===== GIT HEAD & status (skipped - operations blocked) =====

===== .replit =====
--- .replit
modules = ["nodejs-20", "web", "postgresql-16", "python-3.11"]
run = "npm run dev"
hidden = [".config", ".git", "generated-icon.png", "node_modules", "dist"]

[nix]
channel = "stable-24_05"
packages = ["jq"]

[deployment]
deploymentTarget = "autoscale"
build = ["npm", "run", "build"]
run = ["npm", "run", "start"]

[[ports]]
localPort = 5000
externalPort = 80

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Start application"

[[workflows.workflow]]
name = "Start application"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npm run dev"
waitForPort = 5000

[objectStorage]
defaultBucketID = "replit-objstore-4a8bb232-6674-49c7-8ea5-7166ade1f334"

===== vite.config.* =====
--- vite.config.ts
     1	import { defineConfig } from "vite";
     2	import react from "@vitejs/plugin-react";
     3	import path from "path";
     4	import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
     5	
     6	export default defineConfig({
     7	  plugins: [
     8	    react(),
     9	    runtimeErrorOverlay(),
    10	    ...(process.env.NODE_ENV !== "production" &&
    11	    process.env.REPL_ID !== undefined
    12	      ? [
    13	          await import("@replit/vite-plugin-cartographer").then((m) =>
    14	            m.cartographer(),
    15	          ),
    16	        ]
    17	      : []),
    18	  ],
    19	  resolve: {
    20	    alias: {
    21	      "@": path.resolve(import.meta.dirname, "client", "src"),
    22	      "@shared": path.resolve(import.meta.dirname, "shared"),
    23	      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    24	    },
    25	  },
    26	  root: path.resolve(import.meta.dirname, "client"),
    27	  build: {
    28	    outDir: path.resolve(import.meta.dirname, "dist/public"),
    29	    emptyOutDir: true,
    30	  },
    31	});
--- server/vite.ts
     1	import express, { type Express } from "express";
     2	import fs from "fs";
     3	import path from "path";
     4	import { createServer as createViteServer, createLogger } from "vite";
     5	import { type Server } from "http";
     6	import viteConfig from "../vite.config";
     7	import { nanoid } from "nanoid";
     8	
     9	const viteLogger = createLogger();
    10	
    11	export function log(message: string, source = "express") {
    12	  const formattedTime = new Date().toLocaleTimeString("en-US", {
    13	    hour: "numeric",
    14	    minute: "2-digit",
    15	    second: "2-digit",
    16	    hour12: true,
    17	  });
    18	
    19	  console.log(`${formattedTime} [${source}] ${message}`);
    20	}
    21	
    22	export async function setupVite(app: Express, server: Server) {
    23	  const serverOptions = {
    24	    middlewareMode: true,
    25	    hmr: { server },
    26	    allowedHosts: true as const,
    27	  };
    28	
    29	  const vite = await createViteServer({
    30	    ...viteConfig,
    31	    configFile: false,
    32	    customLogger: {
    33	      ...viteLogger,
    34	      error: (msg, options) => {
    35	        viteLogger.error(msg, options);
    36	        process.exit(1);
    37	      },
    38	    },
    39	    server: serverOptions,
    40	    appType: "custom",
    41	  });
    42	
    43	  app.use(vite.middlewares);
    44	  app.use("*", async (req, res, next) => {
    45	    const url = req.originalUrl;
    46	
    47	    try {
    48	      const clientTemplate = path.resolve(
    49	        import.meta.dirname,
    50	        "..",
    51	        "client",
    52	        "index.html",
    53	      );
    54	
    55	      // always reload the index.html file from disk incase it changes
    56	      let template = await fs.promises.readFile(clientTemplate, "utf-8");
    57	      template = template.replace(
    58	        `src="/src/main.tsx"`,
    59	        `src="/src/main.tsx?v=${nanoid()}"`,
    60	      );
    61	      const page = await vite.transformIndexHtml(url, template);
    62	      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    63	    } catch (e) {
    64	      vite.ssrFixStacktrace(e as Error);
    65	      next(e);
    66	    }
    67	  });
    68	}
    69	
    70	export function serveStatic(app: Express) {
    71	  const distPath = path.resolve(import.meta.dirname, "public");
    72	
    73	  if (!fs.existsSync(distPath)) {
    74	    throw new Error(
    75	      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    76	    );
    77	  }
    78	
    79	  app.use(express.static(distPath));
    80	
    81	  // fall through to index.html if the file doesn't exist
    82	  app.use("*", (_req, res) => {
    83	    res.sendFile(path.resolve(distPath, "index.html"));
    84	  });
    85	}

===== server routes (notes endpoints) =====

>> PATCH handler body (context)
2639:   app.patch("/api/notes/:id", async (req, res) => {
    const id = Number(req.params.id);
2640:     const id = Number(req.params.id);
    if (Number.isNaN(id)) return res.status(400).json({ error: 'Bad id' });
2641:     if (Number.isNaN(id)) return res.status(400).json({ error: 'Bad id' });

2642: 
    const { content, doc_json } = req.body ?? {};
2643:     const { content, doc_json } = req.body ?? {};
    if (content == null && doc_json == null)
2644:     if (content == null && doc_json == null)
      return res.status(400).json({ error: 'Nothing to save' });
2645:       return res.status(400).json({ error: 'Nothing to save' });

2646: 
    const updated = await storage.updateNote(id, { content, doc_json });
2647:     const updated = await storage.updateNote(id, { content, doc_json });
    if (!updated) return res.status(404).json({ error: 'Not found' });
2648:     if (!updated) return res.status(404).json({ error: 'Not found' });

2649: 
    res.setHeader('Content-Type', 'application/json');
2650:     res.setHeader('Content-Type', 'application/json');
    res.json(updated);              // <-- ALWAYS JSON, never HTML
2651:     res.json(updated);              // <-- ALWAYS JSON, never HTML
  });
2652:   });

2653: 
  // Todos endpoints
2654:   // Todos endpoints
  app.get("/api/todos", async (req, res) => {
2655:   app.get("/api/todos", async (req, res) => {
    try {
2656:     try {
      const todos = await storage.getTodos();
2657:       const todos = await storage.getTodos();
      res.json(todos);
2658:       res.json(todos);
    } catch (error) {
2659:     } catch (error) {
      res.status(500).json({ message: "Failed to fetch todos" });
2660:       res.status(500).json({ message: "Failed to fetch todos" });
    }
2661:     }
  });
2662:   });

2663: 
  app.patch("/api/todos/:id", async (req, res) => {
2664:   app.patch("/api/todos/:id", async (req, res) => {
    try {
2665:     try {
      const id = parseInt(req.params.id);
2666:       const id = parseInt(req.params.id);
      const todo = await storage.updateTodo(id, req.body);
2667:       const todo = await storage.updateTodo(id, req.body);
      res.json(todo);
2668:       res.json(todo);
    } catch (error) {
2669:     } catch (error) {
      res.status(404).json({ message: "Todo not found" });
2670:       res.status(404).json({ message: "Todo not found" });
    }
2671:     }
  });
2672:   });

2673: 
  // Extract and save tasks from note content
2674:   // Extract and save tasks from note content
  app.put("/api/notes/:id/tasks", async (req, res) => {
2675:   app.put("/api/notes/:id/tasks", async (req, res) => {
    try {
2676:     try {
      const noteId = parseInt(req.params.id);
2677:       const noteId = parseInt(req.params.id);
      const { tasks } = req.body;
2678:       const { tasks } = req.body;

2679: 
      if (!Array.isArray(tasks)) {
2680:       if (!Array.isArray(tasks)) {
        return res.status(400).json({ message: "Tasks must be an array" });
2681:         return res.status(400).json({ message: "Tasks must be an array" });
      }
2682:       }

2683: 
      // Get existing todos for this note
2684:       // Get existing todos for this note
      const existingTodos = await storage.getTodos();
2685:       const existingTodos = await storage.getTodos();
      const noteTodos = existingTodos.filter(t => t.noteId === noteId);
2686:       const noteTodos = existingTodos.filter(t => t.noteId === noteId);

2687: 
      // Create new tasks that don't already exist
2688:       // Create new tasks that don't already exist
      const createdTasks = [];
2689:       const createdTasks = [];
      for (const task of tasks) {
2690:       for (const task of tasks) {
        // Check if task already exists
2691:         // Check if task already exists
        const exists = noteTodos.some(t => 
2692:         const exists = noteTodos.some(t => 
          t.title.toLowerCase() === task.title.toLowerCase()
2693:           t.title.toLowerCase() === task.title.toLowerCase()
        );
2694:         );

2695: 
        if (!exists && task.title && task.title.length > 5) {
2696:         if (!exists && task.title && task.title.length > 5) {
          const newTodo = await storage.createTodo({
2697:           const newTodo = await storage.createTodo({
            noteId,
2698:             noteId,
            title: task.title,
2699:             title: task.title,
            priority: task.priority || 'normal',
2700:             priority: task.priority || 'normal',
            completed: false
2701:             completed: false
          });
2702:           });
          createdTasks.push(newTodo);
2703:           createdTasks.push(newTodo);
        }
2704:         }
      }
2705:       }

2706: 
      res.json({ 
2707:       res.json({ 
        success: true, 
2708:         success: true, 
        created: createdTasks.length,
2709:         created: createdTasks.length,
        tasks: createdTasks 
2710:         tasks: createdTasks 
      });
2711:       });
    } catch (error) {
2712:     } catch (error) {
      console.error("Failed to save tasks:", error);
2713:       console.error("Failed to save tasks:", error);
      res.status(500).json({ message: "Failed to save tasks" });
2714:       res.status(500).json({ message: "Failed to save tasks" });
    }
2715:     }
  });
2716:   });

2717: 
  app.get("/api/todos/:id/context", async (req, res) => {
2718:   app.get("/api/todos/:id/context", async (req, res) => {
    try {
2719:     try {
      const id = parseInt(req.params.id);
2720:       const id = parseInt(req.params.id);
      const todos = await storage.getTodos();
2721:       const todos = await storage.getTodos();
      const todo = todos.find(t => t.id === id);
2722:       const todo = todos.find(t => t.id === id);

2723: 
      if (!todo) {
2724:       if (!todo) {
        return res.status(404).json({ message: "Todo not found" });
2725:         return res.status(404).json({ message: "Todo not found" });
      }
2726:       }

2727: 
      // Get the source note for this todo
2728:       // Get the source note for this todo
      const sourceNote = await storage.getNote(todo.noteId);
2729:       const sourceNote = await storage.getNote(todo.noteId);

2730: 
      // Get related todos from the same note
2731:       // Get related todos from the same note
      const relatedTodos = todos.filter(t => t.noteId === todo.noteId && t.id !== todo.id);
2732:       const relatedTodos = todos.filter(t => t.noteId === todo.noteId && t.id !== todo.id);

2733: 
      // Generate AI context for this specific todo
2734:       // Generate AI context for this specific todo
      const prompt = `Provide intelligent context and insights for this todo item: "${todo.title}"
2735:       const prompt = `Provide intelligent context and insights for this todo item: "${todo.title}"

2736: 
Source context: ${sourceNote?.content || 'No source context available'}
2737: Source context: ${sourceNote?.content || 'No source context available'}

2738: 
Focus on:
2739: Focus on:
1. Why this task is important based on the source context
2740: 1. Why this task is important based on the source context
2. Any helpful tips or considerations for completing this task
2741: 2. Any helpful tips or considerations for completing this task
3. Connections to related information from the source
2742: 3. Connections to related information from the source

2743: 
Provide a concise, actionable response that adds value beyond just the task title.`;
2744: Provide a concise, actionable response that adds value beyond just the task title.`;

2745: 
      try {
2746:       try {
        const aiResult = await analyzeWithOpenAI(prompt, "todo-context");
2747:         const aiResult = await analyzeWithOpenAI(prompt, "todo-context");

2748: 
        const todoContext = {
2749:         const todoContext = {
          todo,
2750:           todo,
          sourceNote,
2751:           sourceNote,
          ai_context: aiResult.enhancedContent || aiResult.suggestion,
2752:           ai_context: aiResult.enhancedContent || aiResult.suggestion,
          insights: [
2753:           insights: [
            aiResult.context,
2754:             aiResult.context,
            ...aiResult.todos.filter((t: string) => t !== todo.title).map((t: string) => `Related: ${t}`)
2755:             ...aiResult.todos.filter((t: string) => t !== todo.title).map((t: string) => `Related: ${t}`)
          ].filter(Boolean),
2756:           ].filter(Boolean),
          relatedTodos
2757:           relatedTodos
        };
2758:         };

        res.json(todoContext);
      } catch (aiError) {
        // Fallback response without AI context if AI fails
        const todoContext = {
          todo,
          sourceNote,
          ai_context: undefined,
          insights: [],
          relatedTodos
        };
        res.json(todoContext);
      }
    } catch (error) {
      console.error("Todo context error:", error);
      res.status(500).json({ message: "Failed to fetch todo context" });
    }
  });

  // Collections endpoints
  app.get("/api/collections", async (req, res) => {
    try {
      const collections = await storage.getCollections();
      const collectionsWithCounts = await Promise.all(
        collections.map(async (collection) => {
          const notes = await storage.getNotesByCollectionId(collection.id);
          // Count only meaningful notes (exclude welcome notes and empty content)
          const meaningfulNotes = notes.filter(note => 
            note.content && 
            note.content.trim().length > 10 && 
            !note.content.startsWith('🎉 Welcome to Mira')
          );

          // Count open todos for this collection
          const openTodoCount = notes.reduce((count, note) => {
            const openTodos = note.todos.filter(todo => !todo.completed);
            return count + openTodos.length;
          }, 0);

          return { 
            ...collection, 
            noteCount: meaningfulNotes.length,
            openTodoCount 
          };
        })
      );
      res.json(collectionsWithCounts);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collections" });
    }
  });

  app.get("/api/collections/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }
      res.json(collection);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collection" });
    }
  });

  app.get("/api/collections/:id/notes", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const notes = await storage.getNotesByCollectionId(id);
      res.json(notes);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collection notes" });
    }
  });

  // GET route for super-note - automatically generates if not exists
  app.get("/api/collections/:id/super-note", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }

      const notes = await storage.getNotesByCollectionId(id);

      // Handle empty collections
      if (notes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `This is your ${collection.name} collection. Start adding notes and they'll appear here with AI-powered insights and organization.`,
          description: "Start adding notes to see them organized here",
          insights: [
            `Your ${collection.name} collection is ready to capture and organize your thoughts.`,
            "Add notes to this collection to see intelligent summaries and connections.",
            "AI will help extract tasks, insights, and organize your content automatically."
          ],
          structuredItems: {
            recommendedActions: [],
            researchResults: [],
            quickInsights: [`Empty ${collection.name} collection - ready for your content`]
          },
          allTodos: [],
          items: [],
          notes: [],
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Filter out notes with no meaningful content
      const meaningfulNotes = notes.filter(note => 
        note.content && 
        note.content.trim().length > 10 && 
        !note.content.startsWith('🎉 Welcome to Mira')
      );

      if (meaningfulNotes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `Your ${collection.name} collection contains ${notes.length} note(s), but they need more content for meaningful analysis.`,
          description: "Add more detailed content to unlock AI insights",
          insights: [
            "Add more detailed content to your notes for better AI insights.",
            `${collection.name} collection is ready for meaningful content.`
          ],
          structuredItems: {
            recommendedActions: [{ 
              title: "Add detailed content", 
              description: "Write more comprehensive notes to unlock AI-powered insights and organization." 
            }],
            researchResults: [],
            quickInsights: [`${notes.length} note(s) in ${collection.name} - add more detail for insights`]
          },
          allTodos: [],
          items: [],
          notes: meaningfulNotes,
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Get all todos from meaningful notes
      const allTodos = meaningfulNotes.flatMap(note => note.todos || []);

      // Get all items from this collection
      const collectionItems = await storage.getItemsByCollectionId(id);

      // Create aggregated content based on collection type
      let collectionContent = '';
      let collectionDescription = '';

      if (collectionItems.length > 0) {
        // Group items by type for better organization
        const itemsByType = collectionItems.reduce((acc: any, item) => {
          const type = item.type || 'item';
          if (!acc[type]) acc[type] = [];
          acc[type].push(item);
          return acc;
        }, {});

        // Create content based on collection type
        const collectionName = collection.name.toLowerCase();
        if (collectionName.includes('movie') || collectionName.includes('tv')) {
          collectionContent = '🎬 Movies & Shows:\n';
          collectionDescription = 'Movies and TV shows to watch';
        } else if (collectionName.includes('book') || collectionName.includes('read')) {
          collectionContent = '📚 Books & Reading:\n';
          collectionDescription = 'Books and reading materials';
        } else if (collectionName.includes('restaurant') || collectionName.includes('food')) {
          collectionContent = '🍽️ Restaurants & Food:\n';
          collectionDescription = 'Places to eat and food to try';
        } else {
          collectionContent = `📋 ${collection.name} Items:\n`;
          collectionDescription = `Items in your ${collection.name} collection`;
        }

        // Add each item as a line
        collectionItems.forEach(item => {
          collectionContent += `• ${item.title}`;
          if (item.description) {
            collectionContent += ` - ${item.description}`;
          }
          collectionContent += '\n';
        });
      } else {
        collectionContent = `Add notes with specific ${collection.name.toLowerCase()} to see them organized here.`;
        collectionDescription = `Items will appear here when extracted from your notes`;
      }

      const superNoteData = {
        collection,
        aggregatedContent: collectionContent,
        description: collectionDescription,
        insights: [
          `${collectionItems.length} individual items tracked`,
          `${allTodos.length} related tasks`,
          `${meaningfulNotes.length} source notes`
        ].filter(Boolean),
        structuredItems: {
          recommendedActions: allTodos.slice(0, 5).map((todo: any) => ({
            title: todo.title,
            description: "Task from your notes",
            noteId: todo.noteId
          })),
          extractedItems: collectionItems.map(item => ({
            title: item.title,
            description: item.description || '',
            type: item.type,
            sourceNoteId: item.sourceNoteId
          })),
          quickInsights: [
            `${collectionItems.length} items extracted`,
            `${allTodos.length} tasks available`,
            `${meaningfulNotes.length} notes in collection`
          ]
        },
        allTodos: allTodos,
        items: collectionItems,
        notes: meaningfulNotes,
        itemCount: collectionItems.length,
        todoCount: allTodos.length
      };

      res.json(superNoteData);
    } catch (error) {
      console.error("Super note fetch error:", error);
      res.status(500).json({ message: "Failed to fetch super note" });
    }
  });

  app.post("/api/collections/:id/super-note", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }

      const notes = await storage.getNotesByCollectionId(id);

      // Handle empty collections
      if (notes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `This is your ${collection.name} collection. Start adding notes and they'll appear here with AI-powered insights and organization.`,
          insights: [
            `Your ${collection.name} collection is ready to capture and organize your thoughts.`,
            "Add notes to this collection to see intelligent summaries and connections.",
            "AI will help extract tasks, insights, and organize your content automatically."
          ],
          structuredItems: {
            recommendedActions: [],
            researchResults: [],
            quickInsights: [`Empty ${collection.name} collection - ready for your content`]
          },
          allTodos: [],
          notes: [],
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Filter out notes with no meaningful content
      const meaningfulNotes = notes.filter(note => 
        note.content && 
        note.content.trim().length > 10 && 
        !note.content.startsWith('🎉 Welcome to Mira')
      );

      if (meaningfulNotes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `Your ${collection.name} collection contains ${notes.length} note(s), but they need more content for meaningful analysis.`,
          insights: [
            "Add more detailed content to your notes for better AI insights.",
            `${collection.name} collection is ready for meaningful content.`
          ],
          structuredItems: {
            recommendedActions: [{ 
              title: "Add detailed content", 
              description: "Write more comprehensive notes to unlock AI-powered insights and organization." 
            }],
            researchResults: [],
            quickInsights: [`${notes.length} note(s) in ${collection.name} - add more detail for insights`]
          },
          allTodos: [],
          notes: meaningfulNotes,
          itemCount: meaningfulNotes.length,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Get individual items extracted from notes in this collection
      const collectionItems = await storage.getItemsByCollectionId(id);
      const allTodos = meaningfulNotes.flatMap(note => note.todos || []);

      // Create collection-specific content based on type
      let collectionContent = "";
      let collectionDescription = "";

      const collectionName = collection.name.toLowerCase();

      if (collectionName.includes('book')) {
        collectionDescription = "Your reading list and book recommendations";
        collectionContent = collectionItems.length > 0 
          ? `📚 Books in your collection:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No books have been extracted yet. Add notes mentioning specific books to see them here.";
      } else if (collectionName.includes('movie') || collectionName.includes('tv')) {
        collectionDescription = "Movies and TV shows to watch";
        collectionContent = collectionItems.length > 0 
          ? `🎬 Movies & Shows:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No movies or shows have been extracted yet. Add notes mentioning specific titles to see them here.";
      } else if (collectionName.includes('restaurant') || collectionName.includes('food')) {
        collectionDescription = "Places to eat and food recommendations";
        collectionContent = collectionItems.length > 0 
          ? `🍽️ Restaurants & Food:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No restaurants have beenextracted yet. Add notes mentioning specific places to eat to see them here.";
      } else if (collectionName.includes('product')) {
        collectionDescription = "Products and items of interest";
        collectionContent = collectionItems.length > 0 
          ? `🛍️ Products:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No products have been extracted yet. Add notes mentioning specific products to see them here.";
      } else if (collectionName.includes('place') || collectionName.includes('travel')) {
        collectionDescription = "Places to visit and travel destinations";
        collectionContent = collectionItems.length > 0 
          ? `📍 Places:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No places have been extracted yet. Add notes mentioning specific locations to see them here.";
      } else if (collectionName.includes('person') || collectionName.includes('contact')) {
        collectionDescription = "People and contacts";
        collectionContent = collectionItems.length > 0 
          ? `👥 People:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No people have been extracted yet. Add notes mentioning specific individuals to see them here.";
      } else {
        // Generic collection
        collectionDescription = `Your ${collection.name} collection`;
        collectionContent = collectionItems.length > 0 
          ? `📋 Items:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : `No specific items have been extracted yet. Add notes with specific ${collection.name.toLowerCase()} to see them organized here.`;
      }

      const superNoteData = {
        collection,
        aggregatedContent: collectionContent,
        description: collectionDescription,
        insights: [
          `${collectionItems.length} individual items tracked`,
          `${allTodos.length} related tasks`,
          `${meaningfulNotes.length} source notes`
        ].filter(Boolean),
        structuredItems: {
          recommendedActions: allTodos.slice(0, 5).map(todo => ({
            title: todo.title,
            description: "Task from your notes",
            noteId: todo.noteId
          })),
          extractedItems: collectionItems.map(item => ({
            title: item.title,
            description: item.description || '',
            type: item.type,
            sourceNoteId: item.sourceNoteId
          })),
          quickInsights: [
            `${collectionItems.length} items extracted`,
            `${allTodos.length} tasks available`,
            `${meaningfulNotes.length} notes in collection`
          ]
        },
        allTodos: allTodos,
        items: collectionItems,
        notes: meaningfulNotes,
        itemCount: collectionItems.length,
        todoCount: allTodos.length
      };

      res.json(superNoteData);
    } catch (error) {
      console.error("Super note generation error:", error);
      res.status(500).json({ message: "Failed to generate super note" });
    }
  });

  app.post("/api/collections", async (req, res) => {
    try {
      const collectionData = insertCollectionSchema.parse(req.body);
      const collection = await storage.createCollection(collectionData);
      res.json(collection);
    } catch (error) {
      res.status(400).json({ message: "Invalid collection data" });
    }
  });

  app.post("/api/collections/reorder", async (req, res) => {
    try {
      const { updates } = req.body;

      if (!updates || !Array.isArray(updates)) {
        return res.status(400).json({ message: "Updates array required" });
      }

      // Update each collection's display order
      for (const update of updates) {
        await storage.updateCollection(update.id, { displayOrder: update.displayOrder });
      }

      res.json({ success: true });
    } catch (error) {
      console.error("Collection reorder error:", error);
      res.status(500).json({ message: "Failed to reorder collections" });
    }
  });

  // Items API routes
  app.get("/api/items", async (req, res) => {
    try {
      const items = await storage.getItems();
      res.json(items);
    } catch (error) {
      console.error("Failed to fetch items:", error);
      res.status(500).json({ message: "Failed to fetch items" });
    }
  });

  app.get("/api/collections/:id/items", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const items = await storage.getItemsByCollectionId(id);
      res.json(items);
    } catch (error) {
      console.error("Failed to fetch collection items:", error);
      res.status(500).json({ message: "Failed to fetch collection items" });
    }
  });

  app.post("/api/items", async (req, res) => {
    try {
      const itemData = insertItemSchema.parse(req.body);
      const item = await storage.createItem(itemData);
      res.json(item);
    } catch (error) {
      console.error("Failed to create item:", error);
      res.status(400).json({ message: "Invalid item data" });
    }
  });

  app.patch("/api/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const item = await storage.updateItem(id, updates);
      res.json(item);
    } catch (error) {
      console.error("Failed to update item:", error);
      res.status(500).json({ message: "Failed to update item" });
    }
  });

  app.delete("/api/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteItem(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete item:", error);
      res.status(500).json({ message: "Failed to delete item" });
    }
  });

  // Reminder endpoints for consolidated todo approach
  app.post("/api/reminders", async (req, res) => {
    try {
      const { title, description, reminderTime, todoId, noteId } = req.body;
      const reminder = await storage.createReminder({
        title,
        description,
        reminderTime: new Date(reminderTime),
        todoId,
        noteId
      });
      res.json(reminder);
    } catch (error) {
      console.error("Failed to create reminder:", error);
      res.status(500).json({ message: "Failed to create reminder" });
    }
  });



  // Add optional todo to main todos list
  app.post("/api/todos/add-optional", async (req, res) => {
    try {
      const { title, noteId, description } = req.body;
      const todo = await storage.createTodo({
        title,
        noteId
      });
      res.json(todo);
    } catch (error) {
      console.error("Failed to add optional todo:", error);
      res.status(500).json({ message: "Failed to add optional todo" });
    }
  });

  // Notification system endpoints
  app.get("/api/notifications/status", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const status = notificationSystem.getNotificationStatus();
      res.json(status);
    } catch (error) {
      console.error("Failed to get notification status:", error);
      res.status(500).json({ message: "Failed to get notification status" });
    }
  });

  app.post("/api/notifications/refresh", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      const status = notificationSystem.getNotificationStatus();
      res.json({ message: "Notifications refreshed", status });
    } catch (error) {
      console.error("Failed to refresh notifications:", error);
      res.status(500).json({ message: "Failed to refresh notifications" });
    }
  });

  app.post("/api/todos/:id/toggle", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const todo = await storage.updateTodo(id, { completed: !req.body.completed });

      // If completing a reminder, refresh notification schedules
      if (todo.isActiveReminder) {
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.refreshNotifications();
      }

      res.json(todo);
    } catch (error) {
      console.error("Failed to toggle todo:", error);
      res.status(500).json({ message: "Failed to toggle todo" });
    }
  });

  // Enhanced todo creation for reminders
  app.post("/api/todos", async (req, res) => {
    try {
      const todoData = insertTodoSchema.parse(req.body);

      // Ensure isActiveReminder defaults to false if not specified
      const enhancedTodoData = {
        ...todoData,
        isActiveReminder: todoData.isActiveReminder || false,
        completed: todoData.completed || false,
        archived: todoData.archived || false
      };

      const todo = await storage.createTodo(enhancedTodoData);

      // If this is an active reminder, schedule notifications
      if (todo.isActiveReminder && todo.timeDue) {
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.scheduleNotifications(todo);
      }

      res.json(todo);
    } catch (error) {
      console.error("Failed to create todo:", error);
      res.status(400).json({ message: "Invalid todo data" });
    }
  });

  // Notification system endpoints
  app.get("/api/notifications/status", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const status = notificationSystem.getNotificationStatus();
      res.json(status);
    } catch (error) {
      console.error("Failed to get notification status:", error);
      res.status(500).json({ message: "Failed to get notification status" });
    }
  });

  app.get("/api/notifications/recent", async (req, res) => {
    try {
      // Return recent notifications (placeholder for now)
      res.json({ recent: [] });
    } catch (error) {
      console.error("Failed to get recent notifications:", error);
      res.status(500).json({ message: "Failed to get recent notifications" });
    }
  });

  app.post("/api/notifications/test", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const { title, message, scheduledTime } = req.body;
      
      // Create a test notification
      console.log(`🔔 Test notification: ${title} - ${message} at ${scheduledTime}`);
      
      res.json({ 
        success: true, 
        message: "Test notification created",
        scheduledTime 
      });
    } catch (error) {
      console.error("Failed to create test notification:", error);
      res.status(500).json({ message: "Failed to create test notification" });
    }
  });

  // Reminder state management endpoints
  app.post("/api/reminders/parse", async (req, res) => {
    try {
      const { content } = req.body;
      const { IntelligentReminderParser } = await import('./utils/intelligent-reminder-parser');
      const parsed = IntelligentReminderParser.parseReminder(content);
      
      let timeString = null;
      let leadTime = null;
      
      if (parsed.timeReference) {
        timeString = parsed.timeReference.originalText;
      }
      
      if (parsed.context) {
        leadTime = `${parsed.context.defaultLeadTime}`;
      }
      
      res.json({
        isReminder: parsed.isReminder,
        timeString,
        leadTime,
        dueTime: parsed.timeReference?.parsedTime,
        recurrence: parsed.recurringPattern,
        category: parsed.context?.type,
        urgency: parsed.context?.urgency
      });
    } catch (error) {
      console.error("Failed to parse reminder:", error);
      res.status(500).json({ message: "Failed to parse reminder" });
    }
  });

  app.post("/api/reminders", async (req, res) => {
    try {
      const { content, parsedInfo } = req.body;
      
      // Create note first
      const note = await storage.createNote({
        content,
        mode: "text"
      });

      // Process with AI to create reminder
      const miraModule = await import('./brain/miraAIProcessing');
      const analysis = await miraModule.processNote({
        content,
        mode: "text",
        req
      });

      // Update note with AI analysis
      await storage.updateNote(note.id, {
        content: analysis.title,
        ai_enhanced: true,
        ai_suggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
        ai_context: analysis.summary || "",
        is_processing: false
      });

      // Create reminder todo with proper state
      if (analysis.todos && analysis.todos.length > 0) {
        const todo = analysis.todos[0];
        const reminderData: any = {
          noteId: note.id,
          title: todo.title,
          isActiveReminder: true,
          reminderState: 'active',
          priority: todo.priority || 'medium'
        };

        if (parsedInfo?.dueTime) {
          reminderData.dueDate = new Date(parsedInfo.dueTime);
          reminderData.timeDue = new Date(parsedInfo.dueTime);
        }

        if (parsedInfo?.recurrence) {
          reminderData.recurrenceRule = parsedInfo.recurrence;
        }

        const createdTodo = await storage.createTodo(reminderData);
        
        // Refresh notifications
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.refreshNotifications();

        res.json({
          id: createdTodo.id,
          title: createdTodo.title,
          dueDate: createdTodo.dueDate,
          reminderState: createdTodo.reminderState,
          note: note
        });
      } else {
        res.status(400).json({ message: "Failed to create reminder from input" });
      }
    } catch (error) {
      console.error("Failed to create reminder:", error);
      res.status(500).json({ message: "Failed to create reminder" });
    }
  });

  app.get("/api/reminders", async (req, res) => {
    try {
      const { state } = req.query;
      console.log(`Fetching reminders with state filter: ${state}`);
      
      const todos = await storage.getTodos();
      console.log(`Total todos: ${todos.length}`);
      
      let reminders = todos.filter(todo => todo.isActiveReminder === true);
      console.log(`Filtered active reminders: ${reminders.length}`);
      
      if (state && state !== 'all') {
        reminders = reminders.filter(todo => todo.reminderState === state);
        console.log(`After state filter '${state}': ${reminders.length}`);
      }
      
      // Transform todos to reminder format expected by frontend
      const transformedReminders = reminders.map(todo => ({
        id: todo.id,
        title: todo.title,
        dueDate: todo.dueDate || todo.timeDue,
        reminderState: todo.reminderState || 'active',
        priority: todo.priority,
        reminderType: todo.plannedNotificationStructure?.reminderCategory || 'general',
        completed: todo.completed,
        created_at: todo.created_at
      }));
      
      console.log(`Returning ${transformedReminders.length} transformed reminders`);
      res.json(transformedReminders);
    } catch (error) {
      console.error("Failed to fetch reminders:", error);
      res.status(500).json({ message: "Failed to fetch reminders" });
    }
  });

  app.put("/api/reminders/:id/complete", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        completed: true,
        reminderState: 'completed'
      });
      
      // Refresh notifications
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to complete reminder:", error);
      res.status(500).json({ message: "Failed to complete reminder" });
    }
  });

  app.put("/api/reminders/:id/dismiss", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        reminderState: 'dismissed',
        dismissedAt: new Date()
      });
      
      // Refresh notifications
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to dismiss reminder:", error);
      res.status(500).json({ message: "Failed to dismiss reminder" });
    }
  });

  app.put("/api/reminders/:id/archive", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        reminderState: 'archived',
        archivedAt: new Date()
      });
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to archive reminder:", error);
      res.status(500).json({ message: "Failed to archive reminder" });
    }
  });

  // User reminder settings endpoints
  app.get("/api/user/reminder-settings", async (req, res) => {
    try {
      // For now, return default settings since we don't have user auth
      res.json({
        reminderSettings: {
          defaultLeadTimes: {
            general: 10,
            pickup: 10,
            appointment: 30,
            medication: 0,
            call: 5,
            meeting: 15,
            flight: 120
          },
          autoArchiveAfterDays: 1,
          showOverdueReminders: true,
          enablePushNotifications: true
        }
      });
    } catch (error) {
      console.error("Failed to get reminder settings:", error);
      res.status(500).json({ message: "Failed to get reminder settings" });
    }
  });

  app.put("/api/user/reminder-settings", async (req, res) => {
    try {
      const { reminderSettings } = req.body;
      
      // For now, just return success since we don't have user auth
      // In a real app, this would update the user's settings in the database
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to update reminder settings:", error);
      res.status(500).json({ message: "Failed to update reminder settings" });
    }
  });

  // Archive expired reminders (called by scheduled job)
  app.post("/api/reminders/archive-expired", async (req, res) => {
    try {
      const todos = await storage.getTodos();
      const now = new Date();
      const endOfYesterday = new Date(now);
      endOfYesterday.setDate(endOfYesterday.getDate() - 1);
      endOfYesterday.setHours(23, 59, 59, 999);

      let archivedCount = 0;
      
      for (const todo of todos) {
        if (todo.isActiveReminder && 
            todo.reminderState === 'active' && 
            todo.dueDate && 
            todo.dueDate < endOfYesterday) {
          
          await storage.updateTodo(todo.id, {
            reminderState: 'archived',
            archivedAt: new Date()
          });
          archivedCount++;
        }
      }

      // Refresh notifications after archiving
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();

      res.json({ archivedCount });
    } catch (error) {
      console.error("Failed to archive expired reminders:", error);
      res.status(500).json({ message: "Failed to archive expired reminders" });
    }
  });

  // Cleanup old todos, reminders, and notes
  app.post("/api/cleanup/old-todos-reminders", async (req, res) => {
    try {
      // Get current state
      const todos = await storage.getTodos();
      const notes = await storage.getNotes();
      
      console.log(`Total todos before cleanup: ${todos.length}`);
      console.log(`Total notes before cleanup: ${notes.length}`);

      // Separate todos and reminders
      const regularTodos = todos.filter(todo => !todo.isActiveReminder);
      const reminders = todos.filter(todo => todo.isActiveReminder === true);

      console.log(`Regular todos: ${regularTodos.length}, Reminders: ${reminders.length}`);

      // Sort by creation date (oldest first)
      const sortedTodos = regularTodos.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
      const sortedReminders = reminders.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
      const sortedNotes = notes.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());

      // Calculate how many to delete
      const todosToDeleteCount = Math.floor(sortedTodos.length * 0.8); // 80% of todos
      const remindersToDeleteCount = Math.floor(sortedReminders.length * 0.6); // 60% of reminders
      const notesToDeleteCount = Math.floor(sortedNotes.length * 0.8); // 80% of notes

      console.log(`Will delete ${todosToDeleteCount} todos, ${remindersToDeleteCount} reminders, and ${notesToDeleteCount} notes`);

      let deletedCount = 0;

      // Delete oldest 80% of todos
      const todosToDelete = sortedTodos.slice(0, todosToDeleteCount);
      for (const todo of todosToDelete) {
        try {
          await storage.deleteTodo(todo.id);
          deletedCount++;
          console.log(`Deleted todo: "${todo.title}" (created: ${todo.created_at})`);
        } catch (error) {
          console.error(`Failed to delete todo ${todo.id}:`, error);
        }
      }

      // Delete oldest 60% of reminders
      const remindersToDelete = sortedReminders.slice(0, remindersToDeleteCount);
      for (const reminder of remindersToDelete) {
        try {
          await storage.deleteTodo(reminder.id);
          deletedCount++;
          console.log(`Deleted reminder: "${reminder.title}" (created: ${reminder.created_at})`);
        } catch (error) {
          console.error(`Failed to delete reminder ${reminder.id}:`, error);
        }
      }

      // Delete oldest 80% of notes
      const notesToDelete = sortedNotes.slice(0, notesToDeleteCount);
      for (const note of notesToDelete) {
        try {
          await storage.deleteNote(note.id);
          deletedCount++;
          console.log(`Deleted note: "${note.content.slice(0, 50)}..." (created: ${note.created_at})`);
        } catch (error) {
          console.error(`Failed to delete note ${note.id}:`, error);
        }
      }

      // Refresh notifications after cleanup
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();

      const finalTodos = await storage.getTodos();
      const finalNotes = await storage.getNotes();
      
      console.log(`Total todos after cleanup: ${finalTodos.length}`);
      console.log(`Total notes after cleanup: ${finalNotes.length}`);

      res.json({
        success: true,
        deletedCount,
        breakdown: {
          todosDeleted: todosToDeleteCount,
          remindersDeleted: remindersToDeleteCount,
          notesDeleted: notesToDeleteCount,
          remainingTodos: finalTodos.filter(t => !t.isActiveReminder).length,
          remainingReminders: finalTodos.filter(t => t.isActiveReminder === true).length,
          remainingNotes: finalNotes.length
        },
        message: `Successfully deleted ${deletedCount} items (${todosToDeleteCount} todos + ${remindersToDeleteCount} reminders + ${notesToDeleteCount} notes)`
      });

    } catch (error) {
      console.error("Cleanup operation failed:", error);
      res.status(500).json({ 
        success: false,
        message: "Failed to cleanup old todos, reminders, and notes",
        error: error.message 
      });
    }
  });

  // Create and return HTTP server
  const server = createServer(app);
  return server;
}

>> POST /api/notes/:id handler (context)
389:   app.post("/api/notes/:id/v3-process", async (req, res) => {
    try {
390:     try {
      const { id } = req.params;
391:       const { id } = req.params;
      const { instruction, existingContent } = req.body;
392:       const { instruction, existingContent } = req.body;
      
393:       
      if (!isOpenAIAvailable()) {
394:       if (!isOpenAIAvailable()) {
        return res.status(503).json({ error: "AI processing unavailable" });
395:         return res.status(503).json({ error: "AI processing unavailable" });
      }
396:       }

397: 
      // Get the note
398:       // Get the note
      const note = await storage.getNote(parseInt(id));
399:       const note = await storage.getNote(parseInt(id));
      if (!note) {
400:       if (!note) {
        return res.status(404).json({ error: "Note not found" });
401:         return res.status(404).json({ error: "Note not found" });
      }
402:       }

403: 
      // Classify intent and determine processing path
404:       // Classify intent and determine processing path
      const classification = await classifyIntent(instruction || existingContent);
405:       const classification = await classifyIntent(instruction || existingContent);
      const tokenBudget = TOKEN_BUDGETS[classification.intent];
406:       const tokenBudget = TOKEN_BUDGETS[classification.intent];

407: 
      // Build V3 prompt based on processing path
408:       // Build V3 prompt based on processing path
      const prompt = classification.processing_path === 'clarify' 
409:       const prompt = classification.processing_path === 'clarify' 
        ? `You are Mira, an AI assistant. The user needs clarification about: "${instruction || existingContent}"
410:         ? `You are Mira, an AI assistant. The user needs clarification about: "${instruction || existingContent}"

411: 
Provide a helpful, clear response that asks follow-up questions or clarifies ambiguous points. 
412: Provide a helpful, clear response that asks follow-up questions or clarifies ambiguous points. 

413: 
Respond in JSON format:
414: Respond in JSON format:
{
415: {
  "content": "Your clarifying response with questions",
416:   "content": "Your clarifying response with questions",
  "metadata": {
417:   "metadata": {
    "intent": "${classification.intent}",
418:     "intent": "${classification.intent}",
    "confidence": ${classification.confidence},
419:     "confidence": ${classification.confidence},
    "processing_path": "clarify",
420:     "processing_path": "clarify",
    "token_usage": 0,
421:     "token_usage": 0,
    "model": "gpt-4o",
422:     "model": "gpt-4o",
    "timestamp": "${new Date().toISOString()}",
423:     "timestamp": "${new Date().toISOString()}",
    "version": "3.0"
424:     "version": "3.0"
  }
425:   }
}`
426: }`
        : `You are Mira, an AI assistant. Enhance and evolve this content: "${existingContent}"
427:         : `You are Mira, an AI assistant. Enhance and evolve this content: "${existingContent}"

428: 
User instruction: "${instruction || 'Enhance this content'}"
429: User instruction: "${instruction || 'Enhance this content'}"

430: 
Create a comprehensive, strategic analysis that transforms the content into actionable intelligence.
431: Create a comprehensive, strategic analysis that transforms the content into actionable intelligence.

432: 
Respond in JSON format:
433: Respond in JSON format:
{
434: {
  "content": "Enhanced markdown content with strategic analysis",
435:   "content": "Enhanced markdown content with strategic analysis",
  "summary": "Brief summary of key points",
436:   "summary": "Brief summary of key points",
  "tasks": [{"title": "Task title", "priority": "medium", "confidence": 0.8}],
437:   "tasks": [{"title": "Task title", "priority": "medium", "confidence": 0.8}],
  "entities": [{"type": "person", "value": "Entity name", "confidence": 0.9}],
438:   "entities": [{"type": "person", "value": "Entity name", "confidence": 0.9}],
  "links": [{"url": "https://example.com", "title": "Link title", "description": "Description"}],
439:   "links": [{"url": "https://example.com", "title": "Link title", "description": "Description"}],
  "metadata": {
440:   "metadata": {
    "intent": "${classification.intent}",
441:     "intent": "${classification.intent}",
    "confidence": ${classification.confidence},
442:     "confidence": ${classification.confidence},
    "processing_path": "evolve",
443:     "processing_path": "evolve",
    "token_usage": 0,
444:     "token_usage": 0,
    "model": "gpt-4o", 
445:     "model": "gpt-4o", 
    "timestamp": "${new Date().toISOString()}",
446:     "timestamp": "${new Date().toISOString()}",
    "version": "3.0"
447:     "version": "3.0"
  }
448:   }
}`;
449: }`;

450: 
      // Process with OpenAI
451:       // Process with OpenAI
      const response = await analyzeWithOpenAI(prompt, 'v3-processing');
452:       const response = await analyzeWithOpenAI(prompt, 'v3-processing');
      
453:       
      // Parse and validate response
454:       // Parse and validate response
      let mira_response: MiraResponseSchema;
455:       let mira_response: MiraResponseSchema;
      try {
456:       try {
        // Handle response format - OpenAI returns object, we need JSON string for parsing
457:         // Handle response format - OpenAI returns object, we need JSON string for parsing
        if (typeof response === 'object' && response !== null) {
458:         if (typeof response === 'object' && response !== null) {
          // Direct object response from OpenAI - use as-is
459:           // Direct object response from OpenAI - use as-is
          mira_response = response as MiraResponseSchema;
460:           mira_response = response as MiraResponseSchema;
        } else if (typeof response === 'string') {
461:         } else if (typeof response === 'string') {
          // String response - parse JSON
462:           // String response - parse JSON
          mira_response = JSON.parse(response);
463:           mira_response = JSON.parse(response);
        } else {
464:         } else {
          throw new Error('Invalid response format from AI');
465:           throw new Error('Invalid response format from AI');
        }
466:         }
        
467:         
        // Ensure metadata exists and update token usage
468:         // Ensure metadata exists and update token usage
        if (!mira_response.metadata) {
469:         if (!mira_response.metadata) {
          mira_response.metadata = {
470:           mira_response.metadata = {
            intent: classification.intent,
471:             intent: classification.intent,
            confidence: classification.confidence,
472:             confidence: classification.confidence,
            processing_path: classification.processing_path,
473:             processing_path: classification.processing_path,
            token_usage: 0,
474:             token_usage: 0,
            model: 'gpt-4o',
475:             model: 'gpt-4o',
            timestamp: new Date().toISOString(),
476:             timestamp: new Date().toISOString(),
            version: '3.0'
477:             version: '3.0'
          };
478:           };
        }
479:         }
        mira_response.metadata.token_usage = prompt.length + (typeof response === 'string' ? response.length : JSON.stringify(response).length); // Approximate
480:         mira_response.metadata.token_usage = prompt.length + (typeof response === 'string' ? response.length : JSON.stringify(response).length); // Approximate
      } catch (error) {
481:       } catch (error) {
        console.error('Failed to parse V3 response:', error, 'Response:', response);
482:         console.error('Failed to parse V3 response:', error, 'Response:', response);
        return res.status(500).json({ error: 'Invalid AI response format' });
483:         return res.status(500).json({ error: 'Invalid AI response format' });
      }
484:       }

485: 
      // Update note with V3 response
486:       // Update note with V3 response
      await storage.updateNote(parseInt(id), {
487:       await storage.updateNote(parseInt(id), {
        mira_response: JSON.stringify(mira_response),
488:         mira_response: JSON.stringify(mira_response),
        mira_response_created_at: new Date(),
489:         mira_response_created_at: new Date(),
        ai_enhanced: true
490:         ai_enhanced: true
      });
491:       });

492: 
      res.json({ 
493:       res.json({ 
        success: true, 
494:         success: true, 
        mira_response,
495:         mira_response,
        classification 
496:         classification 
      });
497:       });

498: 
    } catch (error) {
499:     } catch (error) {
      console.error('V3 processing error:', error);
500:       console.error('V3 processing error:', error);
      res.status(500).json({ error: 'Failed to process with V3 pipeline' });
501:       res.status(500).json({ error: 'Failed to process with V3 pipeline' });
    }
502:     }
  });
503:   });

504: 
  // Document patch endpoint for TipTap editor
505:   // Document patch endpoint for TipTap editor
  app.post("/api/notes/:id/patch", async (req, res) => {
506:   app.post("/api/notes/:id/patch", async (req, res) => {
    try {
507:     try {
      const { id } = req.params;
508:       const { id } = req.params;
      const { doc, steps } = req.body;
509:       const { doc, steps } = req.body;
      
510:       
      if (!doc) {
511:       if (!doc) {
        return res.status(400).json({ error: "Document JSON required" });
512:         return res.status(400).json({ error: "Document JSON required" });
      }
513:       }
      
514:       
      // Update the note's doc_json
515:       // Update the note's doc_json
      await storage.updateNote(parseInt(id), {
516:       await storage.updateNote(parseInt(id), {
        doc_json: doc
517:         doc_json: doc
      });
518:       });
      
519:       
      // Broadcast to SSE clients if steps provided
520:       // Broadcast to SSE clients if steps provided
      if (steps) {
521:       if (steps) {
        // TODO: Broadcast patch event via SSE
522:         // TODO: Broadcast patch event via SSE
      }
523:       }
      
524:       
      res.json({ success: true });
525:       res.json({ success: true });
    } catch (error) {
526:     } catch (error) {
      console.error("Error patching document:", error);
527:       console.error("Error patching document:", error);
      res.status(500).json({ error: "Failed to patch document" });
528:       res.status(500).json({ error: "Failed to patch document" });
    }
529:     }
  });
530:   });

531: 
  // Notes endpoints with todos
532:   // Notes endpoints with todos
  app.get("/api/notes", async (req, res) => {
533:   app.get("/api/notes", async (req, res) => {
    try {
534:     try {
      const notes = await storage.getNotes();
535:       const notes = await storage.getNotes();
      
536:       
      // Fetch todos for each note and attach them
537:       // Fetch todos for each note and attach them
      const notesWithTodos = await Promise.all(
538:       const notesWithTodos = await Promise.all(
        notes.map(async (note) => {
539:         notes.map(async (note) => {
          try {
540:           try {
            const todos = await storage.getTodosByNoteId(note.id);
541:             const todos = await storage.getTodosByNoteId(note.id);
            const normalizedNote = normalizeNote(note);
542:             const normalizedNote = normalizeNote(note);
            return { ...normalizedNote, todos: todos.filter(t => !t.archived) };
543:             return { ...normalizedNote, todos: todos.filter(t => !t.archived) };
          } catch (error) {
544:           } catch (error) {
            console.warn(`Failed to fetch todos for note ${note.id}:`, error);
545:             console.warn(`Failed to fetch todos for note ${note.id}:`, error);
            const normalizedNote = normalizeNote(note);
546:             const normalizedNote = normalizeNote(note);
            return { ...normalizedNote, todos: [] };
547:             return { ...normalizedNote, todos: [] };
          }
548:           }
        })
549:         })
      );
550:       );
      
551:       
      res.setHeader('Cache-Control', 'private, max-age=0, must-revalidate');
552:       res.setHeader('Cache-Control', 'private, max-age=0, must-revalidate');
      res.json(notesWithTodos);
553:       res.json(notesWithTodos);
    } catch (error) {
554:     } catch (error) {
      console.error("Error fetching notes with todos:", error);
555:       console.error("Error fetching notes with todos:", error);
      res.status(500).json({ message: "Failed to fetch notes" });
556:       res.status(500).json({ message: "Failed to fetch notes" });
    }
557:     }
  });
558:   });

559: 
  app.get("/api/notes/:id", async (req, res) => {
560:   app.get("/api/notes/:id", async (req, res) => {
    try {
561:     try {
      const id = parseInt(req.params.id);
562:       const id = parseInt(req.params.id);
      const note = await storage.getNote(id);
563:       const note = await storage.getNote(id);
      if (!note) {
564:       if (!note) {
        return res.status(404).json({ message: "Note not found" });
565:         return res.status(404).json({ message: "Note not found" });
      }
566:       }
      
567:       
      // Fetch todos for this note
568:       // Fetch todos for this note
      try {
569:       try {
        const todos = await storage.getTodosByNoteId(id);
570:         const todos = await storage.getTodosByNoteId(id);
        const normalizedNote = normalizeNote(note);
571:         const normalizedNote = normalizeNote(note);
        const noteWithTodos = { ...normalizedNote, todos: todos.filter(t => !t.archived) };
572:         const noteWithTodos = { ...normalizedNote, todos: todos.filter(t => !t.archived) };
        res.setHeader('Cache-Control', 'private, max-age=0, must-revalidate');
573:         res.setHeader('Cache-Control', 'private, max-age=0, must-revalidate');
        res.json(noteWithTodos);
574:         res.json(noteWithTodos);
      } catch (error) {
575:       } catch (error) {
        console.warn(`Failed to fetch todos for note ${id}:`, error);
576:         console.warn(`Failed to fetch todos for note ${id}:`, error);
        const normalizedNote = normalizeNote(note);
577:         const normalizedNote = normalizeNote(note);
        res.json({ ...normalizedNote, todos: [] });
578:         res.json({ ...normalizedNote, todos: [] });
      }
579:       }
    } catch (error) {
580:     } catch (error) {
      console.error("Error fetching note:", error);
581:       console.error("Error fetching note:", error);
      res.status(500).json({ message: "Failed to fetch note" });
582:       res.status(500).json({ message: "Failed to fetch note" });
    }
583:     }
  });
584:   });

585: 
  // Get items for a specific note
586:   // Get items for a specific note
  app.get("/api/notes/:id/items", async (req, res) => {
587:   app.get("/api/notes/:id/items", async (req, res) => {
    try {
588:     try {
      const noteId = parseInt(req.params.id);
589:       const noteId = parseInt(req.params.id);
      const items = await storage.getItemsByNoteId(noteId);
590:       const items = await storage.getItemsByNoteId(noteId);
      res.json(items);
591:       res.json(items);
    } catch (error) {
592:     } catch (error) {
      console.error("Error fetching items:", error);
593:       console.error("Error fetching items:", error);
      res.status(500).json({ message: "Failed to fetch items" });
594:       res.status(500).json({ message: "Failed to fetch items" });
    }
595:     }
  });
596:   });

597: 
  app.delete("/api/notes/:id", async (req, res) => {
598:   app.delete("/api/notes/:id", async (req, res) => {
    try {
599:     try {
      const id = parseInt(req.params.id);
600:       const id = parseInt(req.params.id);
      const note = await storage.getNote(id);
601:       const note = await storage.getNote(id);
      if (!note) {
602:       if (!note) {
        return res.status(404).json({ message: "Note not found" });
603:         return res.status(404).json({ message: "Note not found" });
      }
604:       }
      await storage.deleteNote(id);
605:       await storage.deleteNote(id);
      res.json({ message: "Note deleted successfully" });
606:       res.json({ message: "Note deleted successfully" });
    } catch (error) {
607:     } catch (error) {
      res.status(500).json({ message: "Failed to delete note" });
608:       res.status(500).json({ message: "Failed to delete note" });
    }
609:     }
  });
610:   });

611: 
  // SSE endpoint for note events
612:   // SSE endpoint for note events
  app.get('/api/notes/:id/events', (req, res) => {
613:   app.get('/api/notes/:id/events', (req, res) => {
    const { id } = req.params;
614:     const { id } = req.params;
    res.writeHead(200, {
615:     res.writeHead(200, {
      'Content-Type': 'text/event-stream',
616:       'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
617:       'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
618:       'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*'
619:       'Access-Control-Allow-Origin': '*'
    });
620:     });
    
621:     
    // Register client for real-time updates
622:     // Register client for real-time updates
    registerClient(parseInt(id), res);
623:     registerClient(parseInt(id), res);
    
624:     
    // Send initial connection confirmation
625:     // Send initial connection confirmation
    res.write(`data: ${JSON.stringify({ type: 'connected', noteId: id })}\n\n`);
  });

  // SSE endpoint for real-time note updates
  app.get('/api/realtime-updates', (req, res) => {
    const clientId = `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Cache-Control'
    });

    // Send initial connection message
    res.write(`data: ${JSON.stringify({ type: 'connected', clientId })}\n\n`);

    // Add client to notification system
    import('./utils/real-time-notifications').then(({ realTimeNotifications }) => {
      realTimeNotifications.addClient(clientId, res);
      
      // Clean up on client disconnect
      req.on('close', () => {
        realTimeNotifications.removeClient(clientId);
      });
    }).catch(err => {
      console.error('Failed to setup real-time connection:', err);
      res.end();
    });
  });

  // Reprocess existing note endpoint
  app.post("/api/reprocess-note", async (req, res) => {
    try {
      const { noteId } = req.body;
      
      if (!noteId) {
        return res.status(400).json({ message: "noteId is required" });
      }
      
      // Get the existing note
      const note = await storage.getNote(parseInt(noteId));
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }
      
      // Reset processing state
      await storage.updateNote(noteId, {
        is_processing: true,
        ai_enhanced: false,
        rich_context: null,
        ai_suggestion: null,
        ai_context: null
      });
      
      // Load user profile for bio integration
      const userProfile = await storage.getUser("demo");
      
      const miraInput = {
        id: noteId.toString(),
        content: note.content,
        mode: note.mode as 'text' | 'image' | 'voice',
        userId: "demo",
        userProfile,
        media_url: note.media_url,
        audio_url: note.audio_url,
        transcription: note.transcription
      };
      
      // Process with AI
      const miraModule = await import('./brain/miraAIProcessing');
      console.log("Reprocessing note:", noteId, "with content:", note.content.substring(0, 100));
      console.log('🔍 [REPROCESS] launching processNoteAsync');
      
      miraModule.processNote(miraInput)
        .then(async (analysis: any) => {
          console.log("✅ [REPROCESS] Promise resolved successfully");
          console.log("=== REPROCESS DEBUG ===");
          console.log("Analysis result:", JSON.stringify(analysis, null, 2));
          console.log("=== END REPROCESS DEBUG ===");
          
          const parsed = analysis.rich_context || analysis;
          
          // Persist side effects
          const { persistSideEffects } = await import('./ai/persist-side-effects');
          await persistSideEffects(parsed, noteId);
          
          // Update note with results
          await storage.updateNote(noteId, {
            ai_generated_title: parsed.title,
            rich_context: JSON.stringify(parsed),
            ai_enhanced: true,
            is_processing: false,
            ai_suggestion: parsed.perspective || '',
            ai_context: "Reprocessed with V2"
          });
          
          console.log("Reprocessing completed for note:", noteId);
        })
        .catch(async (error) => {
          console.error("Reprocessing failed for note:", noteId, error);
          await storage.updateNote(noteId, { 
            is_processing: false,
            ai_context: "Reprocessing failed"
          });
        });
      
      res.json({ message: "Note reprocessing started", noteId });
    } catch (error) {
      console.error("Reprocess endpoint error:", error);
      res.status(500).json({ message: "Failed to start reprocessing" });
    }
  });

  app.post("/api/notes", async (req, res) => {
    try {
      const noteData = insertNoteSchema.parse(req.body);

      // Create the note with processing flag set
      const note = await storage.createNote({
        ...noteData,
        is_processing: noteData.content ? true : false
      });

      // Broadcast note creation for immediate UI updates
      try {
        const { realTimeNotifications } = await import('./utils/real-time-notifications');
        realTimeNotifications.broadcastNoteCreated(note.id, note);
      } catch (error) {
        console.warn('Failed to broadcast note creation:', error);
      }

      // --- BEGIN: V3 Help-First pipeline ------------------
      if (noteData.content) {
        const useV3 = process.env.MIRA_V3_ENABLED?.toLowerCase() === 'true';
        console.log(`🎯 [V3] Feature flag MIRA_V3_ENABLED: ${useV3}`);
        
        if (useV3) {
          console.log(`🎯 [V3] Starting Help-First processing for note ${note.id}`);
          try {
            const { queueEnhancementV3 } = await import('./queue/enhance-v3');
            await queueEnhancementV3(note.id);
            console.log(`✅ [V3] Note ${note.id} queued for Help-First processing`);
            
            // Return immediately - V3 handles all processing
            res.json(note);
            return;
          } catch (queueError) {
            console.error('❌ [V3] Failed to enqueue note for V3 enhancement:', queueError);
            console.error('❌ [V3] Error stack:', queueError.stack);
            // Fall back to legacy V2 processing
          }
        } else {
          console.log(`🔄 [V2] Using legacy processing (V3 disabled)`);
        }
      }
      // --- END: V3 Help-First pipeline --------------------

      // Legacy V2 Process (fallback only)
      if (noteData.content) {
        console.log("Starting AI analysis for note:", note.id, "content length:", noteData.content.length);

        // Use OpenAI if available, fallback to Claude
        const useOpenAI = isOpenAIAvailable();
        console.log("Using AI service:", useOpenAI ? "OpenAI" : "Claude");

        // Import and use new orthogonal AI processing
        const miraModule = await import('./brain/miraAIProcessing');

        // Load user profile for bio integration
        const userProfile = await storage.getUser("demo");
        
        const miraInput = {
          id: note.id.toString(),
          content: noteData.content,
          mode: noteData.mode === 'file' ? 'text' : (noteData.mode as 'text' | 'image' | 'voice'),
          userId: "demo",
          userProfile,
          req: req, // Pass request for location detection
        };

        // Return fast response - let queue handle AI processing
        res.json(note);

        // Keep existing immediate processing as fallback (will be deprecated once queue is stable)
        miraModule.processNote(miraInput)
        .then(async (analysis: any) => {
          console.log("=== FULL AI PROCESSING DEBUG (FALLBACK) ===");
          console.log("1. INPUT TO AI (content only):", { id: miraInput.id, content: miraInput.content, mode: miraInput.mode });
          console.log("2. FULL ANALYSIS OUTPUT:", JSON.stringify(analysis, null, 2));
          console.log("3. ANALYSIS.RICHCONTEXT:", JSON.stringify(analysis.rich_context, null, 2));
          
          const parsed = analysis.rich_context || analysis;
          console.log("4. PARSED VARIABLE:", JSON.stringify(parsed, null, 2));
          console.log("=== END DEBUG ===");
          
          // Persist side effects
          const { persistSideEffects } = await import('./ai/persist-side-effects');
          await persistSideEffects(parsed, note.id);

          // Track usage
          apiUsageStats.totalRequests++;

          // Generate AI title with shorthand and emojis (preserve original content)
          const ai_generated_title = analysis.title || makeTitle(note.content, note.mode);

          // Update note with v2.0 structured AI results - ENSURE rich_context is always populated
          const rich_contextData = {
            entities: analysis.entities || [],
            suggestedLinks: analysis.suggestedLinks || [],
            nextSteps: analysis.nextSteps || [],
            microQuestions: analysis.microQuestions || [],
            fromTheWeb: analysis.fromTheWeb || [],
            timeInstructions: analysis.timeInstructions || {
              hasTimeReference: false,
              extractedTimes: [],
              scheduledItems: []
            }
          };

          // Debug V2 analysis structure
          console.log("V2 Analysis structure:", {
            hasAnalysis: !!analysis,
            hasTodos: !!analysis.todos,
            todosLength: analysis.todos?.length || 0,
            hasNextSteps: !!analysis.nextSteps,
            nextStepsLength: analysis.nextSteps?.length || 0,
            hasEntities: !!analysis.entities,
            entitiesLength: analysis.entities?.length || 0
          });

          const updates: any = {
            ai_generated_title: parsed.title,
            rich_context: JSON.stringify(parsed),
            ai_enhanced: true,
            is_processing: false,
            ai_suggestion: parsed.perspective || '',
            ai_context: "V2 processing completed"
          };

          console.log("Saving analysis data:", analysis);
          console.log("RichContext data:", analysis.rich_context);
          console.log("Full update payload:", JSON.stringify(updates, null, 2));

          try {
            console.log(`Updating note ${note.id} with V2 analysis...`);
            const updatedNote = await storage.updateNote(note.id, updates);
            console.log("Note updated successfully with Mira AI analysis");
            console.log("Updated note confirmation:", updatedNote ? "success" : "failed");
          } catch (updateError) {
            console.error("Failed to update note with AI analysis:", updateError);
            console.error("Update error stack:", updateError.stack);
            // Try a simpler update to ensure something saves
            try {
              await storage.updateNote(note.id, { 
                ai_enhanced: true, 
                is_processing: false,
                ai_context: "V2 processing completed"
              });
              console.log("Fallback update succeeded");
            } catch (fallbackError) {
              console.error("Even fallback update failed:", fallbackError);
            }
          }

          // Create todos from Mira AI v2.0 analysis - filter out generic tasks
          if (analysis.todos && analysis.todos.length > 0) {
            const meaningfulTodos = analysis.todos.filter((todo: any) => 
              todo.title && 
              !todo.title.toLowerCase().includes('research') &&
              !todo.title.toLowerCase().includes('investigation') &&
              !todo.title.toLowerCase().includes('business intelligence') &&
              !todo.title.toLowerCase().includes('deep') &&
              !todo.title.toLowerCase().includes('gathering') &&
              !todo.title.toLowerCase().includes('analysis') &&
              todo.title.length > 10
            );
            
            console.log("Creating", meaningfulTodos.length, "meaningful todos for note:", note.id);
            for (const todo of meaningfulTodos) {
              const todoData: any = {
                noteId: note.id,
                title: todo.title,
              };

              // Apply intelligent reminder parsing to each todo
              const { IntelligentReminderParser } = await import('./utils/intelligent-reminder-parser');
              const reminderInfo = IntelligentReminderParser.parseReminder(todo.title);

              console.log("Creating todo/reminder with data:", {
                title: todo.title,
                isActiveReminder: reminderInfo.isReminder || todo.isActiveReminder,
                timeDue: reminderInfo.timeReference?.parsedTime || todo.timeDue,
                priority: todo.priority || 'medium'
              });

              // Add v2.0 enhanced todo properties
              if (todo.due || reminderInfo.timeReference?.parsedTime) {
                todoData.timeDue = todo.due ? new Date(todo.due) : reminderInfo.timeReference?.parsedTime;
              }
              if (todo.recurrence || reminderInfo.recurringPattern) {
                todoData.recurrenceRule = todo.recurrence || reminderInfo.recurringPattern;
              }
              if (todo.priority || reminderInfo.context?.urgency) {
                todoData.priority = todo.priority || reminderInfo.context.urgency;
              }

              // Mark as active reminder if intelligent parser detected it
              if (reminderInfo.isReminder) {
                todoData.isActiveReminder = true;
                todoData.plannedNotificationStructure = {
                  enabled: true,
                  reminderCategory: reminderInfo.context.category,
                  repeatPattern: reminderInfo.recurringPattern || 'none',
                  leadTimeNotifications: reminderInfo.explicitLeadTime ? 
                    [reminderInfo.explicitLeadTime] : 
                    [reminderInfo.context.defaultLeadTime]
                };
              }

              console.log("Creating v2.0 todo with title:", todo.title);
              const createdTodo = await storage.createTodo(todoData);
              console.log("Successfully created todo/reminder:", createdTodo);

              // Schedule notifications if it's an active reminder
              if (reminderInfo.isReminder && todoData.timeDue) {
                try {
                  const { notificationSystem } = await import('./notification-system');
                  await notificationSystem.refreshNotifications();
                  console.log("Scheduled notifications for active reminder:", todo.title);
                } catch (notificationError) {
                  console.error("Failed to schedule notifications:", notificationError);
                }
              }
            }
          }

          // Create collection if suggested with v2.0 smart mapping
          if (analysis.collectionHint) {
            console.log("Processing v2.0 collection hint:", analysis.collectionHint.name);
            const collections = await storage.getCollections();

            // Smart collection mapping to existing categories
            const suggestedName = analysis.collectionHint.name.toLowerCase();
            let finalCollectionName = analysis.collectionHint.name;

            // Map overly specific collections to existing ones
            if (suggestedName.includes('personal') || suggestedName.includes('communication') || 
                suggestedName.includes('family') || suggestedName.includes('healthcare') || 
                suggestedName.includes('medical') || suggestedName.includes('health') || 
                suggestedName.includes('appointment') || suggestedName.includes('doctor')) {
              finalCollectionName = "Personal";
            } else if (suggestedName.includes('grocery') || suggestedName.includes('shopping') || 
                       suggestedName.includes('errands') || suggestedName.includes('store')) {
              finalCollectionName = "To-dos";
            } else if (suggestedName.includes('work') || suggestedName.includes('office') || 
                       suggestedName.includes('business') || suggestedName.includes('meeting')) {
              finalCollectionName = "Work";
            } else if (suggestedName.includes('home') || suggestedName.includes('house') || 
                       suggestedName.includes('maintenance') || suggestedName.includes('repair')) {
              finalCollectionName = "Home";
            } else if (suggestedName.includes('book') || suggestedName.includes('reading')) {
              finalCollectionName = "Books";
            } else if (suggestedName.includes('movie') || suggestedName.includes('tv') || 
                       suggestedName.includes('film') || suggestedName.includes('entertainment')) {
              finalCollectionName = "Movies & TV";
            } else if (suggestedName.includes('restaurant') || suggestedName.includes('food') || 
                       suggestedName.includes('dining')) {
              finalCollectionName = "Restaurants";
            } else if (suggestedName.includes('travel') || suggestedName.includes('trip') || 
                       suggestedName.includes('vacation')) {
              finalCollectionName = "Travel";
            } else {
              // Default to Other for overly specific suggestions
              finalCollectionName = "Other";
            }

            // Find or create the final collection
            const targetCollection = collections.find(
              c => c.name.toLowerCase() === finalCollectionName.toLowerCase()
            );

            let collection_id = targetCollection?.id;
            if (!targetCollection && finalCollectionName !== "Other") {
              // Only create new collections for broad categories, not specific ones
              const newCollection = await storage.createCollection({
                name: finalCollectionName,
                icon: analysis.collectionHint.icon || "folder",
                color: analysis.collectionHint.colour || "#6366f1"
              });
              collection_id = newCollection.id;
              console.log("Created new broad collection:", finalCollectionName);
            } else if (!targetCollection) {
              // Find Other collection
              const otherCollection = collections.find(c => c.name.toLowerCase() === "other");
              collection_id = otherCollection?.id;
            }

            if (collection_id) {
              await storage.updateNote(note.id, { collection_id });
              console.log("Assigned note to collection:", finalCollectionName);
            }
          }

          // Handle v2.0 knowledge graph entities
          if (analysis.entities && analysis.entities.length > 0) {
            console.log(`Processing ${analysis.entities.length} v2.0 entities`);
            // Future: Store entities in knowledge graph
          }

          // Handle smart actions for UI
          if (analysis.smartActions && analysis.smartActions.length > 0) {
            console.log(`Generated ${analysis.smartActions.length} smart actions`);
            // These are stored in ai_suggestion field for UI consumption
          }
        })
        .catch(async (error) => {
          console.error("AI analysis failed for note:", note.id);
          console.error("Error details:", error.message);
          console.error("Full error:", error);
          await storage.updateNote(note.id, { is_processing: false });
        });
      }
    } catch (error) {
      console.error("Failed to create note:", error);
      res.status(400).json({ message: "Failed to create note", error: error.message });
    }
  });

  // Stage-4A Enhancement Queue Monitoring
  app.get("/api/enhance-queue/stats", async (req, res) => {
    try {
      const { getQueueStats } = await import('./ai/v3/enhance/queue-worker');
      const stats = await getQueueStats();
      res.json(stats);
    } catch (error) {
      console.error('Failed to get queue stats:', error);
      res.status(500).json({ message: 'Failed to get queue stats' });
    }
  });

  app.get("/api/enhance-queue/failed", async (req, res) => {
    try {
      const { getFailedJobs } = await import('./ai/v3/enhance/queue-worker');
      const limit = parseInt(req.query.limit as string) || 10;
      const failedJobs = await getFailedJobs(limit);
      res.json(failedJobs);
    } catch (error) {
      console.error('Failed to get failed jobs:', error);
      res.status(500).json({ message: 'Failed to get failed jobs' });
    }
  });

  // DEPRECATED: Claude comparison endpoint disabled per user request
  // Focus on single AI partner (OpenAI) until main app pathways are rock solid
  app.post("/api/compare-ai", async (req, res) => {
    return res.status(410).json({ 
      message: "AI comparison feature has been deprecated. Focus is on single AI partner (OpenAI) integration.",
      deprecated: true 
    });
  });

  app.post("/api/notes/media", upload.fields([
    { name: 'image', maxCount: 1 },
    { name: 'file', maxCount: 1 },
    { name: 'audio', maxCount: 1 }
  ]), async (req, res) => {
    try {
      console.log("Media upload request received");
      console.log("Body fields:", Object.keys(req.body));
      console.log("Files:", req.files ? Object.keys(req.files) : 'none');

      const { content, mode, hasVoiceContext, aiAnalysis, userContext } = req.body;
      const files = req.files as { [fieldname: string]: Express.Multer.File[] };

      // Validate we have at least one file
      if (!files || Object.keys(files).length === 0) {
        return res.status(400).json({ message: "No files provided" });
      }

      // PRIORITY: User instructions heavily weighted - they indicate high intent
      let noteContent = '';
      let userInstructions = '';

      // Extract and prioritize user instructions
      if (userContext && typeof userContext === 'string' && userContext.trim()) {
        userInstructions = userContext.trim();
        noteContent = userInstructions; // User instructions take priority
      }

      // Add AI analysis as supplementary context only
      if (aiAnalysis && typeof aiAnalysis === 'string' && aiAnalysis.trim()) {
        if (userInstructions) {
          // User provided instructions - AI analysis becomes supporting context
          noteContent = `${userInstructions}\n\n[AI Context: ${aiAnalysis.trim()}]`;
        } else {
          // No user instructions - use AI analysis as primary
          noteContent = aiAnalysis.trim();
        }
      }

      // Fallback to legacy content field if new fields not provided
      if (!noteContent && content && typeof content === 'string') {
        noteContent = content.trim();
      }

      // Handle media files
      let media_url = null;
      let audio_url = null;

      // Process image
      if (files.image && files.image[0]) {
        const savedFile = await saveAudioFile(
          files.image[0].buffer, 
          files.image[0].originalname || 'image.jpg',
          files.image[0].mimetype || 'image/jpeg'
        );
        media_url = savedFile.url;

        // Don't set placeholder text - let AI analysis fill content when ready
      }

      // Process general file
      if (files.file && files.file[0]) {
        const savedFile = await saveAudioFile(files.file[0].buffer, files.file[0].originalname);
        media_url = savedFile.url;

        if (!noteContent.trim()) {
          noteContent = `File uploaded: ${files.file[0].originalname}`;
        }
      }

      // Process voice context with proper error handling
      if (files.audio && files.audio[0]) {
        try {
          console.log("Processing voice context audio, size:", files.audio[0].buffer.length);
          const savedAudio = await saveAudioFile(files.audio[0].buffer, `context-${Date.now()}.webm`);
          audio_url = savedAudio.url;
          console.log("Voice context saved:", audio_url);

          // Transcribe voice context if available
          if (isOpenAIAvailable()) {
            try {
              const transcription = await safeTranscribeAudio(files.audio[0].buffer);
              console.log("Voice context transcribed:", transcription.substring(0, 100));

              // Add transcribed voice context to note content
              if (transcription && transcription.trim()) {
                noteContent = noteContent ? 
                  `${noteContent}\n\n**Voice Context:**\n${transcription.trim()}` : 
                  `**Voice Context:**\n${transcription.trim()}`;
              }
            } catch (transcriptionError) {
              console.error("Voice context transcription failed:", transcriptionError);
              // Continue without transcription
            }
          }
        } catch (audioError) {
          console.error("Voice context processing failed:", audioError);
          // Continue without audio
        }
      }

      // Only use meaningful content - no placeholder text
      if (!noteContent || !noteContent.trim()) {
        noteContent = ""; // Leave empty until AI analysis provides meaningful content
      }

      // Create note with media
      const noteData = {
        content: noteContent,
        mode: mode || 'mixed',
        audio_url: audio_url,
        media_url: media_url,
        is_processing: !!noteContent.trim()
      };

      console.log("Creating note with data:", { 
        contentLength: noteContent.length, 
        hasAudio: !!audio_url, 
        hasMedia: !!media_url 
      });

      const note = await storage.createNote(noteData);

      // Process with AI if content exists
      if (noteContent.trim()) {
        // Special handling for image analysis - BYPASS regular text processing
        if (files.image && files.image[0]) {
          console.log("Processing image with specialized visual recognition");
          console.log("Image buffer size:", files.image[0].buffer.length);
          const imageBase64 = files.image[0].buffer.toString('base64');
          console.log("Base64 length:", imageBase64.length);

          // Use specialized image analysis with user instruction priority
          if (isOpenAIAvailable() && imageBase64.length > 0) {
            console.log("Using GPT-4o for image analysis");
            const { analyzeImageContent } = await import('./openai');

            // Create enhanced prompt that prioritizes user instructions
            let analysisPrompt = noteContent;
            if (userInstructions) {
              analysisPrompt = `USER INSTRUCTIONS (HIGH PRIORITY): ${userInstructions}

Please analyze this image specifically according to the user's instructions above. Their specific request should heavily influence your analysis, todos, and suggestions. Focus on what they asked for rather than general image description.

${aiAnalysis ? `Additional context: ${aiAnalysis}` : ''}`;
            }

            analyzeImageContent(imageBase64, analysisPrompt)
            .then(async (analysis: any) => {
              const updates: any = {
                // Preserve original user content - AI insights go in rich_context, not content
                content: userInstructions || noteContent,
                ai_enhanced: true,
                ai_suggestion: analysis.suggestion,
                ai_context: analysis.context,
                rich_context: analysis.rich_context ? JSON.stringify(analysis.rich_context) : null,
                is_processing: false,
              };

              await storage.updateNote(note.id, updates);

              // Create todos from analysis
              if (analysis.todos && analysis.todos.length > 0) {
                for (const todo of analysis.todos) {
                  if (typeof todo === 'string') {
                    await storage.createTodo({ noteId: note.id, title: todo });
                  }
                }
              }

              // Handle collection suggestion and item extraction
              let collection_id = null;
              if (analysis.collectionSuggestion) {
                try {
                  // Create or find the suggested collection
                  const existingCollections = await storage.getCollections();
                  let targetCollection = existingCollections.find(c => 
                    c.name.toLowerCase().includes(analysis.collectionSuggestion.name.toLowerCase()) ||
                    analysis.collectionSuggestion.name.toLowerCase().includes(c.name.toLowerCase())
                  );

                  if (!targetCollection) {
                    targetCollection = await storage.createCollection({
                      name: analysis.collectionSuggestion.name,
                      icon: analysis.collectionSuggestion.icon || "📚",
                      color: analysis.collectionSuggestion.color || "#8B4513"
                    });
                  }

                  collection_id = targetCollection.id;

                  // Update note to belong to this collection
                  await storage.updateNote(note.id, { collection_id });

                } catch (error) {
                  console.error("Error creating/assigning collection:", error);
                }
              }

              // Create individual items from extracted items
              if (analysis.extractedItems && analysis.extractedItems.length > 0) {
                for (const item of analysis.extractedItems) {
                  try {
                    // Create the item first
                    const createdItem = await storage.createItem({
                      title: item.title,
                      type: item.category || "item",
                      description: item.description || "",
                      context: `Extracted from image analysis`,
                      sourceNoteId: note.id,
                      collection_id: collection_id
                    });

                    // Auto-generate shopping links for products
                    if (item.category === 'product' || item.category === 'book') {
                      setTimeout(async () => {
                        try {
                          const { performLocationWebSearch } = await import('./web-search');
                          const searchQueries = [`${item.title} buy online`, `${item.title} shop`, `where to buy ${item.title}`];
                          const searchResults = await performLocationWebSearch(searchQueries);

                          if (searchResults && searchResults.length > 0) {
                            const shoppingLinks = searchResults.map((result: any) => ({
                              title: result.title,
                              url: result.url,
                              description: result.description
                            }));

                            // Update item with shopping links
                            await storage.updateItem(createdItem.id, {
                              detailedContent: JSON.stringify({
                                shoppingLinks,
                                searchQueries,
                                lastUpdated: new Date().toISOString()
                              })
                            });
                          }
                        } catch (error) {
                          console.error("Error generating shopping links:", error);
                        }
                      }, 1000); // Delay to avoid overwhelming the search API
                    }
                  } catch (error) {
                    console.error("Error creating item:", error);
                  }
                }
              }
            })
            .catch((error: any) => {
              console.error("Error analyzing image:", error);
              storage.updateNote(note.id, { is_processing: false });
            });
          } else if (isOpenAIAvailable() && imageBase64.length > 0) {
            console.log("Using OpenAI for image analysis");
            const { analyzeImageContent } = await import('./anthropic');
            analyzeImageContent(imageBase64, noteContent)
            .then(async (analysis: any) => {
              const updates: any = {
                content: analysis.enhancedContent || noteContent,
                ai_enhanced: true,
                ai_suggestion: analysis.suggestion,
                ai_context: analysis.context,
                rich_context: analysis.rich_context ? JSON.stringify(analysis.rich_context) : null,
                is_processing: false,
              };

              await storage.updateNote(note.id, updates);
            })
            .catch((error: any) => {
              console.error("Error analyzing image with Claude:", error);
              storage.updateNote(note.id, { is_processing: false });
            });
          } else {
            // No AI available for image analysis
            storage.updateNote(note.id, { 
              content: "Image Upload Complete",
              is_processing: false 
            });
          }

          // Skip regular text processing for image notes - they're handled above
          return res.json(note);
        } else {
          // Regular text/audio processing
          const useOpenAI = isOpenAIAvailable();

          const miraInput: MiraAIInput = {
            content: noteContent,
            mode: noteData.mode as any,
            timestamp: new Date().toISOString(),
            context: {
              timeOfDay: new Date().toLocaleTimeString(),
              recentActivity: []
            }
          };

          const aiAnalysisFunction = useOpenAI 
            ? (prompt: string) => safeAnalyzeWithOpenAI(prompt, noteData.mode)
            : (prompt: string) => analyzeWithOpenAI(prompt, noteData.mode);

          processNote(miraInput)
          .then(async (analysis: MiraAIResult) => {
            console.log("Mira AI analysis successful for note:", note.id);

            apiUsageStats.openai.requests++;
            apiUsageStats.totalRequests++;

            // Use v2.0 structured results
            const updates: any = {
              ai_enhanced: true,
              ai_suggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
              ai_context: analysis.summary || "",
              rich_context: analysis.entities ? JSON.stringify({
                entities: analysis.entities,
                suggestedLinks: analysis.suggestedLinks,
                nextSteps: analysis.nextSteps,
                microQuestions: analysis.microQuestions,
                timeInstructions: analysis.timeInstructions
              }) : null,
              is_processing: false,
            };

            await storage.updateNote(note.id, updates);

            // Create todos if found
            if (analysis.todos && analysis.todos.length > 0) {
              for (const todo of analysis.todos) {
                try {
                  const todoData = {
                    title: todo.title,
                    isCompleted: false,
                    priority: todo.priority || 'medium',
                    due: todo.due || null,
                    noteId: note.id,
                    isTimeDependent: !!todo.due,
                    notificationSchedule: todo.due ? [todo.due] : null
                  };

                  await storage.createTodo(todoData);
                  console.log("Created todo:", todo.title);
                } catch (todoError) {
                  console.error("Error creating todo:", todoError);
                }
              }
            }

            // Create reminders if found
            if (analysis.reminders && analysis.reminders.length > 0) {
              for (const reminder of analysis.reminders) {
                try {
                  const reminderData = {
                    title: reminder.title,
                    completed: false,
                    priority: 'high',
                    noteId: note.id,
                    isActiveReminder: true,
                    reminderState: 'active',
                    dueDate: reminder.dueTime ? new Date(reminder.dueTime) : null,
                    timeDue: reminder.dueTime ? new Date(reminder.dueTime) : null
                  };

                  await storage.createTodo(reminderData);
                  console.log("Created reminder:", reminder.title, "for", reminder.dueTime);
                } catch (reminderError) {
                  console.error("Error creating reminder:", reminderError);
                }
              }
            }

            // Also check if timeInstructions suggest this should be a reminder
            if (analysis.timeInstructions?.hasTimeReference && analysis.timeInstructions.extractedTimes.length > 0) {
              // If we have time references but no explicit reminders, create one
              if (!analysis.reminders || analysis.reminders.length === 0) {
                try {
                  const defaultReminderTime = new Date();
                  defaultReminderTime.setDate(defaultReminderTime.getDate() + 1);
                  defaultReminderTime.setHours(9, 0, 0, 0);

                  const reminderData = {
                    title: `Reminder: ${content.slice(0, 50)}...`,
                    completed: false,
                    priority: 'medium',
                    noteId: note.id,
                    isActiveReminder: true,
                    reminderState: 'active',
                    dueDate: defaultReminderTime,
                    timeDue: defaultReminderTime
                  };

                  await storage.createTodo(reminderData);
                  console.log("Created auto-detected reminder for time-sensitive content");
                } catch (reminderError) {
                  console.error("Error creating auto-detected reminder:", reminderError);
                }
              }
            }

            console.log("Note updated with AI analysis:", note.id);
          })
            .catch((error: any) => {
              console.error("Error processing regular note with AI:", error);
              storage.updateNote(note.id, { is_processing: false });
            });
        }
      } else {
        // If no content to process, just mark as not processing
        await storage.updateNote(note.id, { is_processing: false });
      }

      console.log("Media note created successfully:", note.id);
      res.json(note);
    } catch (error: any) {
      console.error("Media note creation error:", error);
      console.error("Error stack:", error.stack);
      console.error("Request body keys:", Object.keys(req.body));
      console.error("Files received:", req.files ? Object.keys(req.files) : 'none');

      // Provide specific error details for mobile debugging
      let errorMessage = "Failed to create media note";
      if (error.message) {
        errorMessage += `: ${error.message}`;
      }

      res.status(500).json({ 
        message: errorMessage,
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      });
    }
  });

  app.post("/api/reprocess-notes", async (req, res) => {
    try {
      const { reprocessAllNotes } = await import("./reprocess-notes");
      await reprocessAllNotes();
      res.json({ success: true, message: "All notes reprocessed successfully" });
    } catch (error) {
      console.error("Error reprocessing notes:", error);
      res.status(500).json({ error: "Failed to reprocess notes" });
    }
  });

  // Intelligent Note Evolution Endpoint
  app.post("/api/notes/:id/evolve", async (req: Request, res: Response): Promise<void> => {
1531:   app.post("/api/notes/:id/evolve", async (req: Request, res: Response): Promise<void> => {
    try {
1532:     try {
      const noteId = parseInt(req.params.id);
1533:       const noteId = parseInt(req.params.id);
      const { instruction, existingContent, existingContext, existingTodos, existingRichContext } = req.body;
1534:       const { instruction, existingContent, existingContext, existingTodos, existingRichContext } = req.body;

1535: 
      if (!instruction || !existingContent) {
1536:       if (!instruction || !existingContent) {
        return res.status(400).json({ message: "Instruction and existing content required" });
1537:         return res.status(400).json({ message: "Instruction and existing content required" });
      }
1538:       }

1539: 
      // Get the note to ensure it exists
1540:       // Get the note to ensure it exists
      const note = await storage.getNote(noteId);
1541:       const note = await storage.getNote(noteId);
      if (!note) {
1542:       if (!note) {
        return res.status(404).json({ message: "Note not found" });
1543:         return res.status(404).json({ message: "Note not found" });
      }
1544:       }

1545: 
      // Create comprehensive evolution prompt
1546:       // Create comprehensive evolution prompt
      const evolutionPrompt = `You are an intelligent assistant helping to evolve and improve a user's note. Your goal is to understand the existing content deeply and apply the user's instruction to make it better, more complete, and more actionable.
1547:       const evolutionPrompt = `You are an intelligent assistant helping to evolve and improve a user's note. Your goal is to understand the existing content deeply and apply the user's instruction to make it better, more complete, and more actionable.

1548: 
EXISTING NOTE CONTENT:
1549: EXISTING NOTE CONTENT:
${existingContent}
1550: ${existingContent}

1551: 
EXISTING AI CONTEXT:
1552: EXISTING AI CONTEXT:
${existingContext || 'None'}
1553: ${existingContext || 'None'}

1554: 
EXISTING TODOS:
1555: EXISTING TODOS:
${existingTodos && existingTodos.length > 0 ? existingTodos.map((t: any) => `• ${t.title} ${t.completed ? '(✓ completed)' : '(pending)'}`).join('\n') : 'None'}
1556: ${existingTodos && existingTodos.length > 0 ? existingTodos.map((t: any) => `• ${t.title} ${t.completed ? '(✓ completed)' : '(pending)'}`).join('\n') : 'None'}

1557: 
EXISTING RESEARCH/RICH CONTEXT:
1558: EXISTING RESEARCH/RICH CONTEXT:
${existingRichContext ? JSON.stringify(JSON.parse(existingRichContext), null, 2) : 'None'}
1559: ${existingRichContext ? JSON.stringify(JSON.parse(existingRichContext), null, 2) : 'None'}

1560: 
USER'S EVOLUTION INSTRUCTION:
1561: USER'S EVOLUTION INSTRUCTION:
"${instruction}"
1562: "${instruction}"

1563: 
Please intelligently evolve this note by:
1564: Please intelligently evolve this note by:

1565: 
1. UNDERSTANDING the current state and context
1566: 1. UNDERSTANDING the current state and context
2. APPLYING the user's instruction thoughtfully
1567: 2. APPLYING the user's instruction thoughtfully
3. PRESERVING important existing information
1568: 3. PRESERVING important existing information
4. ENHANCING with relevant details, next steps, or improvements
1569: 4. ENHANCING with relevant details, next steps, or improvements
5. CHECKING OFF completed todos if the instruction indicates completion
1570: 5. CHECKING OFF completed todos if the instruction indicates completion
6. ADDING new todos if the evolution suggests additional actions
1571: 6. ADDING new todos if the evolution suggests additional actions
7. RESEARCHING and adding relevant external information if appropriate
1572: 7. RESEARCHING and adding relevant external information if appropriate
8. ORGANIZING the information better if needed
1573: 8. ORGANIZING the information better if needed

1574: 
Rules:
1575: Rules:
- Don't lose obviously important information unless explicitly asked
1576: - Don't lose obviously important information unless explicitly asked
- Be proactive and anticipate what the user might need next
1577: - Be proactive and anticipate what the user might need next
- If the instruction mentions checking things off, update todo statuses
1578: - If the instruction mentions checking things off, update todo statuses
- If research is needed, provide relevant facts and resources
1579: - If research is needed, provide relevant facts and resources
- If the instruction suggests adding items, create comprehensive additions
1580: - If the instruction suggests adding items, create comprehensive additions
- Think like a knowledgeable assistant who is always 2 steps ahead
1581: - Think like a knowledgeable assistant who is always 2 steps ahead

1582: 
Respond with a JSON object containing:
1583: Respond with a JSON object containing:
{
1584: {
  "enhancedContent": "The improved note content",
1585:   "enhancedContent": "The improved note content",
  "suggestion": "Brief explanation of what you evolved",
1586:   "suggestion": "Brief explanation of what you evolved",
  "context": "Any new context or insights",
1587:   "context": "Any new context or insights",
  "todos": ["Array of new todo items to add"],
1588:   "todos": ["Array of new todo items to add"],
  "todoUpdates": [{"id": number, "completed": boolean}], // for existing todos to update
1589:   "todoUpdates": [{"id": number, "completed": boolean}], // for existing todos to update
  "collectionSuggestion": {"name": "string", "icon": "string", "color": "string"} or null,
1590:   "collectionSuggestion": {"name": "string", "icon": "string", "color": "string"} or null,
  "rich_context": {
1591:   "rich_context": {
    "recommendedActions": [{"title": "string", "description": "string", "links": [{"title": "string", "url": "string"}]}],
1592:     "recommendedActions": [{"title": "string", "description": "string", "links": [{"title": "string", "url": "string"}]}],
    "researchResults": [{"title": "string", "description": "string", "keyPoints": ["string"], "rating": "string"}],
1593:     "researchResults": [{"title": "string", "description": "string", "keyPoints": ["string"], "rating": "string"}],
    "quickInsights": ["string"]
1594:     "quickInsights": ["string"]
  }
1595:   }
}`;
1596: }`;

1597: 
      console.log("Evolving note with instruction:", instruction);
1598:       console.log("Evolving note with instruction:", instruction);

1599: 
      // Check if this is a media reprocessing request or image analysis request
1600:       // Check if this is a media reprocessing request or image analysis request
      const isMediaReprocessRequest = instruction.toLowerCase().includes('rerun') || 
1601:       const isMediaReprocessRequest = instruction.toLowerCase().includes('rerun') || 
        instruction.toLowerCase().includes('reprocess') || 
1602:         instruction.toLowerCase().includes('reprocess') || 
        instruction.toLowerCase().includes('reanalyze') ||
1603:         instruction.toLowerCase().includes('reanalyze') ||
        instruction.toLowerCase().includes('what does it say') ||
1604:         instruction.toLowerCase().includes('what does it say') ||
        instruction.toLowerCase().includes('what does this say') ||
1605:         instruction.toLowerCase().includes('what does this say') ||
        instruction.toLowerCase().includes('read the text') ||
1606:         instruction.toLowerCase().includes('read the text') ||
        instruction.toLowerCase().includes('identify') ||
1607:         instruction.toLowerCase().includes('identify') ||
        instruction.toLowerCase().includes('tell me about') ||
1608:         instruction.toLowerCase().includes('tell me about') ||
        instruction.toLowerCase().includes('business intelligence') ||
1609:         instruction.toLowerCase().includes('business intelligence') ||
        instruction.toLowerCase().includes('company') ||
1610:         instruction.toLowerCase().includes('company') ||
        instruction.toLowerCase().includes('founders') ||
1611:         instruction.toLowerCase().includes('founders') ||
        instruction.toLowerCase().includes('business model') ||
1612:         instruction.toLowerCase().includes('business model') ||
        (instruction.toLowerCase().includes('image') && (instruction.toLowerCase().includes('again') || instruction.toLowerCase().includes('better')));
1613:         (instruction.toLowerCase().includes('image') && (instruction.toLowerCase().includes('again') || instruction.toLowerCase().includes('better')));

1614: 
      let evolution;
1615:       let evolution;

1616: 
      if (isMediaReprocessRequest && note.media_url) {
1617:       if (isMediaReprocessRequest && note.media_url) {
        console.log("Media reprocessing request detected for note with image");
1618:         console.log("Media reprocessing request detected for note with image");

1619: 
        // Combine original content with new instruction for reprocessing
1620:         // Combine original content with new instruction for reprocessing
        const combinedInstructions = `Original context: ${note.content}\n\nNew instructions: ${instruction}`;
1621:         const combinedInstructions = `Original context: ${note.content}\n\nNew instructions: ${instruction}`;

1622: 
        try {
1623:         try {
          // Re-analyze the image with combined instructions using specialized image analysis
1624:           // Re-analyze the image with combined instructions using specialized image analysis
          const imageBase64 = await getImageAsBase64(note.media_url);
1625:           const imageBase64 = await getImageAsBase64(note.media_url);
          if (imageBase64 && isOpenAIAvailable()) {
1626:           if (imageBase64 && isOpenAIAvailable()) {
            console.log("Using specialized OpenAI image analysis for evolution");
1627:             console.log("Using specialized OpenAI image analysis for evolution");
            console.log("Image base64 length:", imageBase64.length);
1628:             console.log("Image base64 length:", imageBase64.length);
            const { analyzeImageContent } = await import('./openai');
1629:             const { analyzeImageContent } = await import('./openai');
            const imageAnalysis = await analyzeImageContent(imageBase64, combinedInstructions);
1630:             const imageAnalysis = await analyzeImageContent(imageBase64, combinedInstructions);

1631: 
            // Convert image analysis to evolution format
1632:             // Convert image analysis to evolution format
            evolution = {
1633:             evolution = {
              enhancedContent: imageAnalysis.enhancedContent || combinedInstructions,
1634:               enhancedContent: imageAnalysis.enhancedContent || combinedInstructions,
              suggestion: imageAnalysis.suggestion || "Image reanalyzed with new instructions",
1635:               suggestion: imageAnalysis.suggestion || "Image reanalyzed with new instructions",
              context: imageAnalysis.context || "",
1636:               context: imageAnalysis.context || "",
              todos: imageAnalysis.todos || [],
1637:               todos: imageAnalysis.todos || [],
              todoUpdates: [],
1638:               todoUpdates: [],
              collectionSuggestion: imageAnalysis.collectionSuggestion || null,
1639:               collectionSuggestion: imageAnalysis.collectionSuggestion || null,
              rich_context: imageAnalysis.rich_context || null
1640:               rich_context: imageAnalysis.rich_context || null
            };
1641:             };
            console.log("Specialized image analysis completed for evolution");
1642:             console.log("Specialized image analysis completed for evolution");
          } else {
1643:           } else {
            console.log("Image base64 not available or OpenAI not available, falling back to text evolution");
1644:             console.log("Image base64 not available or OpenAI not available, falling back to text evolution");
            console.log("imageBase64 length:", imageBase64 ? imageBase64.length : "null");
1645:             console.log("imageBase64 length:", imageBase64 ? imageBase64.length : "null");
            console.log("OpenAI available:", isOpenAIAvailable());
1646:             console.log("OpenAI available:", isOpenAIAvailable());
            // Fallback to text evolution if image retrieval fails
1647:             // Fallback to text evolution if image retrieval fails
            evolution = await safeAnalyzeWithClaude(evolutionPrompt, "evolution");
1648:             evolution = await safeAnalyzeWithClaude(evolutionPrompt, "evolution");
          }
1649:           }
        } catch (error) {
1650:         } catch (error) {
          console.error("Image analysis failed, falling back to text evolution:", error);
          evolution = await safeAnalyzeWithClaude(evolutionPrompt, "evolution");
        }
      } else {
        // Check if this is a business intelligence or company research request
        const isBusinessIntelligenceRequest = instruction.toLowerCase().includes('business intelligence') ||
          instruction.toLowerCase().includes('company') ||
          instruction.toLowerCase().includes('market positioning') ||
          instruction.toLowerCase().includes('funding') ||
          instruction.toLowerCase().includes('anthropic') ||
          instruction.toLowerCase().includes('openai') ||
          instruction.toLowerCase().includes('competitive') ||
          instruction.toLowerCase().includes('recent developments');

        if (isBusinessIntelligenceRequest && isOpenAIAvailable()) {
          console.log("Using enhanced OpenAI analysis with company intelligence for evolution");
          evolution = await safeAnalyzeWithOpenAI(evolutionPrompt, "evolution");
        } else {
          // Regular text evolution
          evolution = await safeAnalyzeWithClaude(evolutionPrompt, "evolution");
        }
      }

      // Analyze instruction for safety before applying changes
      const isMinorChange = DataProtectionService.isMinorChange(instruction);
      const isRiskyChange = DataProtectionService.isRiskyChange(instruction);

      // Use data protection for content changes
      const protectionResult = await DataProtectionService.safeApplyAIChanges(
        noteId,
        existingContent,
        evolution,
        {
          changedBy: "ai_claude",
          userApproved: isMinorChange, // Auto-approve minor changes
          changeType: "ai_enhancement"
        }
      );

      if (!protectionResult.success) {
        // Return suggestions without applying changes for high-risk modifications
        return res.json({
          id: noteId,
          content: existingContent,
          ai_suggestion: evolution.suggestion,
          ai_context: evolution.context,
          warnings: protectionResult.warnings,
          requiresApproval: true,
          suggestedChanges: evolution.enhancedContent,
          riskLevel: "high"
        });
      }

      // Apply the protected changes
      const updates: any = {
        content: protectionResult.appliedChanges,
        ai_enhanced: true
      };

      // Only add fields if they have values
      if (evolution.suggestion) {
        updates.ai_suggestion = evolution.suggestion;
      }
      if (evolution.context) {
        updates.ai_context = evolution.context;
      }
      if (evolution.rich_context) {
        updates.rich_context = JSON.stringify(evolution.rich_context);
      }
      if (protectionResult.warnings.length > 0) {
        updates.ai_context = (updates.ai_context || "") + "\n\nData Protection Warnings: " + protectionResult.warnings.join("; ");
      }

      // Update the note with protected content
      await storage.updateNote(noteId, updates);

      // Create new todos from AI analysis

      // Create new todos
      if (evolution.todos && evolution.todos.length > 0) {
        for (const todoTitle of evolution.todos) {
          await storage.createTodo({
            title: todoTitle,
            noteId: noteId,
            dependsOnTodoIds: [],
            triggersTodoIds: [],
            plannedNotificationStructure: {
              enabled: false,
              reminderCategory: "not_set",
              repeatPattern: "none",
              leadTimeNotifications: []
            }
          });
        }
      }

      // Handle collection suggestion
      if (evolution.collectionSuggestion) {
        const collections = await storage.getCollections();
        const existingCollection = collections.find(
          c => c.name.toLowerCase() === evolution.collectionSuggestion!.name.toLowerCase()
        );

        let collection_id = existingCollection?.id;
        if (!existingCollection) {
          const newCollection = await storage.createCollection(evolution.collectionSuggestion);
          collection_id = newCollection.id;
        }

        await storage.updateNote(noteId, { collection_id });
      }

      // Return the updated note with normalized fields
      const updatedNote = await storage.getNote(noteId);
      const normalizedUpdatedNote = normalizeNote(updatedNote);
      
      // Also fetch todos for the complete response
      const todos = await storage.getTodosByNoteId(noteId);
      const noteWithTodos = { ...normalizedUpdatedNote, todos: todos.filter(t => !t.archived) };
      
      console.log('Evolve endpoint returning updated note:', noteId);
      res.json(noteWithTodos);

    } catch (error) {
      console.error("Note evolution error:", error);
      res.status(500).json({ message: "Failed to evolve note" });
    }
  });

  // Quick rollback endpoint for reverting AI changes
  app.post("/api/notes/:noteId/rollback", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const { targetVersion } = req.body;

      if (!targetVersion) {
        return res.status(400).json({ message: "Target version is required" });
      }

      const success = await DataProtectionService.rollbackToVersion(noteId, targetVersion);

      if (success) {
        const updatedNote = await storage.getNote(noteId);
        res.json({ 
          success: true, 
          note: updatedNote,
          message: `Rolled back to version ${targetVersion}`
        });
      } else {
        res.status(400).json({ message: "Rollback failed" });
      }
    } catch (error) {
      console.error("Rollback error:", error);
      res.status(500).json({ message: "Failed to rollback note" });
    }
  });

  // Get version history for a note
  app.get("/api/notes/:noteId/versions", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const versions = await DataProtectionService.getVersionHistory(noteId);
      res.json(versions);
    } catch (error) {
      console.error("Version history error:", error);
      res.status(500).json({ message: "Failed to get version history" });
    }
  });

  // Approve pending AI changes
  app.post("/api/notes/:noteId/approve-changes", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const { suggestedChanges, userApproved } = req.body;

      if (!suggestedChanges) {
        return res.status(400).json({ message: "Suggested changes are required" });
      }

      // Get current note content
      const note = await storage.getNote(noteId);
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }

      // Apply the changes with user approval
      const protectionResult = await DataProtectionService.safeApplyAIChanges(
        noteId,
        note.content,
        { enhancedContent: suggestedChanges },
        {
          changedBy: "ai_claude",
          userApproved: userApproved,
          changeType: "ai_suggestion_applied"
        }
      );

      if (protectionResult.success) {
        await storage.updateNote(noteId, { 
          content: protectionResult.appliedChanges,
          ai_enhanced: true 
        });

        const updatedNote = await storage.getNote(noteId);
        res.json({ 
          success: true, 
          note: updatedNote,
          warnings: protectionResult.warnings
        });
      } else {
        res.status(400).json({ 
          success: false, 
          warnings: protectionResult.warnings 
        });
      }
    } catch (error) {
      console.error("Approve changes error:", error);
      res.status(500).json({ message: "Failed to approve changes" });
    }
  });

  // Re-clarify instruction endpoint for when AI misunderstood
  app.post("/api/notes/:noteId/clarify", async (req: Request, res: Response): Promise<void> => {
    try {
      const noteId = parseInt(req.params.noteId);
      const { originalInstruction, clarification } = req.body;

      if (!clarification) {
        return res.status(400).json({ message: "Clarification is required" });
      }

      // Get the note
      const note = await storage.getNote(noteId);
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }

      // Combine original instruction with clarification
      const enhancedInstruction = `Previous instruction: ${originalInstruction}\n\nClarification: ${clarification}\n\nPlease apply the clarified instruction accurately.`;

      // Process the clarified instruction (similar to note evolution)
      const evolutionPrompt = `You are helping enhance a note based on user clarification.

Current Note Content:
${note.content}

User's Clarified Instruction:
${enhancedInstruction}

Please provide an enhanced version that follows the clarified instruction precisely. Be conservative and only make the specific changes requested.

Respond with JSON: {"enhancedContent": "improved content", "suggestion": "what you changed", "todos": ["new todos if any"]}`;

      const evolution = await analyzeWithOpenAI(evolutionPrompt, "clarification");

      // Apply with higher confidence since user provided clarification
      const protectionResult = await DataProtectionService.safeApplyAIChanges(
        noteId,
        note.content,
        evolution,
        {
          changedBy: "ai_claude",
          userApproved: true, // User provided clarification, so approve
          changeType: "ai_enhancement"
        }
      );

      if (protectionResult.success) {
        await storage.updateNote(noteId, { 
          content: protectionResult.appliedChanges,
          ai_enhanced: true,
          ai_suggestion: evolution.suggestion
        });

        const updatedNote = await storage.getNote(noteId);
        res.json({ 
          success: true, 
          note: updatedNote,
          message: "Clarification applied successfully"
        });
      } else {
        res.status(400).json({ 
          success: false, 
          warnings: protectionResult.warnings 
        });
      }

    } catch (error) {
      console.error("Clarification error:", error);
      res.status(500).json({ message: "Failed to apply clarification" });
    }
  });

  // Media reprocessing endpoint for existing notes with images
  app.post("/api/reprocess-media/:noteId", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const { instruction } = req.body;

      if (!instruction) {
        return res.status(400).json({ message: "Instruction is required" });
      }

      // Get the existing note
      const note = await storage.getNote(noteId);
      if (!note || !note.media_url) {
        return res.status(404).json({ message: "Note with image not found" });
      }

      console.log("Media reprocessing request for note:", noteId);

      // Combine original content with new instruction
      const combinedInstructions = `Original context: ${note.content}\n\nNew instructions: ${instruction}`;

      // Get the image as base64
      const imageBase64 = await getImageAsBase64(note.media_url);
      if (!imageBase64) {
        return res.status(400).json({ message: "Could not retrieve image file" });
      }

      // Re-analyze with OpenAI
      const analysisResult = await safeAnalyzeWithOpenAI(combinedInstructions, "image-reprocessing");

      // Return the enhanced analysis results
      res.json({
        enhancedContent: analysisResult.enhancedContent || combinedInstructions,
        suggestion: analysisResult.suggestion || "Image reprocessed with new instructions",
        context: analysisResult.context,
        todos: analysisResult.todos || [],
        rich_context: analysisResult.rich_context,
        success: true
      });

    } catch (error) {
      console.error("Media reprocessing error:", error);
      res.status(500).json({ message: "Failed to reprocess media" });
    }
  });

  // Media analysis endpoint for AI identification and web search
  app.post("/api/analyze-media", upload.single("image"), async (req, res) => {
    try {
      const file = req.file;
      const { analyzeOnly } = req.body;

      if (!file) {
        return res.status(400).json({ error: "No image file provided" });
      }

      let identification = "Image captured";
      let suggestedContext = "Please add context for this image";
      let webResults = null;

      if (isOpenAIAvailable()) {
        try {
          const analysisPrompt = `Analyze this image and provide valuable insights. Focus on:

1. IDENTIFY what this is (book title, product name, menu item, etc.)
2. Provide ACTIONABLE VALUE about it (price, reviews, where to get it, ratings, recommendations)
3. Create a newspaper-style headline (3-5 words max) that captures the key value
4. Write a description focused on usefulness, not the analysis process

Examples:
- For a book: "The Great Gatsby" → headline: "Classic American Literature" → description: "Critically acclaimed novel by F. Scott Fitzgerald. Often required reading. Available in multiple editions."
- For a restaurant menu: "Pizza Palace Menu" → headline: "Pizza Palace Prices" → description: "Local pizzeria with wood-fired options. Average price $15-25. Highly rated for authentic Italian style."
- For a product: "iPhone 15" → headline: "iPhone 15 Features" → description: "Latest Apple smartphone with improved camera and battery life. Starting at $799. Available in multiple colors."

Respond with JSON:
{
  "itemName": "specific item name",
  "headline": "3-5 word value-focused title",
  "description": "useful information about the item",
  "category": "book/product/food/etc",
  "keyValue": "main valuable insight"
}`;

          const analysisResult = await safeAnalyzeWithOpenAI(analysisPrompt, "image-analysis");

          // Parse the structured response
          try {
            // First try to parse the main content, then fall back to raw response
            let parsed: any = {};
            if (analysisResult.enhancedContent) {
              try {
                parsed = JSON.parse(analysisResult.enhancedContent);
              } catch {
                // If enhancedContent isn't JSON, try context or suggestion
                parsed = JSON.parse(analysisResult.context || analysisResult.suggestion || '{}');
              }
            }

            // Only use AI identification if it's meaningful, not placeholder text
            if (parsed.headline && parsed.headline !== "General content analysis") {
              identification = parsed.headline;
            } else if (parsed.itemName && parsed.itemName !== "General content analysis") {
              identification = parsed.itemName;
            } else if (parsed.title && parsed.title !== "General content analysis") {
              identification = parsed.title;
            } else {
              identification = ""; // No placeholder text
            }

            // Only use AI context if it's meaningful
            if (parsed.description && parsed.description !== "General content analysis") {
              suggestedContext = parsed.description;
            } else if (parsed.keyValue && parsed.keyValue !== "General content analysis") {
              suggestedContext = parsed.keyValue;
            } else {
              suggestedContext = ""; // No placeholder text
            }

            // Generate meaningful web search results based on the identified item  
            if (parsed.itemName && parsed.itemName !== "Image captured" && parsed.itemName !== "General content analysis") {
              const searchTerm = parsed.itemName;
              const category = parsed.category || "item";

              webResults = {
                fromTheWeb: [
                  {
                    title: `${searchTerm} Reviews & Ratings`,
                    description: `User reviews, ratings, and detailed analysis of ${searchTerm}`,
                    url: `https://search-results.com/${encodeURIComponent(searchTerm)}`,
                    rating: "4.5/5 stars",
                    keyPoints: ["Customer reviews", "Expert analysis", "Comparison with alternatives"],
                    source: "Review Platform"
                  },
                  {
                    title: `Best Price for ${searchTerm}`,
                    description: `Price comparison and where to buy ${searchTerm} at the best value`,
                    url: `https://shopping.com/${encodeURIComponent(searchTerm)}`,
                    rating: "4.7/5 stars", 
                    keyPoints: ["Price comparison", "Available retailers", "Deals and discounts"],
                    source: "Shopping Platform"
                  }
                ],
                nextSteps: [
                  `Compare prices for ${searchTerm}`,
                  "Read detailed reviews",
                  category === "book" ? "Check library availability" : "Find best retailer"
                ],
                keyInsights: [
                  parsed.keyValue || `${searchTerm} information captured`,
                  "Price and review data available",
                  "Ready for purchase decision"
                ]
              };
            }
          } catch (parseError) {
            // Only use meaningful AI results, no placeholder text
            identification = (analysisResult.context && analysisResult.context !== "General content analysis") ? analysisResult.context : "";
            suggestedContext = (analysisResult.suggestion && analysisResult.suggestion !== "General content analysis") ? analysisResult.suggestion : "";
          }

        } catch (error) {
          console.error("AI image analysis failed:", error);
        }
      }

      if (analyzeOnly === 'true') {
        // Only return identification if it's meaningful (not generic placeholder)
        const meaningfulIdentification = (identification === "Image captured" || identification === "General content analysis") 
          ? "" : (identification || "");

        return res.json({
          identification: meaningfulIdentification || "",
          suggestedContext: meaningfulIdentification ? suggestedContext : "",
          webResults: meaningfulIdentification ? webResults : null
        });
      }

      return res.json({ success: true });

    } catch (error) {
      console.error("Media analysis error:", error);
      res.status(500).json({ error: "Failed to analyze media" });
    }
  });

  // Object Storage endpoints for ChatGPT integration
  app.post("/api/storage/upload", async (req, res) => {
    try {
      const { filename, content, contentType = 'text/plain' } = req.body;

      if (!filename || !content) {
        return res.status(400).json({ error: "Filename and content required" });
      }

      const { ReplitStorage } = await import('./replit-storage');
      const downloadUrl = await ReplitStorage.saveForChatGPT(filename, content);

      res.json({ 
        success: true, 
        filename, 
        downloadUrl,
        message: "File saved to Replit Object Storage" 
      });
    } catch (error) {
      console.error("Storage upload error:", error);
      res.status(500).json({ error: "Failed to upload file" });
    }
  });

  app.get("/api/storage/files", async (req, res) => {
    try {
      const { ReplitStorage } = await import('./replit-storage');
      const files = await ReplitStorage.listFiles();
      res.json({ files });
    } catch (error) {
      console.error("Storage list error:", error);
      res.status(500).json({ error: "Failed to list files" });
    }
  });

  app.get("/api/storage/download/:filename", async (req, res) => {
    try {
      const { filename } = req.params;
      const { ReplitStorage } = await import('./replit-storage');
      const content = await ReplitStorage.downloadFile(filename);
      res.json({ filename, content });
    } catch (error) {
      console.error("Storage download error:", error);
      res.status(500).json({ error: "Failed to download file" });
    }
  });

  // Placeholder note creation endpoint
  app.post("/api/notes/placeholder", async (req, res) => {
    try {
      const { type, fileName, fileSize, mimeType, duration, content } = req.body;

      let placeholderContent = content || "";
      let aiTitle = "";

      // Generate AI title based on type and context
      if (type === "voice") {
        aiTitle = "Voice Recording";
        placeholderContent = content || "🎤 Recording voice note...";
      } else if (type === "image") {
        // Use AI to generate meaningful title from file context
        const contextPrompt = `Generate a concise, meaningful title for an image file. The user is saving this image for a reason. Based on the filename "${fileName}" and type "${mimeType}", suggest what this image might be about and why they're saving it. Respond with just the title, no quotes or extra text. Make it human and contextual, not technical.`;

        try {
          const titleResponse = await analyzeWithOpenAI(contextPrompt, "title-generation");
          aiTitle = titleResponse.enhancedContent || titleResponse.suggestion || "Image Upload";
        } catch (error) {
          aiTitle = "Image Upload";
        }

        placeholderContent = `📸 Processing image...`;
      } else if (type === "file") {
        // Use filename and type to generate meaningful context
        const extension = fileName.split('.').pop()?.toLowerCase() || '';
        const contextPrompt = `Generate a concise, meaningful title for a file the user is uploading. Filename: "${fileName}",Type: "${mimeType}". Consider why someone would save this type of file and what it might contain. Respond with just the title, no quotes or extra text. Make it human and contextual.`;

        try {
          const titleResponse = await analyzeWithOpenAI(contextPrompt, "title-generation");
          aiTitle = titleResponse.enhancedContent || titleResponse.suggestion || fileName;
        } catch (error) {
          aiTitle = fileName;
        }

        placeholderContent = `📄 Processing file...`;
      }

      // Create placeholder note
      const note = await storage.createNote({
        content: placeholderContent,
        mode: type || "text",
        ai_suggestion: aiTitle,
        is_processing: true
      });

      res.json(note);
    } catch (error) {
      console.error("Failed to create placeholder note:", error);
      res.status(500).json({ message: "Failed to create placeholder note" });
    }
  });

  app.post("/api/notes/voice", upload.single("audio"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No audio file provided" });
      }

      // Check if duration is provided and validate minimum length
      const duration = req.body.duration ? parseFloat(req.body.duration) : null;
      if (duration !== null && duration < 1.5) {
        console.log(`Voice recording too short: ${duration}s, rejecting`);
        return res.status(400).json({ 
          message: "Recording too short",
          error: "Voice notes must be at least 1.5 seconds long."
        });
      }

      const noteId = req.body.noteId;
      let note;

      // Save audio file first
      let audio_url = null;
      try {
        const savedAudio = await saveAudioFile(
          req.file.buffer, 
          `voice-${Date.now()}.webm`,
          req.file.mimetype || 'audio/webm'
        );
        audio_url = savedAudio.url;
        console.log("Voice audio saved:", audio_url);
      } catch (error) {
        console.error("Failed to save audio file:", error);
      }

      // Transcribe audio safely - never crash if AI fails
      let transcription = null;
      try {
        if (isOpenAIAvailable()) {
          transcription = await safeTranscribeAudio(req.file.buffer);
        } else {
          console.warn("Audio transcription skipped - OpenAI not available");
        }
      } catch (error) {
        console.error("Audio transcription failed:", error);
        // If transcription fails, reject the note creation instead of creating a placeholder
        return res.status(400).json({ 
          message: "Audio transcription failed",
          error: "Unable to process voice note. Please try again."
        });
      }

      // If no transcription was obtained, reject the request
      if (!transcription || transcription.trim().length === 0) {
        console.log("No transcription obtained, rejecting voice note");
        return res.status(400).json({ 
          message: "No audio content detected",
          error: "Unable to detect speech in the recording. Please try again."
        });
      }

      if (noteId) {
        // Update existing placeholder note
        note = await storage.updateNote(parseInt(noteId), {
          content: transcription,
          transcription,
          audio_url,
          is_processing: false,
        });
      } else {
        // Create new note (fallback)
        note = await storage.createNote({
          content: transcription,
          mode: "voice",
          transcription,
          audio_url,
        });
      }

      // Process with Intelligence-V2 system via OpenAI (non-blocking)
      if (isOpenAIAvailable()) {
        const miraInput: MiraAIInput = {
          content: transcription,
          mode: "voice",
          timestamp: new Date().toISOString(),
          context: {
            timeOfDay: new Date().toLocaleTimeString(),
            recentActivity: []
          }
        };

        processNote(miraInput)
          .then(async (analysis: MiraAIResult) => {
            console.log("Mira AI analysis successful for voice note:", note.id);

            console.log("v2.0 Intelligence Layer analysis successful for voice note:", note.id);

            apiUsageStats.openai.requests++;
            apiUsageStats.totalRequests++;

            // Use v2.0 structured results
            const updates: any = {
              ai_enhanced: true,
              ai_suggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
              ai_context: analysis.summary || "",
              rich_context: analysis.entities ? JSON.stringify({
                entities: analysis.entities,
                suggestedLinks: analysis.suggestedLinks,
                nextSteps: analysis.nextSteps,
                microQuestions: analysis.microQuestions,
                timeInstructions: analysis.timeInstructions
              }) : null,
              is_processing: false,
            };

            // NEVER overwrite original transcription with AI analysis
            // The transcribed content must be preserved as the user's actual words

            await storage.updateNote(note.id, updates);

            // Create v2.0 todos if found
            console.log("Creating", analysis.todos?.length || 0, "v2.0 todos for voice note:", note.id);
            if (analysis.todos && analysis.todos.length > 0) {
              for (const todo of analysis.todos) {
                const todoData: any = {
                  title: todo.title,
                  noteId: note.id,
                };

                // Add v2.0 enhanced todo properties
                if (todo.due) {
                  todoData.timeDue = new Date(todo.due);
                }
                if (todo.recurrence) {
                  todoData.recurrenceRule = todo.recurrence; // RRULE format
                }
                if (todo.priority) {
                  todoData.priority = todo.priority;
                }

                await storage.createTodo(todoData);
              }
            }

            // Create collection if suggested with v2.0 hints
            if (analysis.collectionHint) {
              const collections = await storage.getCollections();
              const existingCollection = collections.find(
                c => c.name.toLowerCase() === analysis.collectionHint!.name.toLowerCase()
              );

              let collection_id = existingCollection?.id;
              if (!existingCollection) {
                const newCollection = await storage.createCollection({
                  name: analysis.collectionHint.name,
                  icon: analysis.collectionHint.icon || "folder",
                  color: analysis.collectionHint.colour || "#6366f1"
                });
                collection_id = newCollection.id;
              }

              await storage.updateNote(note.id, { collection_id });
            }
          })
          .catch(error => {
            console.error("Mira AI analysis failed:", error);
          });
      } else {
        console.warn("OpenAI not available - skipping voice note analysis");
      }

      res.json(note);
    } catch (error) {
      console.error("Voice note creation failed:", error);
      res.status(500).json({ message: "Failed to process voice note" });
    }
  });

  app.post("/api/notes/image", upload.single("image"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No image file provided" });
      }

      const noteId = req.body.noteId;
      let note;

      // Convert image to base64 for AI analysis
      const imageBase64 = req.file.buffer.toString('base64');

      if (noteId) {
        // Update existing placeholder note
        note = await storage.updateNote(parseInt(noteId), {
          content: `📸 Analyzing image...`,
          image_data: imageBase64,
          is_processing: false,
        });
      } else {
        // Create new note (fallback)
        note = await storage.createNote({
          content: `[Image uploaded: ${req.file.originalname}]`,
          mode: "image",
          image_data: imageBase64,
        });
      }

      // Analyze image with AI in the background (non-blocking)
      if (isOpenAIAvailable()) {
        safeAnalyzeWithOpenAI(`data:${req.file.mimetype};base64,${imageBase64}`, "image")
          .then(async (analysis) => {
            const updates: any = {
            ai_enhanced: true,
            ai_suggestion: analysis.suggestion,
            ai_context: analysis.context,
          };

          if (analysis.enhancedContent) {
            updates.content = analysis.enhancedContent;
          }

          await storage.updateNote(note.id, updates);

          // Create todos if found
          for (const todoTitle of analysis.todos) {
            await storage.createTodo({
              title: todoTitle,
              noteId: note.id,
            });
          }

          // Create collection if suggested
          if (analysis.collectionSuggestion) {
            const collections = await storage.getCollections();
            const existingCollection = collections.find(
              c => c.name.toLowerCase() === analysis.collectionSuggestion!.name.toLowerCase()
            );

            let collection_id = existingCollection?.id;
            if (!existingCollection) {
              const newCollection = await storage.createCollection(analysis.collectionSuggestion);
              collection_id = newCollection.id;
            }

            await storage.updateNote(note.id, { collection_id });
          }
        })
          .catch(error => {
            console.error("AI image analysis failed:", error);
          });
      } else {
        console.warn("OpenAI not available - skipping image analysis");
      }

      res.json(note);
    } catch (error) {
      console.error("Image note creation failed:", error);
      res.status(500).json({ message: "Failed to process image" });
    }
  });

  app.post("/api/notes/file", upload.single("file"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file provided" });
      }

      const noteId = req.body.noteId;
      let note;

      if (noteId) {
        // Update existing placeholder note
        note = await storage.updateNote(parseInt(noteId), {
          content: `📄 Analyzing file...`,
          is_processing: false,
        });
      } else {
        // Create new note (fallback)
        note = await storage.createNote({
          content: `[File uploaded: ${req.file.originalname}] - ${req.file.mimetype} (${Math.round(req.file.size / 1024)}KB)`,
          mode: "file",
        });
      }

      // Analyze file content with AI in the background
      let fileContent = `File: ${req.file.originalname} (${req.file.mimetype}, ${Math.round(req.file.size / 1024)}KB)`;

      // For text files, try to read content
      if (req.file.mimetype.startsWith('text/') || 
          req.file.mimetype === 'application/json' ||
          req.file.originalname?.endsWith('.md') ||
          req.file.originalname?.endsWith('.txt')) {
        try {
          fileContent += `\n\nContent:\n${req.file.buffer.toString('utf-8')}`;
        } catch (error) {
          console.log("Could not read file as text:", error);
        }
      }

      const miraInput: MiraAIInput = {
        content: fileContent,
        mode: "file",
        timestamp: new Date().toISOString(),
        context: {
          fileName: req.file?.originalname || "unknown",
          fileType: req.file?.mimetype || "unknown"
        }
      };

      processNote(miraInput)
        .then(async (analysis: MiraAIResult) => {
          const updates: any = {
            ai_enhanced: true,
            ai_suggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
            ai_context: analysis.summary || "",
            rich_context: analysis.entities ? JSON.stringify({
              entities: analysis.entities,
              suggestedLinks: analysis.suggestedLinks,
              nextSteps: analysis.nextSteps,
              microQuestions: analysis.microQuestions,
              timeInstructions: analysis.timeInstructions
            }) : null,
            is_processing: false
          };

          // Use v2.0 title as content if available
          if (analysis.title && analysis.title !== fileContent.substring(0, 100)) {
            updates.content = analysis.title;
          }

          await storage.updateNote(note.id, updates);

          // Create v2.0 todos if found
          if (analysis.todos && analysis.todos.length > 0) {
            for (const todo of analysis.todos) {
              const todoData: any = {
                title: todo.title,
                noteId: note.id,
              };

              // Add v2.0 enhanced todo properties
              if (todo.due) {
                todoData.timeDue = new Date(todo.due);
              }
              if (todo.recurrence) {
                todoData.recurrenceRule = todo.recurrence;
              }
              if (todo.priority) {
                todoData.priority = todo.priority;
              }

              await storage.createTodo(todoData);
            }
          }

          // Create collection if suggested with v2.0 hints
          if (analysis.collectionHint) {
            const collections = await storage.getCollections();
            const existingCollection = collections.find(
              c => c.name.toLowerCase() === analysis.collectionHint!.name.toLowerCase()
            );

            let collection_id = existingCollection?.id;
            if (!existingCollection) {
              const newCollection = await storage.createCollection({
                name: analysis.collectionHint.name,
                icon: analysis.collectionHint.icon || "folder",
                color: analysis.collectionHint.colour || "#6366f1"
              });
              collection_id = newCollection.id;
            }

            await storage.updateNote(note.id, { collection_id });
          }
        })
        .catch((error: any) => {
          console.error("AI file analysis failed:", error);
        });

      res.json(note);
    } catch (error) {
      console.error("File note creation failed:", error);
      res.status(500).json({ message: "Failed to process file" });
    }
  });

  // POST route for note updates (handles TipTap editor saves and prevents cache corruption)
  app.post("/api/notes/:id", async (req, res) => {
2614:   app.post("/api/notes/:id", async (req, res) => {
    try {
2615:     try {
      const noteId = parseInt(req.params.id);
2616:       const noteId = parseInt(req.params.id);
      const updates = req.body || {};
2617:       const updates = req.body || {};
      
2618:       
      // Update the note in database
2619:       // Update the note in database
      const updatedNote = await storage.updateNote(noteId, updates);
2620:       const updatedNote = await storage.updateNote(noteId, updates);
      
2621:       
      if (!updatedNote) {
2622:       if (!updatedNote) {
        return res.status(404).json({ error: "Note not found" });
2623:         return res.status(404).json({ error: "Note not found" });
      }
2624:       }
      
2625:       
      res.json(updatedNote);
2626:       res.json(updatedNote);
    } catch (error) {
2627:     } catch (error) {
      console.error("Error updating note via POST:", error);
2628:       console.error("Error updating note via POST:", error);
      res.status(500).json({ error: "Failed to update note" });
2629:       res.status(500).json({ error: "Failed to update note" });
    }
2630:     }
  });
2631:   });

2632: 
  /**
2633:   /**
   * Authoritative save-endpoint.
2634:    * Authoritative save-endpoint.
   * Accepts *either* plain-text `content` *or* TipTap `doc_json` (or both).
2635:    * Accepts *either* plain-text `content` *or* TipTap `doc_json` (or both).
   * Any other keys are ignored on purpose.
2636:    * Any other keys are ignored on purpose.
   * Always returns 200 + JSON (never HTML).
2637:    * Always returns 200 + JSON (never HTML).
   */
2638:    */
  app.patch("/api/notes/:id", async (req, res) => {
2639:   app.patch("/api/notes/:id", async (req, res) => {
    const id = Number(req.params.id);
2640:     const id = Number(req.params.id);
    if (Number.isNaN(id)) return res.status(400).json({ error: 'Bad id' });
2641:     if (Number.isNaN(id)) return res.status(400).json({ error: 'Bad id' });

2642: 
    const { content, doc_json } = req.body ?? {};
2643:     const { content, doc_json } = req.body ?? {};
    if (content == null && doc_json == null)
2644:     if (content == null && doc_json == null)
      return res.status(400).json({ error: 'Nothing to save' });
2645:       return res.status(400).json({ error: 'Nothing to save' });

2646: 
    const updated = await storage.updateNote(id, { content, doc_json });
2647:     const updated = await storage.updateNote(id, { content, doc_json });
    if (!updated) return res.status(404).json({ error: 'Not found' });
2648:     if (!updated) return res.status(404).json({ error: 'Not found' });

2649: 
    res.setHeader('Content-Type', 'application/json');
2650:     res.setHeader('Content-Type', 'application/json');
    res.json(updated);              // <-- ALWAYS JSON, never HTML
2651:     res.json(updated);              // <-- ALWAYS JSON, never HTML
  });
2652:   });

2653: 
  // Todos endpoints
2654:   // Todos endpoints
  app.get("/api/todos", async (req, res) => {
2655:   app.get("/api/todos", async (req, res) => {
    try {
2656:     try {
      const todos = await storage.getTodos();
2657:       const todos = await storage.getTodos();
      res.json(todos);
2658:       res.json(todos);
    } catch (error) {
2659:     } catch (error) {
      res.status(500).json({ message: "Failed to fetch todos" });
2660:       res.status(500).json({ message: "Failed to fetch todos" });
    }
2661:     }
  });
2662:   });

2663: 
  app.patch("/api/todos/:id", async (req, res) => {
2664:   app.patch("/api/todos/:id", async (req, res) => {
    try {
2665:     try {
      const id = parseInt(req.params.id);
2666:       const id = parseInt(req.params.id);
      const todo = await storage.updateTodo(id, req.body);
2667:       const todo = await storage.updateTodo(id, req.body);
      res.json(todo);
2668:       res.json(todo);
    } catch (error) {
2669:     } catch (error) {
      res.status(404).json({ message: "Todo not found" });
2670:       res.status(404).json({ message: "Todo not found" });
    }
2671:     }
  });
2672:   });

2673: 
  // Extract and save tasks from note content
2674:   // Extract and save tasks from note content
  app.put("/api/notes/:id/tasks", async (req, res) => {
2675:   app.put("/api/notes/:id/tasks", async (req, res) => {
    try {
2676:     try {
      const noteId = parseInt(req.params.id);
2677:       const noteId = parseInt(req.params.id);
      const { tasks } = req.body;
2678:       const { tasks } = req.body;

2679: 
      if (!Array.isArray(tasks)) {
2680:       if (!Array.isArray(tasks)) {
        return res.status(400).json({ message: "Tasks must be an array" });
2681:         return res.status(400).json({ message: "Tasks must be an array" });
      }
2682:       }

2683: 
      // Get existing todos for this note
2684:       // Get existing todos for this note
      const existingTodos = await storage.getTodos();
2685:       const existingTodos = await storage.getTodos();
      const noteTodos = existingTodos.filter(t => t.noteId === noteId);
2686:       const noteTodos = existingTodos.filter(t => t.noteId === noteId);

2687: 
      // Create new tasks that don't already exist
2688:       // Create new tasks that don't already exist
      const createdTasks = [];
2689:       const createdTasks = [];
      for (const task of tasks) {
2690:       for (const task of tasks) {
        // Check if task already exists
2691:         // Check if task already exists
        const exists = noteTodos.some(t => 
2692:         const exists = noteTodos.some(t => 
          t.title.toLowerCase() === task.title.toLowerCase()
2693:           t.title.toLowerCase() === task.title.toLowerCase()
        );
2694:         );

2695: 
        if (!exists && task.title && task.title.length > 5) {
2696:         if (!exists && task.title && task.title.length > 5) {
          const newTodo = await storage.createTodo({
2697:           const newTodo = await storage.createTodo({
            noteId,
2698:             noteId,
            title: task.title,
2699:             title: task.title,
            priority: task.priority || 'normal',
2700:             priority: task.priority || 'normal',
            completed: false
2701:             completed: false
          });
2702:           });
          createdTasks.push(newTodo);
2703:           createdTasks.push(newTodo);
        }
2704:         }
      }
2705:       }

2706: 
      res.json({ 
2707:       res.json({ 
        success: true, 
2708:         success: true, 
        created: createdTasks.length,
2709:         created: createdTasks.length,
        tasks: createdTasks 
2710:         tasks: createdTasks 
      });
2711:       });
    } catch (error) {
2712:     } catch (error) {
      console.error("Failed to save tasks:", error);
2713:       console.error("Failed to save tasks:", error);
      res.status(500).json({ message: "Failed to save tasks" });
2714:       res.status(500).json({ message: "Failed to save tasks" });
    }
2715:     }
  });
2716:   });

2717: 
  app.get("/api/todos/:id/context", async (req, res) => {
2718:   app.get("/api/todos/:id/context", async (req, res) => {
    try {
2719:     try {
      const id = parseInt(req.params.id);
2720:       const id = parseInt(req.params.id);
      const todos = await storage.getTodos();
2721:       const todos = await storage.getTodos();
      const todo = todos.find(t => t.id === id);
2722:       const todo = todos.find(t => t.id === id);

2723: 
      if (!todo) {
2724:       if (!todo) {
        return res.status(404).json({ message: "Todo not found" });
2725:         return res.status(404).json({ message: "Todo not found" });
      }
2726:       }

2727: 
      // Get the source note for this todo
2728:       // Get the source note for this todo
      const sourceNote = await storage.getNote(todo.noteId);
2729:       const sourceNote = await storage.getNote(todo.noteId);

2730: 
      // Get related todos from the same note
2731:       // Get related todos from the same note
      const relatedTodos = todos.filter(t => t.noteId === todo.noteId && t.id !== todo.id);
2732:       const relatedTodos = todos.filter(t => t.noteId === todo.noteId && t.id !== todo.id);

2733: 
      // Generate AI context for this specific todo
      const prompt = `Provide intelligent context and insights for this todo item: "${todo.title}"

Source context: ${sourceNote?.content || 'No source context available'}

Focus on:
1. Why this task is important based on the source context
2. Any helpful tips or considerations for completing this task
3. Connections to related information from the source

Provide a concise, actionable response that adds value beyond just the task title.`;

      try {
        const aiResult = await analyzeWithOpenAI(prompt, "todo-context");

        const todoContext = {
          todo,
          sourceNote,
          ai_context: aiResult.enhancedContent || aiResult.suggestion,
          insights: [
            aiResult.context,
            ...aiResult.todos.filter((t: string) => t !== todo.title).map((t: string) => `Related: ${t}`)
          ].filter(Boolean),
          relatedTodos
        };

        res.json(todoContext);
      } catch (aiError) {
        // Fallback response without AI context if AI fails
        const todoContext = {
          todo,
          sourceNote,
          ai_context: undefined,
          insights: [],
          relatedTodos
        };
        res.json(todoContext);
      }
    } catch (error) {
      console.error("Todo context error:", error);
      res.status(500).json({ message: "Failed to fetch todo context" });
    }
  });

  // Collections endpoints
  app.get("/api/collections", async (req, res) => {
    try {
      const collections = await storage.getCollections();
      const collectionsWithCounts = await Promise.all(
        collections.map(async (collection) => {
          const notes = await storage.getNotesByCollectionId(collection.id);
          // Count only meaningful notes (exclude welcome notes and empty content)
          const meaningfulNotes = notes.filter(note => 
            note.content && 
            note.content.trim().length > 10 && 
            !note.content.startsWith('🎉 Welcome to Mira')
          );

          // Count open todos for this collection
          const openTodoCount = notes.reduce((count, note) => {
            const openTodos = note.todos.filter(todo => !todo.completed);
            return count + openTodos.length;
          }, 0);

          return { 
            ...collection, 
            noteCount: meaningfulNotes.length,
            openTodoCount 
          };
        })
      );
      res.json(collectionsWithCounts);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collections" });
    }
  });

  app.get("/api/collections/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }
      res.json(collection);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collection" });
    }
  });

  app.get("/api/collections/:id/notes", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const notes = await storage.getNotesByCollectionId(id);
      res.json(notes);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collection notes" });
    }
  });

  // GET route for super-note - automatically generates if not exists
  app.get("/api/collections/:id/super-note", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }

      const notes = await storage.getNotesByCollectionId(id);

      // Handle empty collections
      if (notes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `This is your ${collection.name} collection. Start adding notes and they'll appear here with AI-powered insights and organization.`,
          description: "Start adding notes to see them organized here",
          insights: [
            `Your ${collection.name} collection is ready to capture and organize your thoughts.`,
            "Add notes to this collection to see intelligent summaries and connections.",
            "AI will help extract tasks, insights, and organize your content automatically."
          ],
          structuredItems: {
            recommendedActions: [],
            researchResults: [],
            quickInsights: [`Empty ${collection.name} collection - ready for your content`]
          },
          allTodos: [],
          items: [],
          notes: [],
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Filter out notes with no meaningful content
      const meaningfulNotes = notes.filter(note => 
        note.content && 
        note.content.trim().length > 10 && 
        !note.content.startsWith('🎉 Welcome to Mira')
      );

      if (meaningfulNotes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `Your ${collection.name} collection contains ${notes.length} note(s), but they need more content for meaningful analysis.`,
          description: "Add more detailed content to unlock AI insights",
          insights: [
            "Add more detailed content to your notes for better AI insights.",
            `${collection.name} collection is ready for meaningful content.`
          ],
          structuredItems: {
            recommendedActions: [{ 
              title: "Add detailed content", 
              description: "Write more comprehensive notes to unlock AI-powered insights and organization." 
            }],
            researchResults: [],
            quickInsights: [`${notes.length} note(s) in ${collection.name} - add more detail for insights`]
          },
          allTodos: [],
          items: [],
          notes: meaningfulNotes,
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Get all todos from meaningful notes
      const allTodos = meaningfulNotes.flatMap(note => note.todos || []);

      // Get all items from this collection
      const collectionItems = await storage.getItemsByCollectionId(id);

      // Create aggregated content based on collection type
      let collectionContent = '';
      let collectionDescription = '';

      if (collectionItems.length > 0) {
        // Group items by type for better organization
        const itemsByType = collectionItems.reduce((acc: any, item) => {
          const type = item.type || 'item';
          if (!acc[type]) acc[type] = [];
          acc[type].push(item);
          return acc;
        }, {});

        // Create content based on collection type
        const collectionName = collection.name.toLowerCase();
        if (collectionName.includes('movie') || collectionName.includes('tv')) {
          collectionContent = '🎬 Movies & Shows:\n';
          collectionDescription = 'Movies and TV shows to watch';
        } else if (collectionName.includes('book') || collectionName.includes('read')) {
          collectionContent = '📚 Books & Reading:\n';
          collectionDescription = 'Books and reading materials';
        } else if (collectionName.includes('restaurant') || collectionName.includes('food')) {
          collectionContent = '🍽️ Restaurants & Food:\n';
          collectionDescription = 'Places to eat and food to try';
        } else {
          collectionContent = `📋 ${collection.name} Items:\n`;
          collectionDescription = `Items in your ${collection.name} collection`;
        }

        // Add each item as a line
        collectionItems.forEach(item => {
          collectionContent += `• ${item.title}`;
          if (item.description) {
            collectionContent += ` - ${item.description}`;
          }
          collectionContent += '\n';
        });
      } else {
        collectionContent = `Add notes with specific ${collection.name.toLowerCase()} to see them organized here.`;
        collectionDescription = `Items will appear here when extracted from your notes`;
      }

      const superNoteData = {
        collection,
        aggregatedContent: collectionContent,
        description: collectionDescription,
        insights: [
          `${collectionItems.length} individual items tracked`,
          `${allTodos.length} related tasks`,
          `${meaningfulNotes.length} source notes`
        ].filter(Boolean),
        structuredItems: {
          recommendedActions: allTodos.slice(0, 5).map((todo: any) => ({
            title: todo.title,
            description: "Task from your notes",
            noteId: todo.noteId
          })),
          extractedItems: collectionItems.map(item => ({
            title: item.title,
            description: item.description || '',
            type: item.type,
            sourceNoteId: item.sourceNoteId
          })),
          quickInsights: [
            `${collectionItems.length} items extracted`,
            `${allTodos.length} tasks available`,
            `${meaningfulNotes.length} notes in collection`
          ]
        },
        allTodos: allTodos,
        items: collectionItems,
        notes: meaningfulNotes,
        itemCount: collectionItems.length,
        todoCount: allTodos.length
      };

      res.json(superNoteData);
    } catch (error) {
      console.error("Super note fetch error:", error);
      res.status(500).json({ message: "Failed to fetch super note" });
    }
  });

  app.post("/api/collections/:id/super-note", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }

      const notes = await storage.getNotesByCollectionId(id);

      // Handle empty collections
      if (notes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `This is your ${collection.name} collection. Start adding notes and they'll appear here with AI-powered insights and organization.`,
          insights: [
            `Your ${collection.name} collection is ready to capture and organize your thoughts.`,
            "Add notes to this collection to see intelligent summaries and connections.",
            "AI will help extract tasks, insights, and organize your content automatically."
          ],
          structuredItems: {
            recommendedActions: [],
            researchResults: [],
            quickInsights: [`Empty ${collection.name} collection - ready for your content`]
          },
          allTodos: [],
          notes: [],
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Filter out notes with no meaningful content
      const meaningfulNotes = notes.filter(note => 
        note.content && 
        note.content.trim().length > 10 && 
        !note.content.startsWith('🎉 Welcome to Mira')
      );

      if (meaningfulNotes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `Your ${collection.name} collection contains ${notes.length} note(s), but they need more content for meaningful analysis.`,
          insights: [
            "Add more detailed content to your notes for better AI insights.",
            `${collection.name} collection is ready for meaningful content.`
          ],
          structuredItems: {
            recommendedActions: [{ 
              title: "Add detailed content", 
              description: "Write more comprehensive notes to unlock AI-powered insights and organization." 
            }],
            researchResults: [],
            quickInsights: [`${notes.length} note(s) in ${collection.name} - add more detail for insights`]
          },
          allTodos: [],
          notes: meaningfulNotes,
          itemCount: meaningfulNotes.length,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Get individual items extracted from notes in this collection
      const collectionItems = await storage.getItemsByCollectionId(id);
      const allTodos = meaningfulNotes.flatMap(note => note.todos || []);

      // Create collection-specific content based on type
      let collectionContent = "";
      let collectionDescription = "";

      const collectionName = collection.name.toLowerCase();

      if (collectionName.includes('book')) {
        collectionDescription = "Your reading list and book recommendations";
        collectionContent = collectionItems.length > 0 
          ? `📚 Books in your collection:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No books have been extracted yet. Add notes mentioning specific books to see them here.";
      } else if (collectionName.includes('movie') || collectionName.includes('tv')) {
        collectionDescription = "Movies and TV shows to watch";
        collectionContent = collectionItems.length > 0 
          ? `🎬 Movies & Shows:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No movies or shows have been extracted yet. Add notes mentioning specific titles to see them here.";
      } else if (collectionName.includes('restaurant') || collectionName.includes('food')) {
        collectionDescription = "Places to eat and food recommendations";
        collectionContent = collectionItems.length > 0 
          ? `🍽️ Restaurants & Food:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No restaurants have beenextracted yet. Add notes mentioning specific places to eat to see them here.";
      } else if (collectionName.includes('product')) {
        collectionDescription = "Products and items of interest";
        collectionContent = collectionItems.length > 0 
          ? `🛍️ Products:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No products have been extracted yet. Add notes mentioning specific products to see them here.";
      } else if (collectionName.includes('place') || collectionName.includes('travel')) {
        collectionDescription = "Places to visit and travel destinations";
        collectionContent = collectionItems.length > 0 
          ? `📍 Places:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No places have been extracted yet. Add notes mentioning specific locations to see them here.";
      } else if (collectionName.includes('person') || collectionName.includes('contact')) {
        collectionDescription = "People and contacts";
        collectionContent = collectionItems.length > 0 
          ? `👥 People:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No people have been extracted yet. Add notes mentioning specific individuals to see them here.";
      } else {
        // Generic collection
        collectionDescription = `Your ${collection.name} collection`;
        collectionContent = collectionItems.length > 0 
          ? `📋 Items:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : `No specific items have been extracted yet. Add notes with specific ${collection.name.toLowerCase()} to see them organized here.`;
      }

      const superNoteData = {
        collection,
        aggregatedContent: collectionContent,
        description: collectionDescription,
        insights: [
          `${collectionItems.length} individual items tracked`,
          `${allTodos.length} related tasks`,
          `${meaningfulNotes.length} source notes`
        ].filter(Boolean),
        structuredItems: {
          recommendedActions: allTodos.slice(0, 5).map(todo => ({
            title: todo.title,
            description: "Task from your notes",
            noteId: todo.noteId
          })),
          extractedItems: collectionItems.map(item => ({
            title: item.title,
            description: item.description || '',
            type: item.type,
            sourceNoteId: item.sourceNoteId
          })),
          quickInsights: [
            `${collectionItems.length} items extracted`,
            `${allTodos.length} tasks available`,
            `${meaningfulNotes.length} notes in collection`
          ]
        },
        allTodos: allTodos,
        items: collectionItems,
        notes: meaningfulNotes,
        itemCount: collectionItems.length,
        todoCount: allTodos.length
      };

      res.json(superNoteData);
    } catch (error) {
      console.error("Super note generation error:", error);
      res.status(500).json({ message: "Failed to generate super note" });
    }
  });

  app.post("/api/collections", async (req, res) => {
    try {
      const collectionData = insertCollectionSchema.parse(req.body);
      const collection = await storage.createCollection(collectionData);
      res.json(collection);
    } catch (error) {
      res.status(400).json({ message: "Invalid collection data" });
    }
  });

  app.post("/api/collections/reorder", async (req, res) => {
    try {
      const { updates } = req.body;

      if (!updates || !Array.isArray(updates)) {
        return res.status(400).json({ message: "Updates array required" });
      }

      // Update each collection's display order
      for (const update of updates) {
        await storage.updateCollection(update.id, { displayOrder: update.displayOrder });
      }

      res.json({ success: true });
    } catch (error) {
      console.error("Collection reorder error:", error);
      res.status(500).json({ message: "Failed to reorder collections" });
    }
  });

  // Items API routes
  app.get("/api/items", async (req, res) => {
    try {
      const items = await storage.getItems();
      res.json(items);
    } catch (error) {
      console.error("Failed to fetch items:", error);
      res.status(500).json({ message: "Failed to fetch items" });
    }
  });

  app.get("/api/collections/:id/items", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const items = await storage.getItemsByCollectionId(id);
      res.json(items);
    } catch (error) {
      console.error("Failed to fetch collection items:", error);
      res.status(500).json({ message: "Failed to fetch collection items" });
    }
  });

  app.post("/api/items", async (req, res) => {
    try {
      const itemData = insertItemSchema.parse(req.body);
      const item = await storage.createItem(itemData);
      res.json(item);
    } catch (error) {
      console.error("Failed to create item:", error);
      res.status(400).json({ message: "Invalid item data" });
    }
  });

  app.patch("/api/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const item = await storage.updateItem(id, updates);
      res.json(item);
    } catch (error) {
      console.error("Failed to update item:", error);
      res.status(500).json({ message: "Failed to update item" });
    }
  });

  app.delete("/api/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteItem(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete item:", error);
      res.status(500).json({ message: "Failed to delete item" });
    }
  });

  // Reminder endpoints for consolidated todo approach
  app.post("/api/reminders", async (req, res) => {
    try {
      const { title, description, reminderTime, todoId, noteId } = req.body;
      const reminder = await storage.createReminder({
        title,
        description,
        reminderTime: new Date(reminderTime),
        todoId,
        noteId
      });
      res.json(reminder);
    } catch (error) {
      console.error("Failed to create reminder:", error);
      res.status(500).json({ message: "Failed to create reminder" });
    }
  });



  // Add optional todo to main todos list
  app.post("/api/todos/add-optional", async (req, res) => {
    try {
      const { title, noteId, description } = req.body;
      const todo = await storage.createTodo({
        title,
        noteId
      });
      res.json(todo);
    } catch (error) {
      console.error("Failed to add optional todo:", error);
      res.status(500).json({ message: "Failed to add optional todo" });
    }
  });

  // Notification system endpoints
  app.get("/api/notifications/status", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const status = notificationSystem.getNotificationStatus();
      res.json(status);
    } catch (error) {
      console.error("Failed to get notification status:", error);
      res.status(500).json({ message: "Failed to get notification status" });
    }
  });

  app.post("/api/notifications/refresh", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      const status = notificationSystem.getNotificationStatus();
      res.json({ message: "Notifications refreshed", status });
    } catch (error) {
      console.error("Failed to refresh notifications:", error);
      res.status(500).json({ message: "Failed to refresh notifications" });
    }
  });

  app.post("/api/todos/:id/toggle", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const todo = await storage.updateTodo(id, { completed: !req.body.completed });

      // If completing a reminder, refresh notification schedules
      if (todo.isActiveReminder) {
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.refreshNotifications();
      }

      res.json(todo);
    } catch (error) {
      console.error("Failed to toggle todo:", error);
      res.status(500).json({ message: "Failed to toggle todo" });
    }
  });

  // Enhanced todo creation for reminders
  app.post("/api/todos", async (req, res) => {
    try {
      const todoData = insertTodoSchema.parse(req.body);

      // Ensure isActiveReminder defaults to false if not specified
      const enhancedTodoData = {
        ...todoData,
        isActiveReminder: todoData.isActiveReminder || false,
        completed: todoData.completed || false,
        archived: todoData.archived || false
      };

      const todo = await storage.createTodo(enhancedTodoData);

      // If this is an active reminder, schedule notifications
      if (todo.isActiveReminder && todo.timeDue) {
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.scheduleNotifications(todo);
      }

      res.json(todo);
    } catch (error) {
      console.error("Failed to create todo:", error);
      res.status(400).json({ message: "Invalid todo data" });
    }
  });

  // Notification system endpoints
  app.get("/api/notifications/status", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const status = notificationSystem.getNotificationStatus();
      res.json(status);
    } catch (error) {
      console.error("Failed to get notification status:", error);
      res.status(500).json({ message: "Failed to get notification status" });
    }
  });

  app.get("/api/notifications/recent", async (req, res) => {
    try {
      // Return recent notifications (placeholder for now)
      res.json({ recent: [] });
    } catch (error) {
      console.error("Failed to get recent notifications:", error);
      res.status(500).json({ message: "Failed to get recent notifications" });
    }
  });

  app.post("/api/notifications/test", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const { title, message, scheduledTime } = req.body;
      
      // Create a test notification
      console.log(`🔔 Test notification: ${title} - ${message} at ${scheduledTime}`);
      
      res.json({ 
        success: true, 
        message: "Test notification created",
        scheduledTime 
      });
    } catch (error) {
      console.error("Failed to create test notification:", error);
      res.status(500).json({ message: "Failed to create test notification" });
    }
  });

  // Reminder state management endpoints
  app.post("/api/reminders/parse", async (req, res) => {
    try {
      const { content } = req.body;
      const { IntelligentReminderParser } = await import('./utils/intelligent-reminder-parser');
      const parsed = IntelligentReminderParser.parseReminder(content);
      
      let timeString = null;
      let leadTime = null;
      
      if (parsed.timeReference) {
        timeString = parsed.timeReference.originalText;
      }
      
      if (parsed.context) {
        leadTime = `${parsed.context.defaultLeadTime}`;
      }
      
      res.json({
        isReminder: parsed.isReminder,
        timeString,
        leadTime,
        dueTime: parsed.timeReference?.parsedTime,
        recurrence: parsed.recurringPattern,
        category: parsed.context?.type,
        urgency: parsed.context?.urgency
      });
    } catch (error) {
      console.error("Failed to parse reminder:", error);
      res.status(500).json({ message: "Failed to parse reminder" });
    }
  });

  app.post("/api/reminders", async (req, res) => {
    try {
      const { content, parsedInfo } = req.body;
      
      // Create note first
      const note = await storage.createNote({
        content,
        mode: "text"
      });

      // Process with AI to create reminder
      const miraModule = await import('./brain/miraAIProcessing');
      const analysis = await miraModule.processNote({
        content,
        mode: "text",
        req
      });

      // Update note with AI analysis
      await storage.updateNote(note.id, {
        content: analysis.title,
        ai_enhanced: true,
        ai_suggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
        ai_context: analysis.summary || "",
        is_processing: false
      });

      // Create reminder todo with proper state
      if (analysis.todos && analysis.todos.length > 0) {
        const todo = analysis.todos[0];
        const reminderData: any = {
          noteId: note.id,
          title: todo.title,
          isActiveReminder: true,
          reminderState: 'active',
          priority: todo.priority || 'medium'
        };

        if (parsedInfo?.dueTime) {
          reminderData.dueDate = new Date(parsedInfo.dueTime);
          reminderData.timeDue = new Date(parsedInfo.dueTime);
        }

        if (parsedInfo?.recurrence) {
          reminderData.recurrenceRule = parsedInfo.recurrence;
        }

        const createdTodo = await storage.createTodo(reminderData);
        
        // Refresh notifications
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.refreshNotifications();

        res.json({
          id: createdTodo.id,
          title: createdTodo.title,
          dueDate: createdTodo.dueDate,
          reminderState: createdTodo.reminderState,
          note: note
        });
      } else {
        res.status(400).json({ message: "Failed to create reminder from input" });
      }
    } catch (error) {
      console.error("Failed to create reminder:", error);
      res.status(500).json({ message: "Failed to create reminder" });
    }
  });

  app.get("/api/reminders", async (req, res) => {
    try {
      const { state } = req.query;
      console.log(`Fetching reminders with state filter: ${state}`);
      
      const todos = await storage.getTodos();
      console.log(`Total todos: ${todos.length}`);
      
      let reminders = todos.filter(todo => todo.isActiveReminder === true);
      console.log(`Filtered active reminders: ${reminders.length}`);
      
      if (state && state !== 'all') {
        reminders = reminders.filter(todo => todo.reminderState === state);
        console.log(`After state filter '${state}': ${reminders.length}`);
      }
      
      // Transform todos to reminder format expected by frontend
      const transformedReminders = reminders.map(todo => ({
        id: todo.id,
        title: todo.title,
        dueDate: todo.dueDate || todo.timeDue,
        reminderState: todo.reminderState || 'active',
        priority: todo.priority,
        reminderType: todo.plannedNotificationStructure?.reminderCategory || 'general',
        completed: todo.completed,
        created_at: todo.created_at
      }));
      
      console.log(`Returning ${transformedReminders.length} transformed reminders`);
      res.json(transformedReminders);
    } catch (error) {
      console.error("Failed to fetch reminders:", error);
      res.status(500).json({ message: "Failed to fetch reminders" });
    }
  });

  app.put("/api/reminders/:id/complete", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        completed: true,
        reminderState: 'completed'
      });
      
      // Refresh notifications
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to complete reminder:", error);
      res.status(500).json({ message: "Failed to complete reminder" });
    }
  });

  app.put("/api/reminders/:id/dismiss", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        reminderState: 'dismissed',
        dismissedAt: new Date()
      });
      
      // Refresh notifications
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to dismiss reminder:", error);
      res.status(500).json({ message: "Failed to dismiss reminder" });
    }
  });

  app.put("/api/reminders/:id/archive", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        reminderState: 'archived',
        archivedAt: new Date()
      });
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to archive reminder:", error);
      res.status(500).json({ message: "Failed to archive reminder" });
    }
  });

  // User reminder settings endpoints
  app.get("/api/user/reminder-settings", async (req, res) => {
    try {
      // For now, return default settings since we don't have user auth
      res.json({
        reminderSettings: {
          defaultLeadTimes: {
            general: 10,
            pickup: 10,
            appointment: 30,
            medication: 0,
            call: 5,
            meeting: 15,
            flight: 120
          },
          autoArchiveAfterDays: 1,
          showOverdueReminders: true,
          enablePushNotifications: true
        }
      });
    } catch (error) {
      console.error("Failed to get reminder settings:", error);
      res.status(500).json({ message: "Failed to get reminder settings" });
    }
  });

  app.put("/api/user/reminder-settings", async (req, res) => {
    try {
      const { reminderSettings } = req.body;
      
      // For now, just return success since we don't have user auth
      // In a real app, this would update the user's settings in the database
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to update reminder settings:", error);
      res.status(500).json({ message: "Failed to update reminder settings" });
    }
  });

  // Archive expired reminders (called by scheduled job)
  app.post("/api/reminders/archive-expired", async (req, res) => {
    try {
      const todos = await storage.getTodos();
      const now = new Date();
      const endOfYesterday = new Date(now);
      endOfYesterday.setDate(endOfYesterday.getDate() - 1);
      endOfYesterday.setHours(23, 59, 59, 999);

      let archivedCount = 0;
      
      for (const todo of todos) {
        if (todo.isActiveReminder && 
            todo.reminderState === 'active' && 
            todo.dueDate && 
            todo.dueDate < endOfYesterday) {
          
          await storage.updateTodo(todo.id, {
            reminderState: 'archived',
            archivedAt: new Date()
          });
          archivedCount++;
        }
      }

      // Refresh notifications after archiving
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();

      res.json({ archivedCount });
    } catch (error) {
      console.error("Failed to archive expired reminders:", error);
      res.status(500).json({ message: "Failed to archive expired reminders" });
    }
  });

  // Cleanup old todos, reminders, and notes
  app.post("/api/cleanup/old-todos-reminders", async (req, res) => {
    try {
      // Get current state
      const todos = await storage.getTodos();
      const notes = await storage.getNotes();
      
      console.log(`Total todos before cleanup: ${todos.length}`);
      console.log(`Total notes before cleanup: ${notes.length}`);

      // Separate todos and reminders
      const regularTodos = todos.filter(todo => !todo.isActiveReminder);
      const reminders = todos.filter(todo => todo.isActiveReminder === true);

      console.log(`Regular todos: ${regularTodos.length}, Reminders: ${reminders.length}`);

      // Sort by creation date (oldest first)
      const sortedTodos = regularTodos.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
      const sortedReminders = reminders.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
      const sortedNotes = notes.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());

      // Calculate how many to delete
      const todosToDeleteCount = Math.floor(sortedTodos.length * 0.8); // 80% of todos
      const remindersToDeleteCount = Math.floor(sortedReminders.length * 0.6); // 60% of reminders
      const notesToDeleteCount = Math.floor(sortedNotes.length * 0.8); // 80% of notes

      console.log(`Will delete ${todosToDeleteCount} todos, ${remindersToDeleteCount} reminders, and ${notesToDeleteCount} notes`);

      let deletedCount = 0;

      // Delete oldest 80% of todos
      const todosToDelete = sortedTodos.slice(0, todosToDeleteCount);
      for (const todo of todosToDelete) {
        try {
          await storage.deleteTodo(todo.id);
          deletedCount++;
          console.log(`Deleted todo: "${todo.title}" (created: ${todo.created_at})`);
        } catch (error) {
          console.error(`Failed to delete todo ${todo.id}:`, error);
        }
      }

      // Delete oldest 60% of reminders
      const remindersToDelete = sortedReminders.slice(0, remindersToDeleteCount);
      for (const reminder of remindersToDelete) {
        try {
          await storage.deleteTodo(reminder.id);
          deletedCount++;
          console.log(`Deleted reminder: "${reminder.title}" (created: ${reminder.created_at})`);
        } catch (error) {
          console.error(`Failed to delete reminder ${reminder.id}:`, error);
        }
      }

      // Delete oldest 80% of notes
      const notesToDelete = sortedNotes.slice(0, notesToDeleteCount);
      for (const note of notesToDelete) {
        try {
          await storage.deleteNote(note.id);
          deletedCount++;
          console.log(`Deleted note: "${note.content.slice(0, 50)}..." (created: ${note.created_at})`);
        } catch (error) {
          console.error(`Failed to delete note ${note.id}:`, error);
        }
      }

      // Refresh notifications after cleanup
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();

      const finalTodos = await storage.getTodos();
      const finalNotes = await storage.getNotes();
      
      console.log(`Total todos after cleanup: ${finalTodos.length}`);
      console.log(`Total notes after cleanup: ${finalNotes.length}`);

      res.json({
        success: true,
        deletedCount,
        breakdown: {
          todosDeleted: todosToDeleteCount,
          remindersDeleted: remindersToDeleteCount,
          notesDeleted: notesToDeleteCount,
          remainingTodos: finalTodos.filter(t => !t.isActiveReminder).length,
          remainingReminders: finalTodos.filter(t => t.isActiveReminder === true).length,
          remainingNotes: finalNotes.length
        },
        message: `Successfully deleted ${deletedCount} items (${todosToDeleteCount} todos + ${remindersToDeleteCount} reminders + ${notesToDeleteCount} notes)`
      });

    } catch (error) {
      console.error("Cleanup operation failed:", error);
      res.status(500).json({ 
        success: false,
        message: "Failed to cleanup old todos, reminders, and notes",
        error: error.message 
      });
    }
  });

  // Create and return HTTP server
  const server = createServer(app);
  return server;
}

===== storage.updateNote definitions =====
122:  updateNote: async (
>> surrounding bodies
     1	// Part 1: Storage helper stubs for V3 enhancement
     2	import { pool } from './db';  // Use the shared pool from db.ts
     3	import crypto from "node:crypto";
     4	
     5	// Re-export pool for modules that import it directly
     6	export { pool };
     7	
     8	// Export a storage object for compatibility with existing imports
     9	export const storage = {
    10	  pool,
    11	  // Add placeholder methods that other modules expect
    12	  createNote: async (noteData: any) => {
    13	    try {
    14	      const client = await pool.connect();
    15	      const result = await client.query(
    16	        `INSERT INTO notes (content, user_id, collection_id, mode, is_processing) 
    17	         VALUES ($1, $2, $3, $4, $5) 
    18	         RETURNING *`,
    19	        [noteData.content, noteData.userId || 'demo', noteData.collectionId, noteData.mode || 'text', noteData.isProcessing || true]
    20	      );
    21	      client.release();
    22	      return result.rows[0];
    23	    } catch (error) {
    24	      console.error('Error creating note:', error);
    25	      throw error;
    26	    }
    27	  },
    28	  createTodo: async () => ({}),
    29	  createReminder: async () => ({}),
    30	  getCollections: async () => [],
    31	  getTodos: async () => {
    32	    try {
    33	      const client = await pool.connect();
    34	      const result = await client.query('SELECT * FROM todos ORDER BY created_at DESC');
    35	      client.release();
    36	      return result.rows;
    37	    } catch (error) {
    38	      console.error('Error fetching todos:', error);
    39	      return [];
    40	    }
    41	  },
    42	  getNotes: async () => {
    43	    try {
    44	      const client = await pool.connect();
    45	      const result = await client.query('SELECT * FROM notes ORDER BY created_at DESC');
    46	      client.release();
    47	      // Transform field names to match frontend expectations
    48	      return result.rows.map(note => ({
    49	        ...note,
    50	        createdAt: note.created_at, // Add camelCase version
    51	        aiGeneratedTitle: note.ai_generated_title,
    52	        isProcessing: note.is_processing,
    53	        audioUrl: note.audio_url,
    54	        mediaUrl: note.media_url,
    55	        aiEnhanced: note.ai_enhanced,
    56	        aiSuggestion: note.ai_suggestion,
    57	        aiContext: note.ai_context,
    58	        richContext: note.rich_context,
    59	        miraResponse: note.mira_response,
    60	        collectionId: note.collection_id,
    61	        isShared: note.is_shared,
    62	        shareId: note.share_id,
    63	        privacyLevel: note.privacy_level,
    64	        userId: note.user_id,
    65	        imageData: note.image_data,
    66	        tokenUsage: note.token_usage,
    67	      }));
    68	    } catch (error) {
    69	      console.error('Error fetching notes:', error);
    70	      return [];
    71	    }
    72	  },
    73	  getUsers: async () => [],
    74	  createCollection: async () => ({}),
    75	  getNote: async (id: number) => {
    76	    try {
    77	      const client = await pool.connect();
    78	      const result = await client.query('SELECT * FROM notes WHERE id = $1', [id]);
    79	      client.release();
    80	      const note = result.rows[0];
    81	      if (!note) return null;
    82	      // Transform field names to match frontend expectations
    83	      return {
    84	        ...note,
    85	        createdAt: note.created_at,
    86	        aiGeneratedTitle: note.ai_generated_title,
    87	        isProcessing: note.is_processing,
    88	        audioUrl: note.audio_url,
    89	        mediaUrl: note.media_url,
    90	        aiEnhanced: note.ai_enhanced,
    91	        aiSuggestion: note.ai_suggestion,
    92	        aiContext: note.ai_context,
    93	        richContext: note.rich_context,
    94	        miraResponse: note.mira_response,
    95	        collectionId: note.collection_id,
    96	        isShared: note.is_shared,
    97	        shareId: note.share_id,
    98	        privacyLevel: note.privacy_level,
    99	        userId: note.user_id,
   100	        imageData: note.image_data,
   101	        tokenUsage: note.token_usage,
   102	      };
   103	    } catch (error) {
   104	      console.error('Error fetching note:', error);
   105	      return null;
   106	    }
   107	  },
   108	  getTodosByNoteId: async (noteId: number) => {
   109	    try {
   110	      const client = await pool.connect();
   111	      const result = await client.query('SELECT * FROM todos WHERE note_id = $1 ORDER BY created_at DESC', [noteId]);
   112	      client.release();
   113	      return result.rows;
   114	    } catch (error) {
   115	      console.error('Error fetching todos for note:', error);
   116	      return [];
   117	    }
   118	  },
   119	
   120	
   121	  // Accepts { content?, doc_json? } only.
   122	  updateNote: async (
   123	    id: number,
   124	    { content, doc_json }: { content?: string | null; doc_json?: any }
   125	  ) => {
   126	    if (content == null && doc_json == null)
   127	      return (await pool.query('SELECT * FROM notes WHERE id = $1', [id])).rows[0];
   128	
   129	    const fields: string[] = [];
   130	    const values: any[]   = [id];
   131	
   132	    if (content != null)   { fields.push(`content   = $${values.length + 1}`);   values.push(content); }
   133	    if (doc_json != null)  { fields.push(`doc_json  = $${values.length + 1}`);   values.push(doc_json); }
   134	
   135	    const { rows } = await pool.query(
   136	      `UPDATE notes SET ${fields.join(', ')}
   137	       WHERE id = $1 RETURNING *`,
   138	      values
   139	    );
   140	    return rows[0];
   141	  },
   142	
   143	  /* ---------- missing CRUD helpers (todos & notes) ---------- */
   144	  async updateTodo(id: number, updates: Record<string, any>) {
   145	    const ALLOWED = ['title', 'completed', 'priority', 'due_date'] as const;
   146	    const pairs = Object.entries(updates).filter(([k, v]) =>
   147	      ALLOWED.includes(k as any) && v !== undefined && v !== null
   148	    );
   149	    if (pairs.length === 0) {
   150	      const { rows } = await pool.query('SELECT * FROM todos WHERE id = $1', [id]);
   151	      return rows[0] ?? null;
   152	    }
   153	    const set = pairs.map(([k], i) => `${k} = $${i + 2}`).join(', ');
   154	    const vals = [id, ...pairs.map(([, v]) => v)];
   155	    const { rows } = await pool.query(
   156	      `UPDATE todos SET ${set} WHERE id = $1 RETURNING *`,
   157	      vals
   158	    );
   159	    return rows[0];
   160	  },
   161	
   162	  async deleteTodo(id: number) {
   163	    const { rows } = await pool.query('DELETE FROM todos WHERE id = $1 RETURNING *', [id]);
   164	    return rows[0] ?? null;
   165	  },
   166	
   167	  async deleteNote(id: number) {
   168	    await pool.query('DELETE FROM todos WHERE note_id = $1', [id]);
   169	    const { rows } = await pool.query('DELETE FROM notes WHERE id = $1 RETURNING *', [id]);
   170	    return rows[0] ?? null;
   171	  }
   172	};
   173	
   174	export async function getUserPatterns(userId: string): Promise<any> {
   175	  return { 
   176	    summary: 'active user; prefers concise answers',
   177	    recentTopics: [],
   178	    preferredStyle: 'practical'
   179	  };
   180	}
   181	
   182	export async function getCollectionHints(text: string): Promise<any[]> {
   183	  const lower = text.toLowerCase();
   184	  
   185	  if (/flight|hotel|trip|travel/i.test(lower)) {
   186	    return [{ name: 'travel', icon: 'plane' }];
   187	  }
   188	  if (/ticket|game|concert|event/i.test(lower)) {
   189	    return [{ name: 'events', icon: 'calendar' }];
   190	  }
   191	  if (/health|doctor|medicine|vitamins/i.test(lower)) {
   192	    return [{ name: 'health', icon: 'heart' }];
   193	  }
   194	  if (/shopping|buy|purchase|store/i.test(lower)) {
   195	    return [{ name: 'shopping', icon: 'shopping-bag' }];
   196	  }
   197	  
   198	  return [{ name: 'general', icon: 'folder' }];
   199	}
   200	
   201	export async function getRecentNotes(userId: string, limit = 5): Promise<string[]> {
   202	  try {
   203	    const client = await pool.connect();
   204	    const result = await client.query(
   205	      'SELECT content FROM notes WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2',
   206	      [userId, limit]
   207	    );
   208	    client.release();
   209	    
   210	    return result.rows.map(row => row.content.substring(0, 100)); // Truncate for context
   211	  } catch (error) {
   212	    console.warn('[Storage] Failed to fetch recent notes:', error);
   213	    return [];
   214	  }
   215	}

===== other storage methods that routes.ts might call =====

===== client calls to /patch or POST /api/notes/:id =====

===== save paths (note-detail, queue, editor) =====

===== query keys and invalidation =====
--- client/src/utils/queryKeys.ts
     1	export const queryKeys = {
     2	  notes: {
     3	    all: ['/api/notes'] as const,
     4	    detail: (id: number) => [`/api/notes/${id}`] as const,
     5	    versions: (id: number) => [`/api/notes/${id}/versions`] as const,
     6	  },
     7	  collections: {
     8	    all: ['/api/collections'] as const,
     9	  },
    10	  todos: {
    11	    all: ['/api/todos'] as const,
    12	  }
    13	} as const;
client/src/components/media-context-dialog.tsx:202:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/media-context-dialog.tsx:203:      queryClient.invalidateQueries({ queryKey: queryKeys.collections.all });
client/src/components/todos-view-backup.tsx:111:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/todos-view-backup.tsx:121:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/todos-view-backup.tsx:131:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/todos-view.tsx:128:      queryClient.setQueryData<Todo[]>(["/api/todos"], (old) =>
client/src/components/todos-view.tsx:139:        queryClient.setQueryData(["/api/todos"], context.previousTodos);
client/src/components/todos-view.tsx:143:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/todos-view.tsx:153:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/todos-view.tsx:163:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/input-bar.tsx:121:      queryClient.setQueryData(queryKeys.notes.all, [
client/src/components/input-bar.tsx:134:      queryClient.setQueryData(queryKeys.notes.all, (old?: any[]) =>
client/src/components/input-bar.tsx:138:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/input-bar.tsx:166:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/input-bar.tsx:185:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/input-bar.tsx:186:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/input-bar.tsx:213:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/input-bar.tsx:232:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/input-bar.tsx:233:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/input-bar.tsx:261:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/input-bar.tsx:280:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/input-bar.tsx:281:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/input-bar.tsx:367:        await queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(noteId) });
client/src/components/capture-area.tsx:30:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/capture-area.tsx:31:      queryClient.refetchQueries({ queryKey: queryKeys.notes.all });
client/src/components/capture-area.tsx:32:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/note-card.tsx:275:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/note-card.tsx:296:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/note-card.tsx:297:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/note-card.tsx:755:          queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/ios-voice-recorder.tsx:72:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/ios-voice-recorder.tsx:73:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/voice-modal.tsx:44:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/voice-modal.tsx:45:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/inline-voice-recorder.tsx:112:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/inline-voice-recorder.tsx:113:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/components/full-screen-capture-backup.tsx:66:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/components/collections-view.tsx:91:      queryClient.setQueryData(queryKeys.collections.all, reorderedCollections);
client/src/components/collections-view.tsx:97:      queryClient.setQueryData(queryKeys.collections.all, context?.previousCollections);
client/src/components/collections-view.tsx:101:      queryClient.invalidateQueries({ queryKey: queryKeys.collections.all });
client/src/components/activity-feed.tsx:120:              queryClient.removeQueries({ queryKey: queryKeys.notes.all });
client/src/hooks/use-realtime-updates.ts:45:              queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/hooks/use-realtime-updates.ts:61:              queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/hooks/use-realtime-updates.ts:63:                queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(data.noteId) });
client/src/hooks/use-notes.ts:25:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/hooks/use-notes.ts:26:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/hooks/use-notes.ts:27:      queryClient.invalidateQueries({ queryKey: queryKeys.collections.all });
client/src/hooks/use-notes.ts:29:      queryClient.refetchQueries({ queryKey: queryKeys.notes.all });
client/src/hooks/use-notes.ts:30:      queryClient.refetchQueries({ queryKey: ["/api/todos"] });
client/src/hooks/use-notes.ts:55:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/hooks/use-notes.ts:56:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/hooks/use-notes.ts:57:      queryClient.invalidateQueries({ queryKey: queryKeys.collections.all });
client/src/pages/remind-original.tsx:42:      queryClient.invalidateQueries({ queryKey: ["/api/reminders"] });
client/src/pages/remind-original.tsx:62:      queryClient.invalidateQueries({ queryKey: ["/api/reminders"] });
client/src/pages/remind-original.tsx:81:      queryClient.invalidateQueries({ queryKey: ["/api/reminders"] });
client/src/pages/note-detail.tsx.bak:210:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(id) });
client/src/pages/note-detail.tsx.bak:229:      queryClient.setQueryData(queryKeys.notes.detail(updated.id), updated);
client/src/pages/note-detail.tsx.bak:231:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/pages/note-detail.tsx.bak:325:        queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak:374:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak:375:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all }); // Fix navigation issue
client/src/pages/note-detail.tsx.bak:407:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak:418:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak:433:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak:450:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak:560:      await queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak:561:      await queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/pages/note-detail.tsx.bak:562:      await queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/note-detail.tsx.bak:1100:                                    queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(note.id) });
client/src/pages/note-detail.tsx.bak:1418:          queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/note-detail.tsx.bak-202508070225:210:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(id) });
client/src/pages/note-detail.tsx.bak-202508070225:229:      queryClient.setQueryData(queryKeys.notes.detail(updated.id), updated);
client/src/pages/note-detail.tsx.bak-202508070225:231:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/pages/note-detail.tsx.bak-202508070225:325:        queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak-202508070225:374:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak-202508070225:375:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all }); // Fix navigation issue
client/src/pages/note-detail.tsx.bak-202508070225:407:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak-202508070225:418:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak-202508070225:433:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak-202508070225:450:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak-202508070225:560:      await queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx.bak-202508070225:561:      await queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/pages/note-detail.tsx.bak-202508070225:562:      await queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/note-detail.tsx.bak-202508070225:1100:                                    queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(note.id) });
client/src/pages/note-detail.tsx.bak-202508070225:1418:          queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/profile.tsx:76:      queryClient.invalidateQueries({ queryKey: ["/api/profile"] });
client/src/pages/profile.tsx:105:      queryClient.invalidateQueries({ queryKey: ["/api/profile"] });
client/src/pages/profile.tsx:106:      queryClient.invalidateQueries({ queryKey: ["/api/profile", "demo"] });
client/src/pages/settings.tsx:61:      queryClient.invalidateQueries({ queryKey: ["/api/profile"] });
client/src/pages/settings.tsx:90:      queryClient.invalidateQueries({ queryKey: ["/api/profile"] });
client/src/pages/settings.tsx:91:      queryClient.invalidateQueries({ queryKey: ["/api/profile", "demo"] });
client/src/pages/remind.tsx:44:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/remind.tsx:45:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/pages/remind.tsx:65:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/remind.tsx:83:    queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/todo-detail.tsx:30:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/todo-detail.tsx:43:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/todo-detail.tsx:55:      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
client/src/pages/note-detail-new.tsx:57:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(parseInt(id || "0")) });
client/src/pages/note-detail-new.tsx:58:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/pages/note-detail-new.tsx:67:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/pages/note-detail-new.tsx:78:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(parseInt(id || "0")) });
client/src/pages/collection-detail.tsx:68:      queryClient.setQueryData([...queryKeys.collections.all, id, "super-note"], data);
client/src/pages/note-detail.tsx:388:        queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx:403:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx:418:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx:435:      queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx:546:      await queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx:547:      await queryClient.invalidateQueries({ queryKey: queryKeys.notes.all });
client/src/pages/note-detail.tsx:548:      await queryClient.invalidateQueries({ queryKey: queryKeys.todos.all });
client/src/pages/note-detail.tsx:1143:                                    queryClient.invalidateQueries({ queryKey: queryKeys.notes.detail(Number(id)) });
client/src/pages/note-detail.tsx:1461:          queryClient.invalidateQueries({ queryKey: queryKeys.todos.all });

===== Activity feed polling & caching =====
client/src/components/NoteDetailSimple-broken.tsx:22:    staleTime: 60000, // Cache individual notes for 1 minute
client/src/components/NoteDetailSimple-broken.tsx:23:    gcTime: 300000, // Keep in cache for 5 minutes
client/src/components/activity-feed.tsx.bak-202508070225:23:    staleTime: 15000, // 15 second cache
client/src/components/activity-feed.tsx.bak-202508070225:24:    gcTime: 300000, // Keep in cache for 5 minutes
client/src/components/activity-feed.tsx.bak-202508070225:27:    refetchInterval: false,
client/src/components/activity-feed.tsx:27:    staleTime: 1000, // 1 second cache for immediate updates
client/src/components/activity-feed.tsx:28:    gcTime: 10000, // Keep in cache for 10 seconds only
client/src/components/activity-feed.tsx:31:    refetchInterval: false,

===== SSE/WebSocket endpoints (server) =====
server/utils/brain/promptTemplates/scheduledEvent.ts:5:SYSTEM: You are Mira's elite secretary team specializing in scheduled events. Output **ONLY** valid JSON following the schema provided.
server/utils/real-time-notifications.ts:3: * Broadcasts note creation events to all connected clients
server/web-search.ts:235:  // This prevents showing synthetic data to users
server/web-search.ts:251:      description: `Best event spaces and party venues for birthdays, celebrations, and special events in ${locationString}.`,
server/web-search.ts:390:  // This prevents arbitrary defaults and forces generic searches
server/notification-system.ts:180:    // - WebSocket for real-time updates
server/ai/v3/memory/simple-memory.ts:86:        INSERT INTO memory.events
server/ai/v3/memory/simple-memory.ts:104:        SELECT * FROM memory.events
server/ai/v3/reasoning/stage4a-validator.ts:3: * Prevents malformed AI responses from reaching the database
server/ai/v3/enhance/sse-manager.ts:1:import { EventEmitter } from 'events';
server/ai/v3/enhance/worker.ts:9:import { broadcastToNote } from '../realtime/sse-manager';
server/ai/v3/enhance/queue-worker.ts:107:      // IDEMPOTENCY CHECK with row lock (prevents race conditions)
server/openai.ts:216:    const imageAnalysisPrompt = `You are an expert visual analyst with comprehensive knowledge across technology, business, culture, and current events. Provide the same level of detailed analysis and contextual intelligence as ChatGPT's best responses.
server/routes.ts.bak:4:import { registerClient } from "./ai/v3/realtime/sse-manager";
server/routes.ts.bak:612:  // SSE endpoint for note events
server/routes.ts.bak:613:  app.get('/api/notes/:id/events', (req, res) => {
server/routes.ts.bak:630:  app.get('/api/realtime-updates', (req, res) => {
server/routes.ts.bak:2606:  // POST route for note updates (handles TipTap editor saves and prevents cache corruption)
server/routes.ts.bak-202508070225:4:import { registerClient } from "./ai/v3/realtime/sse-manager";
server/routes.ts.bak-202508070225:612:  // SSE endpoint for note events
server/routes.ts.bak-202508070225:613:  app.get('/api/notes/:id/events', (req, res) => {
server/routes.ts.bak-202508070225:630:  app.get('/api/realtime-updates', (req, res) => {
server/routes.ts.bak-202508070225:2606:  // POST route for note updates (handles TipTap editor saves and prevents cache corruption)
server/storage.ts:189:    return [{ name: 'events', icon: 'calendar' }];
server/routes.ts:4:import { registerClient } from "./ai/v3/realtime/sse-manager";
server/routes.ts:612:  // SSE endpoint for note events
server/routes.ts:613:  app.get('/api/notes/:id/events', (req, res) => {
server/routes.ts:630:  app.get('/api/realtime-updates', (req, res) => {
server/routes.ts:2613:  // POST route for note updates (handles TipTap editor saves and prevents cache corruption)

===== real-time hooks (client) =====
client/src/components/activity-feed.tsx.bak-202508070225:7:import { useRealTimeUpdates } from "@/hooks/use-realtime-updates";
client/src/components/activity-feed.tsx:8:import { useRealTimeUpdates } from "@/hooks/use-realtime-updates";
client/src/hooks/useEnhancementSocket.ts:5:export function useEnhancementSocket(noteId?: number) {
client/src/pages/note-detail.tsx.bak:12:import { useEnhancementSocket } from "@/hooks/useEnhancementSocket";
client/src/pages/note-detail.tsx.bak:287:  useEnhancementSocket(note?.id);
client/src/pages/note-detail.tsx.bak-202508070225:12:import { useEnhancementSocket } from "@/hooks/useEnhancementSocket";
client/src/pages/note-detail.tsx.bak-202508070225:287:  useEnhancementSocket(note?.id);
client/src/pages/note-detail.tsx:13:import { useEnhancementSocket } from "@/hooks/useEnhancementSocket";
client/src/pages/note-detail.tsx:312:  useEnhancementSocket(note?.id);
client/src/pages/notes.tsx:13:import { useRealTimeUpdates } from "@/hooks/use-realtime-updates";
--- client/src/hooks/useEnhancementSocket.ts
     1	import { useEffect } from 'react';
     2	import { useQueryClient } from '@tanstack/react-query';
     3	import { queryKeys } from '@/utils/queryKeys';
     4	
     5	export function useEnhancementSocket(noteId?: number) {
     6	  const qc = useQueryClient();
     7	  
     8	  useEffect(() => {
     9	    if (!noteId) return;
    10	    
    11	    // Connect to the correct SSE endpoint for this specific note
    12	    const es = new EventSource(`/api/notes/${noteId}/events`);
    13	    
    14	    es.onopen = () => {
    15	      console.log('[SSE] Connected to note', noteId);
    16	    };
    17	    
    18	    es.onmessage = (e) => {
    19	      try {
    20	        const msg = JSON.parse(e.data);
    21	        
    22	        // Handle enhancement complete events
    23	        if (msg.type === 'enhancement_complete') {
    24	          console.log('[SSE] Enhancement complete for note', noteId);
    25	          
    26	          // Invalidate queries to refresh the UI
    27	          qc.invalidateQueries({ queryKey: queryKeys.notes.detail(noteId) });
    28	          qc.invalidateQueries({ queryKey: queryKeys.notes.all });
    29	        }
    30	      } catch (err) {
    31	        console.error('[SSE] Parse error:', err);
    32	      }
    33	    };
    34	    
    35	    es.onerror = (error) => {
    36	      console.error('[SSE] Connection error, closing:', error);
    37	      es.close();
    38	    };
    39	    
    40	    return () => {
    41	      console.log('[SSE] Closing connection for note', noteId);
    42	      es.close();
    43	    };
    44	  }, [noteId, qc]);
    45	}

===== object render guards (safeText) =====

===== TypeScript errors (no emit) =====
client/src/components/NoteDetailSimple-broken.tsx(41,21): error TS2339: Property 'original' does not exist on type 'ParsedRC'.
client/src/components/NoteDetailSimple-broken.tsx(43,24): error TS2339: Property 'perspective' does not exist on type 'ParsedRC'.
client/src/components/inline-voice-recorder.tsx(88,66): error TS2345: Argument of type '{ content: string; mode: "voice"; audioBlob: Blob; audioUrl: string; isProcessing: boolean; isOffline: boolean; recordingDuration: number; createdAt: string; version: number; aiGeneratedTitle: null; ... 26 more ...; todos: never[]; }' is not assignable to parameter of type 'Omit<NoteWithTodos, "id">'.
  Types of property 'createdAt' are incompatible.
    Type 'string' is not assignable to type 'Date'.
client/src/components/ios-voice-recorder.tsx(48,66): error TS2345: Argument of type '{ content: string; mode: string; audioBlob: Blob; audioUrl: string; isProcessing: boolean; isOffline: boolean; recordingDuration: number; createdAt: string; }' is not assignable to parameter of type 'Omit<NoteWithTodos, "id">'.
  Type '{ content: string; mode: string; audioBlob: Blob; audioUrl: string; isProcessing: boolean; isOffline: boolean; recordingDuration: number; createdAt: string; }' is missing the following properties from type 'Omit<NoteWithTodos, "id">': aiGeneratedTitle, userId, isShared, shareId, and 25 more.
client/src/components/settings-modal.tsx(4,26): error TS2307: Cannot find module './ai-comparison' or its corresponding type declarations.
client/src/components/settings-modal.tsx(44,13): error TS2322: Type '{ activeTab: "collections" | "todos" | "activity"; onTabChange: (tab: any) => void; onNewNote: () => void; onSettings: () => void; onCloseCapture: (() => void) | undefined; hideAddButton: boolean; }' is not assignable to type 'IntrinsicAttributes & BottomNavigationProps'.
  Property 'activeTab' does not exist on type 'IntrinsicAttributes & BottomNavigationProps'.
client/src/components/settings-modal.tsx(45,27): error TS7006: Parameter 'tab' implicitly has an 'any' type.
client/src/components/settings-modal.tsx(204,11): error TS2322: Type '{ activeTab: "collections" | "todos" | "activity"; onTabChange: (tab: "collections" | "todos" | "activity") => void; onNewNote: () => void; onSettings: () => void; onCloseCapture: (() => void) | undefined; hideAddButton: boolean; }' is not assignable to type 'IntrinsicAttributes & BottomNavigationProps'.
  Property 'activeTab' does not exist on type 'IntrinsicAttributes & BottomNavigationProps'.
client/src/components/todos-view.tsx(299,53): error TS2339: Property 'description' does not exist on type '{ id: number; title: string; createdAt: Date; noteId: number; completed: boolean | null; pinned: boolean | null; archived: boolean | null; priority: string | null; itemType: string | null; ... 12 more ...; recurrenceRule: string | null; }'.
client/src/components/todos-view.tsx(346,45): error TS2339: Property 'description' does not exist on type '{ id: number; title: string; createdAt: Date; noteId: number; completed: boolean | null; pinned: boolean | null; archived: boolean | null; priority: string | null; itemType: string | null; ... 12 more ...; recurrenceRule: string | null; }'.
client/src/components/voice-modal.tsx(122,25): error TS2345: Argument of type '"paused"' is not assignable to parameter of type 'SetStateAction<"ready" | "recording" | "stopped" | "processing">'.
client/src/components/voice-modal.tsx(130,9): error TS2367: This comparison appears to be unintentional because the types '"ready" | "recording" | "stopped" | "processing"' and '"paused"' have no overlap.
client/src/hooks/useCreateNote.ts(5,35): error TS2345: Argument of type '{ method: string; body: string; headers: { 'Content-Type': string; }; }' is not assignable to parameter of type 'string'.
client/src/hooks/useNoteStream.ts(14,59): error TS1361: 'Step' cannot be used as a value because it was imported using 'import type'.
client/src/hooks/useNoteStream.ts(14,64): error TS2554: Expected 2 arguments, but got 1.
client/src/pages/note-detail-new.tsx(6,30): error TS2307: Cannot find module '@/components/MediaDisplay' or its corresponding type declarations.
client/src/pages/remind.tsx(8,29): error TS2307: Cannot find module '@/components/simple-text-input' or its corresponding type declarations.
client/src/store/indexeddb.ts(11,3): error TS2411: Property 'todos' of type '{ key: number; value: { id: number; title: string; createdAt: Date; noteId: number; completed: boolean | null; pinned: boolean | null; archived: boolean | null; priority: string | null; ... 13 more ...; recurrenceRule: string | null; }; indexes: { ...; }; }' is not assignable to 'string' index type 'DBSchemaValue'.
client/src/store/offline-store.ts(286,10): error TS2339: Property 'isOffline' does not exist on type 'NoteWithTodos'.
client/src/store/offline-store.ts(286,53): error TS2339: Property 'audioBlob' does not exist on type 'NoteWithTodos'.
client/src/store/offline-store.ts(293,37): error TS2339: Property 'audioBlob' does not exist on type 'NoteWithTodos'.
client/src/store/offline-store.ts(294,40): error TS2339: Property 'recordingDuration' does not exist on type 'NoteWithTodos'.
client/src/store/offline-store.ts(313,11): error TS2353: Object literal may only specify known properties, and 'isOffline' does not exist in type 'Partial<NoteWithTodos>'.
client/src/store/offline-store.ts(375,15): error TS2304: Cannot find name 'processOfflineVoiceNotes'.
client/src/utils/parseRichContext.ts(54,5): error TS2322: Type '{}' is not assignable to type 'string'.
server/ai/mira-superintelligence-types.ts(11,8): error TS1192: Module '"/home/runner/workspace/node_modules/chrono-node/dist/esm/index"' has no default export.
server/ai/mira-superintelligence-types.ts(201,3): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
server/ai/mira-superintelligence-types.ts(202,5): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
server/ai/mira-superintelligence-types.ts(202,38): error TS2304: Cannot find name 'expect'.
server/ai/mira-superintelligence-types.ts(203,5): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
server/ai/mira-superintelligence-types.ts(204,39): error TS2304: Cannot find name 'expect'.
server/ai/persist-side-effects.ts(7,30): error TS2554: Expected 0 arguments, but got 1.
server/ai/persist-side-effects.ts(12,34): error TS2554: Expected 0 arguments, but got 1.
server/ai/persist-side-effects.ts(24,34): error TS2554: Expected 0 arguments, but got 1.
server/ai/v3/enhance/queue-worker.ts(177,32): error TS2551: Property 'tasks' does not exist on type 'ReasoningResponse'. Did you mean 'task'?
server/ai/v3/notifications/channel-push.ts(1,21): error TS7016: Could not find a declaration file for module 'web-push'. '/home/runner/workspace/node_modules/web-push/src/index.js' implicitly has an 'any' type.
  Try `npm i --save-dev @types/web-push` if it exists or add a new declaration (.d.ts) file containing `declare module 'web-push';`
server/ai/v3/queue-worker.ts(48,17): error TS2339: Property 'intent' does not exist on type 'MiraResponseMeta'.
server/ai/v3/queue-worker.ts(69,16): error TS2339: Property 'broadcast' does not exist on type 'SSEManager'.
server/ai/v3/reasoning/reasoning-engine.ts(184,45): error TS2339: Property 'title' does not exist on type 'ExtractedTask'.
server/ai/v3/reasoning/reasoning-engine.ts(199,30): error TS2339: Property 'priority' does not exist on type 'ExtractedTask'.
server/ai/v3/reasoning/reasoning-engine.ts(207,49): error TS2339: Property 'title' does not exist on type 'ExtractedTask'.
server/ai/v3/scheduler/scheduler.ts(71,22): error TS2774: This condition will always return true since this function is always defined. Did you mean to call it instead?
server/brain/conciergeBrain.ts(77,54): error TS2339: Property 'summary' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(77,72): error TS2339: Property 'assistantAddendum' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(78,33): error TS2339: Property 'title' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(84,55): error TS2339: Property 'title' does not exist on type 'never'.
server/brain/conciergeBrain.ts(85,51): error TS2339: Property 'priority' does not exist on type 'never'.
server/brain/conciergeBrain.ts(93,30): error TS2339: Property 'smartActions' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(94,33): error TS2339: Property 'smartActions' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(101,16): error TS2339: Property 'enrichments' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(101,38): error TS2339: Property 'enrichments' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(102,32): error TS2339: Property 'enrichments' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(104,27): error TS2322: Type '{ name: string; price: string; url: string; rating?: string | undefined; }[]' is not assignable to type 'never[]'.
  Type '{ name: string; price: string; url: string; rating?: string | undefined; }' is not assignable to type 'never'.
server/brain/conciergeBrain.ts(113,46): error TS2339: Property 'urgency' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(114,61): error TS2339: Property 'complexity' does not exist on type 'AIAnalysisResult'.
server/brain/conciergeBrain.ts(118,33): error TS2339: Property 'assistantAddendum' does not exist on type 'AIAnalysisResult'.
server/brain/miraAIProcessing.ts(440,7): error TS2353: Object literal may only specify known properties, and 'richContext' does not exist in type 'MiraAIResult'.
server/init-collections.ts(21,16): error TS2339: Property 'name' does not exist on type 'never'.
server/init-collections.ts(25,40): error TS2554: Expected 0 arguments, but got 1.
server/init-db.ts(10,38): error TS2554: Expected 0 arguments, but got 1.
server/init-db.ts(16,38): error TS2554: Expected 0 arguments, but got 1.
server/init-db.ts(22,38): error TS2554: Expected 0 arguments, but got 1.
server/intelligence-v2/collections-extractor.ts(1,10): error TS2305: Module '"../storage.js"' has no exported member 'db'.
server/intelligence-v2/intelligence-router-fixed.ts(106,28): error TS2554: Expected 2 arguments, but got 1.
server/intelligence-v2/intelligence-router-fixed.ts(107,31): error TS2554: Expected 2 arguments, but got 1.
server/intelligence-v2/intelligence-router-fixed.ts(121,38): error TS2551: Property 'getAllNotes' does not exist on type '{ pool: Pool; createNote: (noteData: any) => Promise<any>; createTodo: () => Promise<{}>; createReminder: () => Promise<{}>; getCollections: () => Promise<never[]>; ... 9 more ...; deleteNote(id: number): Promise<...>; }'. Did you mean 'getNotes'?
server/intelligence-v2/intelligence-router-fixed.ts(237,59): error TS2554: Expected 4 arguments, but got 3.
server/intelligence-v2/intelligence-router-fixed.ts(281,9): error TS2322: Type 'Relationship[]' is not assignable to type '{ type: string; target: string; strength: number; context: string; }[]'.
  Property 'target' is missing in type 'Relationship' but required in type '{ type: string; target: string; strength: number; context: string; }'.
server/intelligence-v2/intelligence-router-fixed.ts(396,5): error TS2322: Type '{ name: Entity; type: string; details: undefined; }[]' is not assignable to type 'Entity[]'.
  Type '{ name: Entity; type: string; details: undefined; }' is not assignable to type 'Entity'.
    Types of property 'name' are incompatible.
      Type 'Entity' is not assignable to type 'string'.
server/intelligence-v2/intelligence-router-fixed.ts(417,29): error TS2339: Property 'toLowerCase' does not exist on type 'Entity'.
server/intelligence-v2/intent-vector-classifier.ts(63,5): error TS2322: Type '{ primaryActions: ActionLabel[]; domainContexts: string[]; temporalClass: string; collaborationScope: string; affectTone?: string | undefined; }' is not assignable to type 'IntentVector'.
  Types of property 'temporalClass' are incompatible.
    Type 'string' is not assignable to type '"immediate" | "short-term" | "long-term" | "evergreen"'.
server/notification-system.ts(132,39): error TS2802: Type 'MapIterator<[number, NotificationSchedule[]]>' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher.
server/notification-system.ts(133,49): error TS7006: Parameter 'schedule' implicitly has an 'any' type.
server/notification-system.ts(141,53): error TS7006: Parameter 'schedule' implicitly has an 'any' type.
server/notification-system.ts(267,29): error TS2802: Type 'MapIterator<NotificationSchedule[]>' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher.
server/replit-storage.ts(16,40): error TS2339: Property 'downloadUrlFor' does not exist on type 'Client'.
server/replit-storage.ts(29,7): error TS2322: Type 'Result<string, RequestError, unknown>' is not assignable to type 'string'.
  Type 'ErrResult<RequestError, unknown>' is not assignable to type 'string'.
server/replit-storage.ts(39,22): error TS2339: Property 'map' does not exist on type 'Result<StorageObject[], RequestError, unknown>'.
  Property 'map' does not exist on type 'ErrResult<RequestError, unknown>'.
server/replit-storage.ts(39,26): error TS7006: Parameter 'obj' implicitly has an 'any' type.
server/replitAuth.ts(60,17): error TS2339: Property 'upsertUser' does not exist on type '{ pool: Pool; createNote: (noteData: any) => Promise<any>; createTodo: () => Promise<{}>; createReminder: () => Promise<{}>; getCollections: () => Promise<never[]>; ... 9 more ...; deleteNote(id: number): Promise<...>; }'.
server/reprocess-notes.ts(27,20): error TS2339: Property 'name' does not exist on type 'never'.
server/reprocess-notes.ts(30,50): error TS2339: Property 'id' does not exist on type 'never'.
server/reprocess-notes.ts(32,66): error TS2554: Expected 0 arguments, but got 1.
server/reprocess-notes.ts(33,42): error TS2339: Property 'id' does not exist on type '{}'.
server/reprocess-notes.ts(38,47): error TS2353: Object literal may only specify known properties, and 'collectionId' does not exist in type '{ content?: string | null | undefined; doc_json?: any; }'.
server/routes.ts(11,23): error TS2305: Module '"./brain/miraAIProcessing"' has no exported member 'processWithIntelligenceV2'.
server/routes.ts(225,21): error TS2339: Property 'updateUser' does not exist on type '{ pool: Pool; createNote: (noteData: any) => Promise<any>; createTodo: () => Promise<{}>; createReminder: () => Promise<{}>; getCollections: () => Promise<never[]>; ... 9 more ...; deleteNote(id: number): Promise<...>; }'.
server/routes.ts(312,21): error TS2339: Property 'updateUser' does not exist on type '{ pool: Pool; createNote: (noteData: any) => Promise<any>; createTodo: () => Promise<{}>; createReminder: () => Promise<{}>; getCollections: () => Promise<never[]>; ... 9 more ...; deleteNote(id: number): Promise<...>; }'.
server/routes.ts(334,34): error TS2551: Property 'getUser' does not exist on type '{ pool: Pool; createNote: (noteData: any) => Promise<any>; createTodo: () => Promise<{}>; createReminder: () => Promise<{}>; getCollections: () => Promise<never[]>; ... 9 more ...; deleteNote(id: number): Promise<...>; }'. Did you mean 'getUsers'?
server/routes.ts(350,47): error TS2353: Object literal may only specify known properties, and 'ai_suggestion' does not exist in type '{ content?: string | null | undefined; doc_json?: any; }'.
server/routes.ts(406,27): error TS7053: Element implicitly has an 'any' type because expression of type 'any' can't be used to index type '{ readonly clarify: 3000; readonly evolve: 6000; readonly shopping: 8000; readonly research: 8000; }'.
server/routes.ts(455,26): error TS2749: 'MiraResponseSchema' refers to a value, but is being used as a type here. Did you mean 'typeof MiraResponseSchema'?
server/routes.ts(460,39): error TS2749: 'MiraResponseSchema' refers to a value, but is being used as a type here. Did you mean 'typeof MiraResponseSchema'?
server/routes.ts(488,9): error TS2353: Object literal may only specify known properties, and 'mira_response' does not exist in type '{ content?: string | null | undefined; doc_json?: any; }'.
server/routes.ts(590,35): error TS2551: Property 'getItemsByNoteId' does not exist on type '{ pool: Pool; createNote: (noteData: any) => Promise<any>; createTodo: () => Promise<{}>; createReminder: () => Promise<{}>; getCollections: () => Promise<never[]>; ... 9 more ...; deleteNote(id: number): Promise<...>; }'. Did you mean 'getTodosByNoteId'?
server/routes.ts(675,9): error TS2353: Object literal may only specify known properties, and 'is_processing' does not exist in type '{ content?: string | null | undefined; doc_json?: any; }'.
server/routes.ts(683,41): error TS2551: Property 'getUser' does not exist on type '{ pool: Pool; createNote: (noteData: any) => Promise<any>; createTodo: () => Promise<{}>; createReminder: () => Promise<{}>; getCollections: () => Promise<never[]>; ... 9 more ...; deleteNote(id: number): Promise<...>; }'. Did you mean 'getUsers'?
server/routes.ts(716,13): error TS2353: Object literal may only specify known properties, and 'ai_generated_title' does not exist in type '{ content?: string | null | undefined; doc_json?: any; }'.
server/routes.ts(729,13): error TS2353: Object literal may only specify known properties, and 'is_processing' does not exist in type '{ content?: string | null | undefined; doc_json?: any; }'.
server/routes.ts(776,50): error TS18046: 'queueError' is of type 'unknown'.
server/routes.ts(797,43): error TS2551: Property 'getUser' does not exist on type '{ pool: Pool; createNote: (noteData: any) => Promise<any>; createTodo: () => Promise<{}>; createReminder: () => Promise<{}>; getCollections: () => Promise<never[]>; ... 9 more ...; deleteNote(id: number): Promise<...>; }'. Did you mean 'getUsers'?
server/routes.ts(831,56): error TS2304: Cannot find name 'makeTitle'.
server/routes.ts(878,50): error TS18046: 'updateError' is of type 'unknown'.
server/routes.ts(882,17): error TS2353: Object literal may only specify known properties, and 'ai_enhanced' does not exist in type '{ content?: string | null | undefined; doc_json?: any; }'.
server/routes.ts(948,60): error TS2554: Expected 0 arguments, but got 1.
…(truncated if long)…

===== runtime ports & preview reality =====
netstat (listening):

===== API smoke (read-only) =====
GET /api/notes (first 1KB)
[{"id":644,"content":"Comparison of Quest Chips and Wilde Chips:\n\nQuest Chips:\n- Known for high protein and low carbohydrate content.\n- Popular among those following ketogenic or low-carb diets.\n- Often made with ingredients like protein isolates and fiber.\n\nWilde Chips:\n- Made from chicken breast, offering a different protein source.\n- Generally higher in protein compared to traditional potato chips.\n- Aimed at those seeking a more natural ingredient list.\n\nConsiderations:\n- Taste preferences: Quest may have a more processed taste due to protein isolates.\n- Nutritional goals: Wilde offers more natural ingredients, but Quest provides a low-carb option.\n\nNext Steps:\n- Decide based on dietary preferences and taste priorities.","createdAt":"2025-08-07T22:01:05.519Z","todos":[],"miraResponse":"{\"meta\": {\"v\": 3, \"model\": \"gpt-4o\", \"intent\": \"GENERAL\", \"timestamp\": \"2025-08-07T22:01:10.954Z\", \"confidence\": 0.8, \"inputTokens\": 316, \"totalTokens\": 513, \"outputTokens\": 197, \"r
GET /api/notes/433 (first 1KB)
{"id":433,"content":"Audio note (transcription unavailable)","createdAt":"2025-06-20T20:23:21.946Z","todos":[],"miraResponse":null,"aiGeneratedTitle":null,"tokenUsage":null,"isProcessing":false,"mode":"voice","userId":null,"isShared":false,"shareId":null,"privacyLevel":"private","audioUrl":"/uploads/8b3bafeb-c80f-4041-9c0f-7ae22adc6c13.webm","mediaUrl":null,"transcription":"Audio note (transcription unavailable)","imageData":null,"aiEnhanced":true,"aiSuggestion":"Set Reminder: reminder","aiContext":"Note processed","richContext":"{\"entities\":[],\"suggestedLinks\":[],\"nextSteps\":[],\"microQuestions\":[]}","richContextBackup":null,"migratedAt":null,"miraResponseCreatedAt":null,"collectionId":null,"vectorDense":null,"vectorSparse":null,"intentVector":null,"version":1,"originalContent":null,"lastUserEdit":"2025-06-20T20:23:21.946Z","protectedContent":null,"processingPath":null,"classificationScores":null,"docJson":null}


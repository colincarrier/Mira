# Mira AI Memory Assistant - Complete Codebase Export

## Project Statistics
- **Total Source Files**: 14347
- **Total Lines of Code**: 157295
- **Export Date**: Tue Jun 24 11:32:08 PM UTC 2025
- **Architecture**: Full-stack TypeScript PWA with AI processing

## Technology Stack
- **Frontend**: React 18 + TypeScript + Tailwind CSS + PWA
- **Backend**: Express.js + Node.js
- **Database**: PostgreSQL with Drizzle ORM  
- **AI**: OpenAI GPT-4o with Intelligence-V2 architecture
- **Build**: Vite with Replit deployment
- **Storage**: Object Storage + File System

## Core Architecture Components

### 1. AI Processing Pipeline
- Intelligence-V2 Router with vector search
- Multi-modal input processing (text, voice, image)
- Recursive reasoning engine
- Intent classification system
- Advanced prompt engineering

### 2. Data Management
- PostgreSQL with comprehensive schema
- Drizzle ORM with type safety
- Data protection and versioning
- Vector storage for semantic search

### 3. Frontend Architecture  
- React 18 with TypeScript
- Progressive Web App capabilities
- Real-time data synchronization
- Multi-modal input interfaces

### 4. Backend Services
- Express.js API server
- File storage management
- Notification system
- Authentication and security

## File Structure Overview
## BACKEND SOURCE FILES

### server/ai/persist-side-effects.ts
```typescript
import { storage } from '../storage';

export async function persistSideEffects(parsed: any, noteId: number) {
  // Todos
  for (const t of parsed.todos || []) {
    await storage.createTodo({ 
      title: t.title, 
      priority: t.priority, 
      noteId 
    });
  }
  
  // Reminder
  if (parsed.reminder?.timeISO) {
    await storage.createTodo({
      title: parsed.title,
      noteId,
      priority: 'high',
      isActiveReminder: true,
      timeDue: new Date(parsed.reminder.timeISO)
    });
  }
  
  // Bullet‑to‑collection (sample)
  if (parsed.aiBody && parsed.aiBody.startsWith('•')) {
    const bullets = parsed.aiBody.split('\n').map((b: string) => b.replace(/^•\s*/, ''));
    
    // Find or create Bullets collection
    const collections = await storage.getCollections();
    let bulletsCollection = collections.find(c => c.name === 'Bullets');
    
    if (!bulletsCollection) {
      bulletsCollection = await storage.createCollection({
        name: 'Bullets',
        icon: 'list',
        color: '#6366f1'
      });
    }
    
    for (const text of bullets) {
      if (text.trim()) {
        await storage.createItem({ 
          title: text, 
          type: 'bullet', 
          collectionId: bulletsCollection.id, 
          sourceNoteId: noteId 
        });
      }
    }
  }
}```

### server/ai/presentation-composer.ts
```typescript
export interface RichContext {
  title: string;
  original?: string;
  aiBody?: string;
  perspective?: string;
}

/** Build the four fields shown in the UI */
export function composeRichContext(raw: string, analysis: any): RichContext {
  // Clean raw content - remove any AI instruction artifacts
  let cleanContent = raw.trim()
    .replace(/\[AI Analysis:.*?\]/g, '')
    .replace(/\[AI Context:.*?\]/g, '')
    .replace(/\s+/g, ' ')
    .trim();

  const title = cleanContent.length <= 45 ? cleanContent : cleanContent.slice(0, 42) + '…';
  const original = cleanContent === title ? '' : cleanContent;

  // Generate meaningful AI body from actual analysis
  let aiBody = '';
  if (analysis?.proactiveDelivery?.suggestedActions?.length) {
    const actions = analysis.proactiveDelivery.suggestedActions
      .filter((a: any) => a.action && !a.action.includes('research') && !a.action.includes('investigation'))
      .slice(0, 3)
      .map((a: any) => '• ' + a.action);
    
    if (actions.length > 0) {
      aiBody = actions.join('\n');
    }
  }

  // Generate concise perspective from understanding
  let perspective = '';
  if (analysis?.immediateProcessing?.understanding) {
    const understanding = analysis.immediateProcessing.understanding;
    // Remove bio context and keep only relevant insight
    perspective = understanding
      .replace(/\(.*?\)/g, '') // Remove parenthetical bio context
      .slice(0, 100)
      .trim();
  }

  return { title, original, aiBody, perspective };
}```

### server/ai/prompt-specs.ts
```typescript
export const PROMPT_HEADER = /* md */`
SYSTEM:
You are Mira's Intelligence‑V2 core.
Always reply **ONLY** in this JSON schema:

{
  "title":  <string>,       // ≤45 chars, camel‑case
  "original": <string?>,    // empty if same as title
  "aiBody":  <string?>,     // bullets or paragraph, supports markdown
  "perspective": <string?>, // ≤80 chars explaining reasoning & next prep
  "todos":   <{title:string, priority:"low"|"normal"|"high"}[]>,
  "reminder": <{timeISO:string, leadMins:number}?>
}

Rules:
- No extra keys, no markdown outside values.
- If you have no value, return "" or [].
- Personalise tone & suggestions using USER_BIO block.
`;

export function buildPrompt(userBio: string, note: string) {
  return PROMPT_HEADER + `\nUSER_BIO:\n${userBio}\nNOTE_TEXT:\n${note}`;
}```

### server/ai-taxonomy-engine.ts
```typescript
import Anthropic from '@anthropic-ai/sdk';

// Micro-question patterns for high-frequency input types
export const AI_TAXONOMY_PATTERNS = {
  // Food & Restaurants
  food_decision: {
    triggers: ['restaurant', 'dinner', 'lunch', 'eat', 'food', 'hungry'],
    microQuestions: [
      'What cuisine type are you craving?',
      'What\'s your budget range?',
      'How far are you willing to travel?',
      'Dining alone or with others?',
      'Any dietary restrictions?'
    ],
    followUpActions: [
      'Check restaurant hours and availability',
      'Read recent reviews',
      'Compare menu prices',
      'Check if reservations needed'
    ]
  },

  // Shopping & Purchases
  purchase_decision: {
    triggers: ['buy', 'purchase', 'need', 'shopping', 'get'],
    microQuestions: [
      'What\'s your max budget?',
      'When do you need this by?',
      'Any specific brand preferences?',
      'Where do you prefer to shop?',
      'Is this a replacement or new purchase?'
    ],
    followUpActions: [
      'Compare prices across retailers',
      'Check for current deals or coupons',
      'Read customer reviews',
      'Verify return policy'
    ]
  },

  // Travel Planning
  travel_planning: {
    triggers: ['trip', 'travel', 'vacation', 'visit', 'fly', 'hotel'],
    microQuestions: [
      'What are your travel dates?',
      'What\'s your total budget?',
      'Who\'s traveling with you?',
      'What type of experience do you want?',
      'Any must-see attractions or activities?'
    ],
    followUpActions: [
      'Check flight prices and schedules',
      'Research accommodation options',
      'Look into local transportation',
      'Find popular attractions and activities',
      'Check weather for travel dates'
    ]
  },

  // Learning & Skill Development
  learning_goal: {
    triggers: ['learn', 'study', 'course', 'skill', 'practice', 'improve'],
    microQuestions: [
      'What\'s your current skill level?',
      'How much time can you dedicate daily/weekly?',
      'Do you prefer structured courses or self-directed learning?',
      'What\'s your learning budget?',
      'What\'s your target proficiency timeline?'
    ],
    followUpActions: [
      'Find highly-rated courses or tutorials',
      'Identify practice resources and communities',
      'Create a structured learning schedule',
      'Set measurable milestones'
    ]
  },

  // Health & Fitness
  health_fitness: {
    triggers: ['workout', 'exercise', 'gym', 'health', 'diet', 'weight'],
    microQuestions: [
      'What are your specific health/fitness goals?',
      'What\'s your current activity level?',
      'Any physical limitations or injuries?',
      'How much time can you commit?',
      'Do you prefer home or gym workouts?'
    ],
    followUpActions: [
      'Research appropriate workout programs',
      'Find local fitness facilities or classes',
      'Consider nutrition planning',
      'Track progress methods'
    ]
  },

  // Career & Professional
  career_development: {
    triggers: ['job', 'career', 'work', 'interview', 'resume', 'promotion'],
    microQuestions: [
      'What\'s your current career stage?',
      'What specific role or field interests you?',
      'What\'s your experience level?',
      'Are you looking locally or open to relocation?',
      'What\'s your salary expectation range?'
    ],
    followUpActions: [
      'Research job market trends',
      'Update resume and LinkedIn profile',
      'Identify skill gaps to address',
      'Network with industry professionals'
    ]
  },

  // Home & Living
  home_improvement: {
    triggers: ['home', 'house', 'apartment', 'room', 'decorate', 'furniture'],
    microQuestions: [
      'What\'s your budget for this project?',
      'What\'s the timeline?',
      'DIY or hiring professionals?',
      'What style/aesthetic do you prefer?',
      'Any functional requirements?'
    ],
    followUpActions: [
      'Get quotes from contractors if needed',
      'Research materials and costs',
      'Check local permits if required',
      'Find design inspiration and references'
    ]
  },

  // Entertainment & Events
  entertainment: {
    triggers: ['movie', 'show', 'concert', 'event', 'weekend', 'fun'],
    microQuestions: [
      'What type of entertainment do you enjoy?',
      'What\'s your budget?',
      'Preferred date/time?',
      'Going alone or with others?',
      'Any location preferences?'
    ],
    followUpActions: [
      'Check event schedules and ticket availability',
      'Compare prices across platforms',
      'Read reviews or ratings',
      'Plan transportation and timing'
    ]
  },

  // Financial Planning
  financial_planning: {
    triggers: ['money', 'budget', 'save', 'invest', 'debt', 'loan', 'financial'],
    microQuestions: [
      'What\'s your current financial situation?',
      'What are your financial goals?',
      'What\'s your risk tolerance?',
      'Timeline for achieving goals?',
      'Any existing debts or obligations?'
    ],
    followUpActions: [
      'Research financial products and services',
      'Compare rates and fees',
      'Consider consulting a financial advisor',
      'Create a structured plan with milestones'
    ]
  }
};

export interface TaxonomyAnalysis {
  category: string;
  confidence: number;
  microQuestions: string[];
  suggestedFollowUps: string[];
  contextualInsights: string[];
}

export async function analyzeTaxonomy(content: string): Promise<TaxonomyAnalysis | null> {
  const contentLower = content.toLowerCase();
  
  // Find matching patterns
  const matches = Object.entries(AI_TAXONOMY_PATTERNS).map(([category, pattern]) => {
    const triggerMatches = pattern.triggers.filter(trigger => 
      contentLower.includes(trigger)
    ).length;
    
    const confidence = triggerMatches / pattern.triggers.length;
    
    return {
      category,
      confidence,
      pattern
    };
  }).filter(match => match.confidence > 0);

  if (matches.length === 0) return null;

  // Get the best match
  const bestMatch = matches.sort((a, b) => b.confidence - a.confidence)[0];
  
  if (bestMatch.confidence < 0.2) return null; // Minimum confidence threshold

  return {
    category: bestMatch.category,
    confidence: bestMatch.confidence,
    microQuestions: bestMatch.pattern.microQuestions,
    suggestedFollowUps: bestMatch.pattern.followUpActions,
    contextualInsights: generateContextualInsights(bestMatch.category, content)
  };
}

function generateContextualInsights(category: string, content: string): string[] {
  // AI should generate insights, not hardcoded templates
  return [];
    food_decision: [
      'Consider checking recent reviews for food safety',
      'Peak dining times may require reservations',
      'Many restaurants offer online ordering for pickup'
    ],
    purchase_decision: [
      'Compare prices across at least 3 retailers',
      'Check return policies before purchasing',
      'Look for seasonal sales or discount codes'
    ],
    travel_planning: [
      'Book flights on Tuesday-Thursday for better rates',
      'Check visa requirements well in advance',
      'Consider travel insurance for international trips'
    ],
    learning_goal: [
      'Start with free resources to gauge interest',
      'Join communities for motivation and support',
      'Set small, achievable milestones'
    ],
    health_fitness: [
      'Consult healthcare provider before major changes',
      'Start gradually to avoid injury',
      'Track progress to maintain motivation'
    ],
    career_development: [
      'Update your skills to match current market demands',
      'Network actively in your target industry',
      'Practice interview skills regularly'
    ],
    home_improvement: [
      'Get multiple quotes for major projects',
      'Check local building codes and permits',
      'Consider seasonal timing for outdoor work'
    ],
    entertainment: [
      'Book popular events early for better selection',
      'Check cancellation policies',
      'Consider transportation and parking'
    ],
    financial_planning: [
      'Emergency fund should cover 3-6 months expenses',
      'Diversify investments to reduce risk',
      'Review and adjust plans annually'
    ]
  };

  return insights[category] || [];
}

// Enhanced AI analysis that incorporates taxonomy patterns
export async function enhancedAIAnalysis(content: string, mode: string): Promise<any> {
  const anthropic = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY,
  });

  // First, analyze taxonomy
  const taxonomyAnalysis = await analyzeTaxonomy(content);
  
  let enhancedPrompt = `You are Mira, analyzing this input: "${content}"`;
  
  if (taxonomyAnalysis) {
    enhancedPrompt += `

DETECTED PATTERN: ${taxonomyAnalysis.category} (${Math.round(taxonomyAnalysis.confidence * 100)}% confidence)

MICRO-QUESTIONS TO ADDRESS:
${taxonomyAnalysis.microQuestions.map(q => `- ${q}`).join('\n')}

SUGGESTED FOLLOW-UPS:
${taxonomyAnalysis.suggestedFollowUps.map(f => `- ${f}`).join('\n')}

CONTEXTUAL INSIGHTS:
${taxonomyAnalysis.contextualInsights.map(i => `- ${i}`).join('\n')}

Use this pattern recognition to provide more targeted, specific assistance.`;
  }

  enhancedPrompt += `

Provide intelligent analysis with complexity scoring, task hierarchy for complex projects, and predictive next steps. Focus on authentic research and actionable intelligence.`;

  // Continue with regular AI analysis using the enhanced prompt...
  const response = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 2500,
    system: 'You are Mira, an intelligent personal assistant. Always respond with valid JSON only.',
    messages: [
      {
        role: 'user',
        content: enhancedPrompt
      }
    ]
  });

  const textContent = response.content[0].type === 'text' ? response.content[0].text : '';
  
  try {
    const result = JSON.parse(textContent);
    // Add taxonomy analysis to the result
    if (taxonomyAnalysis) {
      result.taxonomyInsights = taxonomyAnalysis;
    }
    return result;
  } catch (parseError) {
    console.error('Failed to parse enhanced AI response:', parseError);
    return null;
  }
}```

### server/anthropic.ts
```typescript
// ⚠️  CRITICAL: AI PROMPT PROTECTION - DO NOT MODIFY WITHOUT APPROVAL ⚠️
// This file contains Claude AI integration and core prompts.
// See AI_MODIFICATION_RULES.md for modification protocol.

import Anthropic from "@anthropic-ai/sdk";

// the newest Anthropic model is "claude-sonnet-4-20250514" which was released May 14, 2025. Use this by default unless user has already selected claude-3-7-sonnet-20250219
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

export interface AIAnalysisResult {
  enhancedContent?: string;
  suggestion?: string;
  context?: string;

  // Complexity Analysis
  complexityScore: number; // 1-10 scale
  intentType: 'simple-task' | 'complex-project' | 'research-inquiry' | 'personal-reflection' | 'reference-material';
  urgencyLevel: 'low' | 'medium' | 'high' | 'critical';

  // Enhanced Task Structure
  todos: string[];
  taskHierarchy?: {
    phase: string;
    description: string;
    tasks: string[];
    estimatedTime: string;
    dependencies?: string[];
  }[];

  collectionSuggestion?: {
    name: string;
    icon: string;
    color: string;
  };

  // Intelligence Context
  richContext?: {
    recommendedActions: {
      title: string;
      description: string;
      links?: { title: string; url: string }[];
    }[];
    researchResults: {
      title: string;
      description: string;
      rating?: string;
      keyPoints: string[];
      contact?: string;
    }[];
    quickInsights: string[];
  };

  // Predictive Intelligence
  nextSteps?: string[];
  timeToComplete?: string;
  successFactors?: string[];
  potentialObstacles?: string[];

  // Knowledge Connections
  relatedTopics?: string[];
  skillsRequired?: string[];
  resourcesNeeded?: string[];

  // Individual Item Extraction
  extractedItems?: {
    title: string;
    description?: string;
    category: string;
    metadata?: Record<string, any>;
  }[];

  splitNotes?: {
    content: string;
    todos: string[];
    collectionSuggestion?: {
      name: string;
      icon: string;
      color: string;
    };
  }[];
}

export async function analyzeNote(content: string, mode: string): Promise<AIAnalysisResult> {
  try {
    const prompt = `Analyze and enhance: "${content}"

Generate comprehensive analysis with MARKDOWN FORMATTING and CLICKABLE LINKS:

FORMAT REQUIREMENTS:
- Use **bold** for important terms and names
- Use [Link Text](URL) format for all external links
- Include [Amazon](https://amazon.com/s?k=item) links when relevant
- Include [Expert Review](https://techradar.com) links for product content
- Use markdown tables with | separators
- Use ### for section headers
- Use proper bullet points with -

CONTENT STRUCTURE:
1. Enhanced content with proper markdown formatting
2. Comprehensive analysis with sections and subsections
3. Clickable links where appropriate
4. Comparison tables if relevant
5. Use case recommendations

Respond with JSON:
{
  "enhancedContent": "MARKDOWN formatted content with clickable links, headers, tables, and comprehensive analysis. Use proper markdown syntax throughout.",
  "suggestion": "Brief action suggestion",
  "context": "Detailed context analysis",
  "complexityScore": 5,
  "intentType": "simple-task",
  "urgencyLevel": "medium",
  "todos": ["actionable items"],
  "richContext": {
    "recommendedActions": [{"title": "Action", "description": "Details"}],
    "quickInsights": ["insight1", "insight2"]
  }
}`;

    console.log("Claude analysis with enhanced Mira Brain prompt");

    const message = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      system: "You are an expert analysis assistant. Generate comprehensive, well-formatted markdown content with proper links, tables, and structure. Always respond with valid JSON only.",
      max_tokens: 8000,
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    });

    const response = message.content[0];
    if (response.type !== 'text') {
      throw new Error('Unexpected response type from Claude');
    }

    console.log("Claude raw response:", response.text.substring(0, 200) + "...");

    let result;
    try {
      // Clean response if it has markdown formatting
      let cleanResponse = response.text.trim();
      if (cleanResponse.startsWith('```json')) {
        cleanResponse = cleanResponse.replace(/```json\s*/, '').replace(/```\s*$/, '');
      }
      if (cleanResponse.startsWith('```')) {
        cleanResponse = cleanResponse.replace(/```\s*/, '').replace(/```\s*$/, '');
      }

      result = JSON.parse(cleanResponse);
    } catch (parseError) {
      console.error("Error parsing Claude response:", parseError);
      console.log("Raw Claude response that failed to parse:", response.text);

      // Return fallback analysis with proper structure
      return {
        enhancedContent: content,
        suggestion: "Unable to analyze note at this time. Please try again.",
        context: "Analysis failed - fallback response",
        complexityScore: 5,
        intentType: 'personal-reflection',
        urgencyLevel: 'medium',
        todos: [],
        taskHierarchy: undefined,
        collectionSuggestion: undefined,
        richContext: undefined,
        nextSteps: undefined,
        timeToComplete: undefined,
        successFactors: undefined,
        potentialObstacles: undefined,
        relatedTopics: undefined,
        skillsRequired: undefined,
        resourcesNeeded: undefined
      };
    }

    console.log("Claude analysis completed successfully");

    // Clean up suggestion to avoid returning prompt text
    let cleanSuggestion = result.suggestion || "";
    if (cleanSuggestion.includes("You are Mira") || cleanSuggestion.length > 200) {
      cleanSuggestion = "";
    }

    // Return the complete AIAnalysisResult structure
    // NEVER return AI prompt as enhancedContent - preserve original user content
    let cleanEnhancedContent = result.enhancedContent;
    if (cleanEnhancedContent && cleanEnhancedContent.includes("You are Mira")) {
      cleanEnhancedContent = content; // Fallback to original content
    }
    
    return {
      enhancedContent: cleanEnhancedContent || content,
      suggestion: cleanSuggestion,
      context: result.context || "",
      complexityScore: result.complexityScore || 5,
      intentType: result.intentType || 'personal-reflection',
      urgencyLevel: result.urgencyLevel || 'medium',
      todos: Array.isArray(result.todos) ? result.todos : [],
      taskHierarchy: result.taskHierarchy,
      collectionSuggestion: result.collectionSuggestion,
      richContext: result.richContext,
      nextSteps: result.nextSteps,
      timeToComplete: result.timeToComplete,
      successFactors: result.successFactors,
      potentialObstacles: result.potentialObstacles,
      relatedTopics: result.relatedTopics,
      skillsRequired: result.skillsRequired,
      resourcesNeeded: result.resourcesNeeded
    };
  } catch (error) {
    console.error("Claude analysis failed:", error);
    throw new Error(`Claude analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function analyzeImageContent(imageBase64: string, content: string): Promise<AIAnalysisResult> {
  try {
    const imageAnalysisPrompt = `You've received an image from the user. Your job is to fully decode and surface valuable insight from it, as if you're a visual detective and shopping concierge combined.

1. Identify any objects, logos, text, products, or landmarks in the image.
2. Use OCR to extract any readable text or symbols.
3. Interpret what the item is — include category, potential use, or style cues.
4. Run a web search to locate:
    - Brand or manufacturer
    - Product name or collection
    - Purchase links (Google, Amazon, Grailed, brand sites, etc.)
    - Price or resale value
    - Comparable alternatives
5. If it's a location, return links to Google Maps, Yelp, or the official site.
6. Format your response as a concise but rich recommendation card with embedded links.

NEVER reply with "I can't tell." Always extract partial clues and make a best effort guess, followed by web-based confirmation.

Generate a meaningful, specific title (3-5 words max) about what you actually see in the image. Examples:
- "Nike Air Force 1s"
- "Starbucks Menu Board"
- "iPhone 15 Pro Max"
- "Toyota Camry 2024"

Return JSON with this exact structure:
{
  "enhancedContent": "Brief specific title of what's in the image",
  "suggestion": "Detailed analysis and recommendations",
  "context": "Category and usage context",
  "complexityScore": 5,
  "intentType": "reference-material",
  "urgencyLevel": "low",
  "todos": [],
  "richContext": {
    "recommendedActions": [
      {
        "title": "Shop Similar Items",
        "description": "Find where to buy this product",
        "links": [{"title": "Brand Website", "url": "https://example.com"}]
      }
    ],
    "researchResults": [
      {
        "title": "Product Details",
        "description": "Specifications and pricing",
        "keyPoints": ["Price range", "Availability", "Reviews"]
      }
    ],
    "quickInsights": ["Key facts about the item"]
  }
}`;

    const message = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      system: "You are Mira's visual analysis system. Identify objects, brands, and products in images, then provide shopping links and detailed information. Always return valid JSON.",
      max_tokens: 4000,
      messages: [
        {
          role: "user",
          content: [
            {
              type: "text",
              text: imageAnalysisPrompt
            },
            {
              type: "image",
              source: {
                type: "base64",
                media_type: "image/jpeg",
                data: imageBase64
              }
            }
          ]
        }
      ]
    });

    const response = message.content[0];
    if (response.type !== 'text') {
      throw new Error('Unexpected response type from Claude');
    }

    let result;
    try {
      let cleanResponse = response.text.trim();
      if (cleanResponse.startsWith('```json')) {
        cleanResponse = cleanResponse.replace(/```json\s*/, '').replace(/```\s*$/, '');
      }
      if (cleanResponse.startsWith('```')) {
        cleanResponse = cleanResponse.replace(/```\s*/, '').replace(/```\s*$/, '');
      }

      result = JSON.parse(cleanResponse);
    } catch (parseError) {
      console.error("Error parsing Claude image response:", parseError);
      
      return {
        enhancedContent: "Visual Analysis Complete",
        suggestion: "Image processed but detailed analysis unavailable",
        context: "Image content review",
        complexityScore: 5,
        intentType: 'reference-material',
        urgencyLevel: 'low',
        todos: [],
        richContext: {
          recommendedActions: [],
          researchResults: [],
          quickInsights: ["Image analysis in progress"]
        }
      };
    }

    return result;
  } catch (error) {
    console.error('Error analyzing image with Claude:', error);
    
    return {
      enhancedContent: "Image Review",
      suggestion: "Visual analysis temporarily unavailable",
      context: "Image processing",
      complexityScore: 5,
      intentType: 'reference-material',
      urgencyLevel: 'low',
      todos: [],
      richContext: {
        recommendedActions: [],
        researchResults: [],
        quickInsights: ["Analysis pending"]
      }
    };
  }
}

export async function transcribeAudio(audioBuffer: Buffer): Promise<string> {
  try {
    // Note: Anthropic doesn't have audio transcription, this would use OpenAI
    throw new Error("Audio transcription not supported by Anthropic");
  } catch (error) {
    console.error("Error transcribing audio:", error);
    throw new Error("Failed to transcribe audio");
  }
}```

### server/brain/classifiers/commerceClassifier.ts
```typescript
/**
 * Commerce Classifier - 1ms keyword scoring
 * Fast classification to route between commerce and memory paths
 */

export interface ClassificationResult {
  isCommerce: boolean;
  confidence: number;
  scores: Record<string, number>;
  primaryIntent: string;
}

// Commerce keywords weighted by specificity
const COMMERCE_KEYWORDS = {
  // High confidence indicators (0.8-1.0)
  buy: 0.9,
  purchase: 0.9,
  order: 0.8,
  shopping: 0.8,
  store: 0.7,
  price: 0.8,
  cost: 0.7,
  sale: 0.8,
  discount: 0.7,
  deals: 0.7,
  
  // Medium confidence indicators (0.5-0.7)
  best: 0.6,
  cheap: 0.6,
  affordable: 0.6,
  review: 0.5,
  compare: 0.6,
  recommendation: 0.5,
  
  // Product categories (0.4-0.6)
  tv: 0.5,
  laptop: 0.5,
  phone: 0.5,
  headphones: 0.4,
  shoes: 0.4,
  clothes: 0.4,
  furniture: 0.4,
  appliance: 0.5,
  
  // Retail context (0.3-0.5)
  amazon: 0.4,
  target: 0.4,
  walmart: 0.4,
  bestbuy: 0.4,
  online: 0.3,
  delivery: 0.3,
  shipping: 0.3
};

// Memory/personal keywords (negative commerce signals)
const MEMORY_KEYWORDS = {
  remember: -0.5,
  remind: -0.6,
  note: -0.3,
  memo: -0.4,
  appointment: -0.5,
  meeting: -0.5,
  call: -0.4,
  email: -0.3,
  todo: -0.5,
  task: -0.4,
  later: -0.3,
  tomorrow: -0.4,
  next: -0.3
};

/**
 * Fast commerce classification using keyword scoring
 */
export function commerceClassifier(content: string): ClassificationResult {
  const contentLower = content.toLowerCase();
  const words = contentLower.split(/\s+/);
  
  let commerceScore = 0;
  let memoryScore = 0;
  let totalMatches = 0;
  
  const scores: Record<string, number> = {};
  
  // Score commerce keywords
  for (const [keyword, weight] of Object.entries(COMMERCE_KEYWORDS)) {
    if (contentLower.includes(keyword)) {
      commerceScore += weight;
      totalMatches++;
      scores[`commerce_${keyword}`] = weight;
    }
  }
  
  // Score memory keywords (negative for commerce)
  for (const [keyword, weight] of Object.entries(MEMORY_KEYWORDS)) {
    if (contentLower.includes(keyword)) {
      memoryScore += Math.abs(weight);
      commerceScore += weight; // Subtract from commerce score
      scores[`memory_${keyword}`] = weight;
    }
  }
  
  // Boost score for price patterns ($X, €X, £X)
  const pricePattern = /[\$€£¥]\s*[\d,]+/;
  if (pricePattern.test(content)) {
    commerceScore += 0.7;
    scores['price_pattern'] = 0.7;
  }
  
  // Boost for model numbers (common in product searches)
  const modelPattern = /\b\w+\d+\w*\b/g;
  const modelMatches = content.match(modelPattern);
  if (modelMatches && modelMatches.length > 0) {
    commerceScore += 0.4;
    scores['model_pattern'] = 0.4;
  }
  
  // Boost for comparison language
  if (/\b(vs|versus|compared? to|better than)\b/.test(contentLower)) {
    commerceScore += 0.5;
    scores['comparison_language'] = 0.5;
  }
  
  // Normalize confidence score
  const maxPossibleScore = Math.max(commerceScore + memoryScore, 1);
  const confidence = Math.min(Math.max(commerceScore / maxPossibleScore, 0), 1);
  
  // Determine primary intent
  let primaryIntent = 'personal-reflection';
  if (commerceScore > 0.6) {
    primaryIntent = 'product-query';
  } else if (memoryScore > commerceScore) {
    primaryIntent = 'reminder';
  } else if (totalMatches > 0) {
    primaryIntent = 'simple-task';
  }
  
  return {
    isCommerce: commerceScore > memoryScore && confidence > 0.3,
    confidence,
    scores: {
      commerce: commerceScore,
      memory: memoryScore,
      ...scores
    },
    primaryIntent
  };
}```

### server/brain/conciergeBrain.ts
```typescript
/**
 * Concierge Brain - Commerce/Product Enrichment Path
 * Handles product queries, shopping research, and commercial intelligence
 */

import { MiraAIInput, MiraAIResult } from './miraAIProcessing';
import { ClassificationResult } from './classifiers/commerceClassifier';

export async function conciergeBrain(
  input: MiraAIInput, 
  classification: ClassificationResult
): Promise<MiraAIResult> {
  
  // Import OpenAI for product analysis
  const openaiModule = await import('../openai');
  
  // Create commerce-focused prompt for comprehensive product research
  const commercePrompt = `
SYSTEM: You are an expert product research assistant. Analyze this query and provide comprehensive, detailed product recommendations with specific models, current pricing, and actionable insights - similar to what ChatGPT would provide.

USER_QUERY: "${input.content}"

INSTRUCTIONS:
1. Identify the specific product category and user requirements
2. Research current top-rated models (June 2025) with specific names and model numbers
3. Provide detailed comparisons including pros/cons, pricing, and key features
4. Include expert review insights and ratings
5. Suggest specific shopping actions with direct links
6. Organize by priority: premium, value, budget options
7. Be comprehensive and detailed - provide dense, helpful information

REQUIRED_JSON_OUTPUT:
{
  "title": "string (3-5 words, product-focused headline)",
  "summary": "string (comprehensive product analysis with specific models, pricing, comparisons, and expert insights - minimum 200 words)",
  "intent": "product-query",
  "urgency": "medium",
  "complexity": 7,
  "todos": [
    {"title": "Research specific models mentioned", "priority": "medium"},
    {"title": "Compare prices across retailers", "priority": "medium"},
    {"title": "Read expert reviews", "priority": "low"}
  ],
  "smartActions": [
    {"label": "Search Amazon", "action": "openLink", "url": "https://amazon.com/s?k=PRODUCT_QUERY"},
    {"label": "Compare Reviews", "action": "openLink", "url": "https://www.google.com/search?q=PRODUCT_QUERY+reviews+2025"},
    {"label": "Price Comparison", "action": "openLink", "url": "https://www.google.com/search?q=PRODUCT_QUERY+price+comparison"}
  ],
  "assistantAddendum": "string (detailed product breakdown with specific recommendations, model comparisons, pricing insights, and shopping guidance - minimum 150 words)",
  "enrichments": {
    "products": [
      {"name": "Premium Option - Specific Model Name", "price": "$XXX-XXX range", "url": "shopping link", "rating": "4.5/5 stars", "keyFeatures": "list key features"},
      {"name": "Value Pick - Specific Model Name", "price": "$XXX-XXX range", "url": "shopping link", "rating": "4.3/5 stars", "keyFeatures": "list key features"},
      {"name": "Budget Choice - Specific Model Name", "price": "$XXX-XXX range", "url": "shopping link", "rating": "4.0/5 stars", "keyFeatures": "list key features"}
    ]
  }
}

QUALITY REQUIREMENTS:
- Summary must be detailed and comprehensive (200+ words)
- Include specific product model names and numbers
- Provide current pricing estimates
- Mention key features and comparisons
- Reference expert reviews when possible
- Be as detailed and helpful as ChatGPT would be

OUTPUT ONLY JSON:
`;

  try {
    // Process through OpenAI for product intelligence
    const result = await openaiModule.analyzeWithOpenAI(commercePrompt, 'enhanced');
    
    console.log('Commerce brain - OpenAI result:', JSON.stringify(result, null, 2));
    
    // Extract structured commerce response - check for detailed analysis in various fields
    const detailedSummary = result.context || result.summary || result.assistantAddendum || "Product query processed";
    const productTitle = result.title || result.enhancedContent || extractProductTitle(input.content);
    
    // Extract todos from OpenAI response
    let todosList = [];
    if (Array.isArray(result.todos)) {
      todosList = result.todos.map(todo => ({
        title: typeof todo === 'string' ? todo : todo.title || `Research ${input.content}`,
        priority: typeof todo === 'object' ? todo.priority || 'medium' : 'medium'
      }));
    } else {
      todosList = generateShoppingTodos(input.content);
    }
    
    // Extract smart actions from OpenAI response
    let smartActionsList = [];
    if (Array.isArray(result.smartActions)) {
      smartActionsList = result.smartActions;
    } else {
      smartActionsList = generateCommerceActions(input.content, result);
    }
    
    // Extract enrichments from OpenAI response
    let enrichmentsList = { products: [] };
    if (result.enrichments && result.enrichments.products) {
      enrichmentsList = result.enrichments;
    } else {
      enrichmentsList = { products: generateProductSuggestions(input.content) };
    }
    
    const enhancedResult: MiraAIResult = {
      uid: '',
      timestamp: '',
      title: productTitle,
      summary: detailedSummary,
      intent: 'product-query',
      urgency: result.urgencyLevel || result.urgency || 'medium',
      complexity: Math.max(result.complexityScore || result.complexity || 7, 7), // Commerce queries are complex
      confidence: classification.confidence,
      todos: todosList,
      smartActions: smartActionsList,
      assistantAddendum: result.assistantAddendum || generateProductAnalysis(input.content, result),
      enrichments: enrichmentsList,
      processingPath: 'commerce',
      classificationScores: classification.scores,
      _rawModelJSON: result
    };
    
    return enhancedResult;
    
  } catch (error) {
    console.error('Concierge brain error:', error);
    
    // Fallback for commerce queries
    return {
      uid: '',
      timestamp: '',
      title: extractProductTitle(input.content),
      summary: "Shopping assistance available",
      intent: 'product-query',
      urgency: 'medium',
      complexity: 5,
      confidence: classification.confidence,
      todos: generateShoppingTodos(input.content),
      smartActions: generateCommerceActions(input.content),
      assistantAddendum: `I can help you research and find the best options for: ${input.content}`,
      enrichments: {
        products: generateProductSuggestions(input.content)
      },
      processingPath: 'commerce',
      classificationScores: classification.scores
    };
  }
}

/**
 * Extract product-focused title
 */
function extractProductTitle(content: string): string {
  // Look for product keywords and create focused title
  const productWords = content.toLowerCase().match(/\b(best|cheap|affordable|buy|purchase)\s+([^.!?]+)/);
  if (productWords) {
    return productWords[0].split(' ').slice(0, 5).join(' ');
  }
  
  const words = content.trim().split(/\s+/);
  return words.slice(0, 4).join(' ') + (words.length > 4 ? ' Search' : '');
}

/**
 * Generate shopping-focused todos
 */
function generateShoppingTodos(content: string): Array<{title: string, priority: string}> {
  const todos = [];
  
  // Research phase
  todos.push({
    title: `Research ${content.split(' ').slice(-3).join(' ')} options`,
    priority: 'medium'
  });
  
  // Compare phase
  todos.push({
    title: 'Compare prices and reviews',
    priority: 'medium'
  });
  
  // Purchase decision
  if (content.toLowerCase().includes('buy') || content.toLowerCase().includes('purchase')) {
    todos.push({
      title: 'Make purchase decision',
      priority: 'high'
    });
  }
  
  return todos;
}

/**
 * Generate commerce-specific smart actions
 */
function generateCommerceActions(content: string, result?: any): Array<{label: string, action: string, url?: string}> {
  const actions = [];
  
  // Research action
  actions.push({
    label: 'Research Online',
    action: 'openLink',
    url: `https://www.google.com/search?q=${encodeURIComponent(content + ' buy review')}`
  });
  
  // Price comparison
  actions.push({
    label: 'Compare Prices',
    action: 'compare'
  });
  
  // If product identified, add specific shopping links
  if (content.toLowerCase().includes('amazon')) {
    actions.push({
      label: 'View on Amazon',
      action: 'openLink',
      url: `https://amazon.com/s?k=${encodeURIComponent(content)}`
    });
  }
  
  return actions;
}

/**
 * Generate detailed product analysis
 */
function generateProductAnalysis(content: string, result?: any): string {
  return `Product Research Analysis:

Query: ${content}

I can help you find the best options by:
• Researching current market prices and availability
• Comparing top-rated products in this category  
• Finding the best deals and discounts
• Checking user reviews and expert recommendations

Would you like me to focus on any specific requirements like budget range, brand preferences, or particular features?`;
}

/**
 * Generate product suggestions based on query
 */
function generateProductSuggestions(content: string): Array<{name: string, price: string, url: string, rating?: string}> {
  // This would integrate with real shopping APIs in production
  // For now, provide structured placeholders that indicate research is needed
  
  const productType = content.toLowerCase();
  
  if (productType.includes('tv') || productType.includes('television')) {
    return [
      {
        name: 'Research needed for TV recommendations',
        price: 'Price comparison required',
        url: `https://www.google.com/search?q=${encodeURIComponent(content + ' best 2024')}`,
        rating: 'Reviews pending'
      }
    ];
  }
  
  return [
    {
      name: `Research needed for: ${content}`,
      price: 'Market analysis required',
      url: `https://www.google.com/search?q=${encodeURIComponent(content + ' best price')}`,
      rating: 'Comparison needed'
    }
  ];
}```

### server/brain/memoryBrain.ts
```typescript
/**
 * Memory Brain - Pure Reminder/Todo Processing Path
 * Handles personal tasks, reminders, notes, and memory organization
 */

import { MiraAIInput, MiraAIResult } from './miraAIProcessing';
import { ClassificationResult } from './classifiers/commerceClassifier';

export async function memoryBrain(
  input: MiraAIInput, 
  classification: ClassificationResult
): Promise<MiraAIResult> {
  
  // Import OpenAI for consistent processing
  const openaiModule = await import('../openai');
  
  // Create memory-focused prompt
  const memoryPrompt = `
SYSTEM: You are Mira's memory assistant. Process this personal note with focus on task organization and reminders.

USER_INPUT: "${input.content}"

PROCESSING_FOCUS:
- Extract actionable tasks and reminders
- Identify time-sensitive elements
- Organize into logical todo structure
- Keep analysis concise and practical

REQUIRED_JSON_OUTPUT:
{
  "title": "string (3-5 words, newspaper headline style)",
  "summary": "string (brief processing note)",
  "intent": "${classification.primaryIntent}",
  "urgency": "low|medium|high|critical",
  "complexity": "number (1-5 for memory tasks)",
  "todos": [{"title": "exact user words", "priority": "urgency", "due": "ISO date if mentioned"}],
  "smartActions": [{"label": "Set Reminder", "action": "reminder"}]
}

MEMORY_PROCESSING_RULES:
- Preserve user's exact phrasing for todos
- Mark time-sensitive items as higher urgency
- Keep complexity scores low (1-5) for personal tasks
- Extract only explicitly mentioned actions
- No unnecessary elaboration or suggestions

OUTPUT ONLY JSON:
`;

  try {
    // Process through OpenAI with memory focus
    const result = await openaiModule.analyzeWithOpenAI(memoryPrompt, 'simple');
    
    // Create memory-focused result
    const memoryResult: MiraAIResult = {
      uid: '',
      timestamp: '',
      title: result.enhancedContent || extractMemoryTitle(input.content),
      summary: result.context || "Note processed",
      intent: classification.primaryIntent,
      urgency: result.urgencyLevel || determineUrgency(input.content),
      complexity: Math.min(result.complexityScore || 3, 5), // Memory tasks are simpler
      confidence: classification.confidence,
      todos: result.todos?.map(todo => ({
        title: todo,
        priority: result.urgencyLevel || 'medium',
        due: extractDueDate(input.content)
      })) || extractSimpleTodos(input.content),
      smartActions: generateMemoryActions(input.content, classification.primaryIntent),
      processingPath: 'memory',
      classificationScores: classification.scores,
      _rawModelJSON: result
    };
    
    return memoryResult;
    
  } catch (error) {
    console.error('Memory brain error:', error);
    
    // Fallback for memory tasks
    return {
      uid: '',
      timestamp: '',
      title: extractMemoryTitle(input.content),
      summary: "Note processed successfully",
      intent: classification.primaryIntent,
      urgency: determineUrgency(input.content),
      complexity: 2,
      confidence: classification.confidence,
      todos: extractSimpleTodos(input.content),
      smartActions: generateMemoryActions(input.content, classification.primaryIntent),
      processingPath: 'memory',
      classificationScores: classification.scores
    };
  }
}

/**
 * Extract memory-focused title (newspaper style)
 */
function extractMemoryTitle(content: string): string {
  const words = content.trim().split(/\s+/);
  
  // Look for action words to create focused titles
  const actionMatch = content.match(/\b(call|email|meet|buy|pick up|remind|note|remember)\s+([^.!?]+)/i);
  if (actionMatch) {
    const actionPhrase = actionMatch[0].split(' ').slice(0, 4).join(' ');
    return actionPhrase.charAt(0).toUpperCase() + actionPhrase.slice(1);
  }
  
  // Fallback to first 3-5 words
  if (words.length <= 5) {
    return content;
  }
  return words.slice(0, 4).join(' ') + '...';
}

/**
 * Determine urgency based on time indicators
 */
function determineUrgency(content: string): 'low' | 'medium' | 'high' | 'critical' {
  const contentLower = content.toLowerCase();
  
  // Critical indicators
  if (/\b(urgent|asap|emergency|immediately|now)\b/.test(contentLower)) {
    return 'critical';
  }
  
  // High urgency indicators
  if (/\b(today|tonight|this morning|this afternoon)\b/.test(contentLower)) {
    return 'high';
  }
  
  // Medium urgency indicators
  if (/\b(tomorrow|this week|soon|deadline)\b/.test(contentLower)) {
    return 'medium';
  }
  
  return 'low';
}

/**
 * Extract simple todos from content
 */
function extractSimpleTodos(content: string): Array<{title: string, priority: string, due?: string}> {
  const urgency = determineUrgency(content);
  const dueDate = extractDueDate(content);
  
  // Simple extraction for single action items
  if (content.length < 100) {
    return [{
      title: content.trim(),
      priority: urgency,
      due: dueDate
    }];
  }
  
  // Multi-item extraction for longer content
  const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
  return sentences.slice(0, 3).map(sentence => ({
    title: sentence.trim(),
    priority: urgency,
    due: dueDate
  }));
}

/**
 * Extract due date from content
 */
function extractDueDate(content: string): string | undefined {
  const contentLower = content.toLowerCase();
  
  // Today
  if (/\b(today|tonight)\b/.test(contentLower)) {
    return new Date().toISOString().split('T')[0];
  }
  
  // Tomorrow
  if (/\btomorrow\b/.test(contentLower)) {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    return tomorrow.toISOString().split('T')[0];
  }
  
  // Specific dates (basic patterns)
  const dateMatch = content.match(/\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\b/);
  if (dateMatch) {
    return `${dateMatch[3]}-${dateMatch[1].padStart(2, '0')}-${dateMatch[2].padStart(2, '0')}`;
  }
  
  return undefined;
}

/**
 * Generate memory-specific smart actions
 */
function generateMemoryActions(content: string, intent: string): Array<{label: string, action: string}> {
  const actions = [];
  const contentLower = content.toLowerCase();
  
  // Time-based actions
  if (/\b(remind|reminder|alert)\b/.test(contentLower) || intent === 'reminder') {
    actions.push({
      label: 'Set Reminder',
      action: 'reminder'
    });
  }
  
  // Calendar actions
  if (/\b(meeting|appointment|call|@\s*\d+[ap]m?)\b/.test(contentLower)) {
    actions.push({
      label: 'Add to Calendar',
      action: 'calendar'
    });
  }
  
  // Note actions
  if (intent === 'personal-reflection' || content.length > 100) {
    actions.push({
      label: 'Save Note',
      action: 'save'
    });
  }
  
  // Default action
  if (actions.length === 0) {
    actions.push({
      label: 'Create Todo',
      action: 'todo'
    });
  }
  
  return actions;
}```

### server/brain/miraAIProcessing.ts
```typescript
/**
 * Intelligence-V2 Integration
 */
// ─────────────────────────────────────────────────────────────────────────────
// V2 COMPONENT SINGLETONS
import OpenAI from 'openai';
import { IntelligenceV2Router } from '../intelligence-v2/intelligence-router';
import { FeatureFlagManager } from '../intelligence-v2/feature-flags';

// Initialize Intelligence-V2 system
console.log('Environment check:', {
  FEATURE_INTELLIGENCE_V2: process.env.FEATURE_INTELLIGENCE_V2,
  OPENAI_API_KEY: process.env.OPENAI_API_KEY ? 'present' : 'missing'
});

const featureFlags = FeatureFlagManager.getInstance();

let intelligenceV2Router: IntelligenceV2Router | null = null;
if (featureFlags.isEnabled('INTELLIGENCE_V2_ENABLED')) {
  const apiKey = process.env.OPENAI_API_KEY_MIRA || process.env.OPENAI_API_KEY;
  console.log('Initializing Intelligence-V2 with API key:', apiKey ? `${apiKey.substring(0, 10)}...` : 'undefined');
  const openai = new OpenAI({ apiKey });
  intelligenceV2Router = new IntelligenceV2Router(openai);
  console.log('✅ [Bootstrap] Intelligence‑V2 router initialised successfully');
} else {
  console.log('❌ [Bootstrap] Intelligence‑V2 disabled by env flag');
  featureFlags.logFlagStatus();
}

/**
 * Enhanced time detection for reminder creation
 */
function detectTimeReferences(content: string): {
  hasTimeReference: boolean;
  extractedTimes: string[];
  isUrgent: boolean;
  shouldCreateReminder: boolean;
} {
  const contentLower = content.toLowerCase();

  // Explicit reminder phrases
  const reminderPhrases = [
    'remind me', 'reminder', 'don\'t forget', 'remember to', 'make sure to',
    'need to remember', 'schedule', 'appointment', 'meeting'
  ];

  // Time expressions
  const timeExpressions = [
    'tomorrow', 'today', 'tonight', 'this morning', 'this afternoon', 'this evening',
    'next week', 'next month', 'monday', 'tuesday', 'wednesday', 'thursday', 
    'friday', 'saturday', 'sunday', 'in \\d+ (hours?|days?|weeks?)', 
    'at \\d+:?\\d*\\s*(am|pm)?', 'by \\w+', 'before \\w+', 'after \\w+'
  ];

  // Urgency indicators
  const urgencyWords = [
    'urgent', 'important', 'deadline', 'due', 'asap', 'immediately', 
    'critical', 'priority', 'must', 'need to'
  ];

  const hasExplicitReminder = reminderPhrases.some(phrase => 
    contentLower.includes(phrase)
  );

  const extractedTimes = timeExpressions.filter(pattern => 
    new RegExp(pattern, 'i').test(content)
  );

  const isUrgent = urgencyWords.some(word => 
    contentLower.includes(word)
  );

  const hasTimeReference = extractedTimes.length > 0 || hasExplicitReminder;
  const shouldCreateReminder = hasExplicitReminder || (hasTimeReference && isUrgent);

  return {
    hasTimeReference,
    extractedTimes,
    isUrgent,
    shouldCreateReminder
  };
}


/**
 * Mira AI Processing - Orthogonal Upgrade
 * Universal dispatcher with commerce/memory path routing
 */

import { v4 as uuid } from 'uuid';

export interface MiraAIInput {
  content: string;
  mode: 'text' | 'image' | 'voice';
  imageData?: string;
  userContext?: string;
  location?: {
    latitude: number;
    longitude: number;
    city?: string;
    country?: string;
  };
  timestamp?: string;
  id?: string;
  req?: any;
}

export interface MiraAIResult {
  uid: string;
  timestamp: string;
  title: string;
  summary: string;
  intent: string;
  urgency: 'low' | 'medium' | 'high' | 'critical';
  complexity: number;
  confidence: number;

  // Core outputs
  todos: Array<{
    title: string;
    priority: string;
    due?: string;
  }>;

  // New: Separate reminders with time instructions
  reminders?: Array<{
    title: string;
    datetime: string;
    type: 'reminder';
  }>;

  smartActions: Array<{
    label: string;
    action: string;
    url?: string;
  }>;

  // New: Time instructions for Mira to understand
  timeInstructions?: {
    hasTimeReference: boolean;
    extractedTimes: string[];
    scheduledItems: string[];
  };

  // Enhanced outputs
  assistantAddendum?: string;
  enrichments?: {
    products?: Array<{
      name: string;
      price: string;
      url: string;
      rating?: string;
    }>;
    locations?: Array<{
      name: string;
      address: string;
      distance: string;
    }>;
  };

  // Routing metadata
  processingPath: 'commerce' | 'memory';
  classificationScores: Record<string, number>;

  // Legacy compatibility
  fromTheWeb?: any[];
  _rawModelJSON?: any;
}

/**
 * Fast commerce classification using keyword scoring
 */
function commerceClassifier(content: string): {
  isCommerce: boolean;
  confidence: number;
  scores: Record<string, number>;
  primaryIntent: string;
} {
  const contentLower = content.toLowerCase();

  // Commerce keywords weighted by specificity
  const commerceKeywords = {
    buy: 1.0, purchase: 1.0, order: 0.9, shopping: 0.9, store: 0.8,
    price: 0.9, cost: 0.8, sale: 0.9, discount: 0.8, deals: 0.8,
    best: 0.7, cheap: 0.7, affordable: 0.7, review: 0.6, compare: 0.7,
    headphones: 0.8, laptop: 0.8, phone: 0.8, tv: 0.8, shoes: 0.7,
    wireless: 0.6, bluetooth: 0.6, under: 0.5, dollars: 0.7, budget: 0.6
  };

  let commerceScore = 0;
  let totalMatches = 0;

  // Score commerce keywords
  for (const [keyword, weight] of Object.entries(commerceKeywords)) {
    if (contentLower.includes(keyword)) {
      commerceScore += weight;
      totalMatches++;
    }
  }

  // Boost for price patterns ($X, €X, £X)
  if (/[\$€£¥]\s*[\d,]+/.test(content)) {
    commerceScore += 0.7;
  }

  // Boost for comparison language
  if (/\b(vs|versus|compared? to|better than)\b/.test(contentLower)) {
    commerceScore += 0.5;
  }

  const confidence = Math.min(Math.max(commerceScore / Math.max(totalMatches, 1), 0), 1);

  return {
    isCommerce: commerceScore > 0.4,
    confidence,
    scores: { commerce: commerceScore },
    primaryIntent: commerceScore > 0.4 ? 'product-query' : 'simple-task'
  };
}

/**
 * Commerce path - product enrichment
 */
async function processCommerceQuery(input: MiraAIInput): Promise<MiraAIResult> {
  const openaiModule = await import('../openai');

  const commercePrompt = `
SYSTEM: You are Mira's shopping assistant. Analyze this product query and provide shopping assistance.

USER_QUERY: "${input.content}"

REQUIRED_JSON_OUTPUT:
{
  "title": "string (3-5 words, product-focused)",
  "summary": "string (shopping analysis)",
  "intent": "product-query",
  "urgency": "medium",
  "complexity": 6,
  "todos": [{"title": "research options", "priority": "medium"}],
  "smartActions": [{"label": "Research Online", "action": "openLink", "url": "https://www.google.com/search?q=${encodeURIComponent(input.content + ' buy')}"}],
  "assistantAddendum": "I can help you research and find the best options for this product query."
}

OUTPUT ONLY JSON:`;

  try {
    const result = await openaiModule.analyzeWithOpenAI(commercePrompt, 'enhanced');

    // Try to parse JSON response from enhancedContent
    let parsedResult = null;
    try {
      if (result.enhancedContent) {
        parsedResult = JSON.parse(result.enhancedContent);
      }
    } catch (parseError) {
      console.log('Could not parse commerce JSON, using fallback');
    }

    // Use the actual enhanced content from OpenAI instead of fallback summary
    let enhancedContent = result.enhancedContent || "Product analysis completed";

    // Clean only if it contains instruction text, but preserve rich content
    if (enhancedContent.includes("Generate comprehensive") || enhancedContent.includes("COMPREHENSIVE MARKDOWN CONTENT")) {
      enhancedContent = "Product research and comparison analysis completed";
    }

    return {
      uid: '',
      timestamp: '',
      title: parsedResult?.title || extractProductTitle(input.content),
      summary: enhancedContent, // Use the rich enhanced content here
      intent: parsedResult?.intent || 'product-query',
      urgency: parsedResult?.urgency || 'medium',
      complexity: parsedResult?.complexity || 6,
      confidence: 0.8,
      todos: parsedResult?.todos || [{title: `Research ${input.content}`, priority: 'medium'}],
      smartActions: parsedResult?.smartActions || [{
        label: 'Research Online',
        action: 'openLink',
        url: `https://www.google.com/search?q=${encodeURIComponent(input.content + ' buy review')}`
      }],
      assistantAddendum: parsedResult?.assistantAddendum || `I can help you research and find the best options for: ${input.content}`,
      enrichments: {
        products: [{
          name: `Research needed for: ${input.content}`,
          price: 'Price comparison required',
          url: `https://www.google.com/search?q=${encodeURIComponent(input.content + ' price')}`,
          rating: 'Reviews pending'
        }]
      },
      processingPath: 'commerce',
      classificationScores: { commerce: 0.8 },
      _rawModelJSON: result
    };
  } catch (error) {
    console.error('Commerce processing error:', error);
    return createFallbackResult(input, 'commerce');
  }
}

/**
 * Memory path - personal tasks and reminders
 */
async function processMemoryTask(input: MiraAIInput): Promise<MiraAIResult> {
  const openaiModule = await import('../openai');

  const memoryPrompt = `
SYSTEM: You are Mira's intelligent memory assistant. Extract todos and reminders with precise time information.

USER_INPUT: "${input.content}"

ANALYZE FOR TIME REFERENCES:
- Look for explicit time words: "remind me", "tomorrow", "next week", "at 2pm", "in 3 days", "by Friday"
- Look for implicit urgency: "don't forget", "important", "deadline", "due"
- Look for dates: "June 15", "Monday", "this weekend"
- Convert relative times to specific ISO datetimes when possible

CURRENT_TIME_CONTEXT: ${new Date().toISOString()}

REQUIRED_JSON_OUTPUT:
{
  "title": "string (3-5 words, newspaper style)",
  "summary": "string (brief processing note)",
  "intent": "simple-task",
  "urgency": "low|medium|high|critical",
  "complexity": "number (1-5)",
  "todos": [
    {
      "title": "exact user words for actionable task",
      "priority": "low|medium|high",
      "due": "ISO date if deadline mentioned"
    }
  ],
  "reminders": [
    {
      "title": "exact reminder text",
      "datetime": "ISO datetime when reminder should trigger",
      "type": "reminder"
    }
  ],
  "smartActions": [{"label": "Set Reminder", "action": "reminder"}],
  "timeInstructions": {
    "hasTimeReference": "boolean",
    "extractedTimes": ["array of time expressions found"],
    "scheduledItems": ["items that need scheduling"]
  }
}

PROCESSING_RULES:
1. If user says "remind me" or similar, create a reminder entry
2. If time words are present, mark hasTimeReference as true
3. For urgent/time-sensitive items, create both todo AND reminder
4. Default reminder time: if no specific time, use tomorrow 9am
5. Preserve user's exact phrasing in titles

OUTPUT ONLY JSON:`;

  try {
    const result = await openaiModule.analyzeWithOpenAI(memoryPrompt, 'simple');

    // Try to parse JSON response
    let parsedResult = null;
    try {
      if (result.enhancedContent) {
        parsedResult = JSON.parse(result.enhancedContent);
      }
    } catch (parseError) {
      console.log('Could not parse memory JSON, using fallback');
    }

    // Clean the summary to avoid instruction text appearing in UI
    let cleanSummary = parsedResult?.summary || "Note processed successfully";
    if (cleanSummary.includes("Generate comprehensive") || cleanSummary.length > 100) {
      cleanSummary = "Personal note organized and processed";
    }

    return {
      uid: '',
      timestamp: '',
      title: parsedResult?.title || extractMemoryTitle(input.content),
      summary: cleanSummary,
      intent: parsedResult?.intent || 'simple-task',
      urgency: parsedResult?.urgency || determineUrgency(input.content),
      complexity: parsedResult?.complexity || 2,
      confidence: 0.7,
      todos: parsedResult?.todos || [{title: input.content.trim(), priority: 'medium'}],
      reminders: parsedResult?.reminders || [],
      smartActions: parsedResult?.smartActions || [{label: 'Set Reminder', action: 'reminder'}],
      timeInstructions: parsedResult?.timeInstructions || {
        hasTimeReference: false,
        extractedTimes: [],
        scheduledItems: []
      },
      processingPath: 'memory',
      classificationScores: { memory: 0.7 },
      _rawModelJSON: result
    };
  } catch (error) {
    console.error('Memory processing error:', error);
    return createFallbackResult(input, 'memory');
  }
}

/**
 * Main entry point - Universal AI Processing
 */
import { storage } from '../storage.js';
export async function processNote(input: MiraAIInput): Promise<MiraAIResult> {
  const uid = input.id ?? uuid();
  const timestamp = input.timestamp ?? new Date().toISOString();

  // Switch between V1 and V2 processing  (null‑safe)
  if (
    featureFlags.isEnabled('INTELLIGENCE_V2_ENABLED') &&
    intelligenceV2Router !== null &&
    typeof intelligenceV2Router.processNoteV2 === 'function'
  ) {
    console.log('🧠 [Mira AI] Routing to Intelligence-V2 system');
    // Use the correct V2 processing method with userProfile
    const v2Result = await intelligenceV2Router.processNoteV2({
      content: input.content,
      mode: input.mode,
      id: uid,
      userProfile: input.userProfile
    });

    console.log('🧠 [V2] Direct three-layer result:', JSON.stringify(v2Result, null, 2));
    
    // V2 now returns the exact three-layer format: {title, original, aiBody, perspective, todos, reminder}
    // No mapping needed - pass through directly
    return {
      uid: v2Result.id,
      title: v2Result.title || v2Result.richContext?.title,
      summary: v2Result.richContext?.perspective || '',
      richContext: v2Result.richContext, // This is the three-layer format
      intent: 'general',
      urgency: 'medium',
      complexity: 5,
      confidence: 0.9,
      todos: v2Result.richContext?.todos || [],
      smartActions: (v2Result.richContext?.todos || []).map((todo: any) => ({
        label: todo.title,
        action: action.reasoning
      })) || [],
      entities: analysis?.immediateProcessing?.entities?.map((entity: any) => ({
        name: entity,
        type: 'general'
      })) || [],
      suggestedLinks: [],
      nextSteps: analysis?.recursiveReasoning?.step1Anticipation?.potentialActions || [],
      microQuestions: analysis?.recursiveReasoning?.step1Anticipation?.followUpQuestions || [],
      fromTheWeb: [],
      tags: analysis?.immediateProcessing?.entities || [],
      relatedTopics: analysis?.contextualIntelligence?.crossReferences?.map((ref: any) => ref.relationship) || [],
      processingPath: 'memory' as 'commerce' | 'memory',
      classificationScores: { 
        intelligence_v2: 1.0,
        complexity: analysis?.immediateProcessing?.complexity || 0,
        confidence: 0.9
      },
      timeInstructions: {
        hasTimeReference: false,
        extractedTimes: [],
        scheduledItems: []
      },
      timestamp: v2Result.timestamp
    };
  }

  try {
    // Fast classification
    const classification = commerceClassifier(input.content);

    // Route to appropriate processor
    let result: MiraAIResult;

    if (classification.isCommerce && classification.confidence > 0.6) {
      result = await processCommerceQuery(input);
      result.processingPath = 'commerce';
    } else {
      result = await processMemoryTask(input);
      result.processingPath = 'memory';
    }

    // Add metadata
    result.uid = uid;
    result.timestamp = timestamp;
    result.confidence = classification.confidence;
    result.classificationScores = classification.scores;

    return result;

  } catch (error) {
    console.error('Mira AI processing error:', error);
    return createFallbackResult(input, 'memory');
  }
}

/**
 * Helper functions
 */
function extractProductTitle(content: string): string {
  const words = content.trim().split(/\s+/);
  return words.slice(0, 4).join(' ') + (words.length > 4 ? ' Search' : '');
}

function extractMemoryTitle(content: string): string {
  const words = content.trim().split(/\s+/);
  return words.length <= 5 ? content : words.slice(0, 4).join(' ') + '...';
}

function determineUrgency(content: string): 'low' | 'medium' | 'high' | 'critical' {
  const contentLower = content.toLowerCase();
  if (/\b(urgent|asap|emergency|immediately|now)\b/.test(contentLower)) return 'critical';
  if (/\b(today|tonight|this morning|this afternoon)\b/.test(contentLower)) return 'high';
  if (/\b(tomorrow|this week|soon|deadline)\b/.test(contentLower)) return 'medium';
  return 'low';
}

function createFallbackResult(input: MiraAIInput, path: 'commerce' | 'memory'): MiraAIResult {
  return {
    uid: uuid(),
    timestamp: new Date().toISOString(),
    title: extractMemoryTitle(input.content),
    summary: "Note processed successfully",
    intent: path === 'commerce' ? 'product-query' : 'simple-task',
    urgency: 'low',
    complexity: path === 'commerce' ? 5 : 2,
    confidence: 0.5,
    todos: [{title: input.content.trim(), priority: 'medium'}],
    smartActions: [{label: path === 'commerce' ? 'Research Online' : 'Set Reminder', action: path === 'commerce' ? 'openLink' : 'reminder'}],
    processingPath: path,
    classificationScores: {}
  };
}

// Export for backward compatibility
export const processMiraInput = processNote;```

### server/brain/promptTemplates/dispatcherPrompt.ts
```typescript
/**
 * Dispatcher Prompt - Universal header for all AI processing
 */

import { MiraAIInput } from '../miraAIProcessing';

export function dispatcherPrompt(input: MiraAIInput): string {
  return `
SYSTEM: You are Mira's intelligent processing system. Analyze user input and respond with structured JSON only.

CORE_PRINCIPLES:
- Preserve user's exact language and intent
- Extract actionable items without elaboration
- Provide confident, concise analysis
- Focus on practical utility over verbose explanation

USER_INPUT: "${input.content}"
PROCESSING_MODE: ${input.mode}
TIMESTAMP: ${input.timestamp || new Date().toISOString()}

UNIVERSAL_REQUIREMENTS:
- Always output valid JSON following the specified schema
- Keep titles to 3-5 words maximum (newspaper headline style)
- Match urgency to explicit time indicators in content
- Extract todos using user's exact phrasing
- Provide confidence scores between 0.0-1.0

CONTEXT_AWARENESS:
${input.userContext ? `User Context: ${input.userContext}` : ''}
${input.location ? `Location: ${input.location.city}, ${input.location.country}` : ''}
`;
}```

### server/brain/promptTemplates/simpleTask.ts
```typescript
/**
 * Simple Task Template - Memory processing for basic todos and reminders
 */

import { MiraAIInput } from '../miraAIProcessing';
import { dispatcherPrompt } from './dispatcherPrompt';

export function simpleTaskTemplate(input: MiraAIInput): string {
  const basePrompt = dispatcherPrompt(input);
  
  return `${basePrompt}

INTENT_CLASSIFICATION: simple-task
ADDITIONAL_HINT: This appears to be a straightforward task or reminder. Keep processing minimal and extract only explicit user requirements.

REQUIRED_SCHEMA:
{
  "title": "string (3-5 words max, newspaper headline style)",
  "summary": "string (1-2 sentences, only if different from title)",
  "intent": "simple-task",
  "urgency": "low" | "medium" | "high" | "critical",
  "complexity": "number (1-5 for simple tasks)",
  "todos": [{"title": "string (match user's exact words)", "due": "ISO date if specified", "priority": "urgency"}],
  "smartActions": [{"label": "Set Reminder", "action": "reminder"}],
  "entities": [],
  "optionalTodos": [],
  "nextSteps": []
}

PROCESSING_RULES:
- Extract only what user explicitly stated
- Do NOT add unnecessary next steps or suggestions
- Keep complexity between 1-5
- Use user's exact phrasing for todos
- Mark time-sensitive items with appropriate urgency

OUTPUT ONLY JSON:`;
}```

### server/company-intelligence.ts
```typescript
/**
 * Company Intelligence Module
 * Provides comprehensive business intelligence and company research capabilities
 */

export interface CompanyProfile {
  name: string;
  foundedYear?: string;
  founders?: string[];
  businessModel: string;
  keyProducts: string[];
  industryPosition: string;
  fundingHistory?: string;
  marketPresence: string;
  recentDevelopments: string[];
  culturalSignificance: string;
  technicalDetails?: string;
  competitiveLandscape?: string;
  targetDemographics?: string;
}

/**
 * Company Intelligence Database
 * Contains detailed profiles of major companies, especially in tech and AI
 */
export const COMPANY_INTELLIGENCE_DB: Record<string, CompanyProfile> = {
  "pinata farms": {
    name: "Piñata Farms",
    foundedYear: "2019-2020",
    founders: ["Colin Carrier (ex-Twitch Chief Strategy Officer)", "Josh Hossain"],
    businessModel: "Consumer AI company focused on meme creation and viral remix culture",
    keyProducts: [
      "Mobile app for creating and remixing memes using AI-assisted tools",
      "AI-powered voiceovers and face swaps",
      "Scene editing and personalization tools",
      "Social meme sharing platform"
    ],
    industryPosition: "Pioneer in AI-powered meme creation and remix culture",
    fundingHistory: "Backed by Andreessen Horowitz (a16z) and BoxGroup",
    marketPresence: "Los Angeles / San Francisco based, popular with Gen Z and creator communities",
    recentDevelopments: [
      "Advanced AI tools for automatic face tracking and lip sync",
      "Voice generation and motion matching capabilities",
      "Integration with Discord, TikTok, and Instagram Stories",
      "Focus on spontaneous, irreverent content creation"
    ],
    culturalSignificance: "Represents the intersection of AI technology and internet culture, offering a subversive counterpoint to sanitized social content",
    technicalDetails: "AI-as-co-creator platform that blurs the line between user-generated content and AI remixing",
    competitiveLandscape: "Positioned as 'TikTok for memes' with emphasis on low-friction creation and virality",
    targetDemographics: "Gen Z users, creator communities, Discord communities, and private group chat users"
  },
  "openai": {
    name: "OpenAI",
    foundedYear: "2015",
    founders: ["Sam Altman", "Elon Musk", "Greg Brockman", "Ilya Sutskever"],
    businessModel: "AI research and deployment company focused on artificial general intelligence",
    keyProducts: ["GPT models", "ChatGPT", "DALL-E", "Whisper", "Codex"],
    industryPosition: "Leading AI research organization",
    fundingHistory: "Multi-billion dollar funding from Microsoft and others",
    marketPresence: "Global leader in conversational AI and generative models",
    recentDevelopments: ["GPT-4", "ChatGPT Plus", "API services", "Enterprise solutions"],
    culturalSignificance: "Democratized access to advanced AI capabilities"
  }
};

/**
 * Analyzes company mentions and provides comprehensive intelligence
 */
export function getCompanyIntelligence(companyName: string): CompanyProfile | null {
  const normalizedName = companyName.toLowerCase().trim();
  
  // Direct match
  if (COMPANY_INTELLIGENCE_DB[normalizedName]) {
    return COMPANY_INTELLIGENCE_DB[normalizedName];
  }
  
  // Fuzzy matching for variations
  for (const [key, profile] of Object.entries(COMPANY_INTELLIGENCE_DB)) {
    if (normalizedName.includes(key) || key.includes(normalizedName)) {
      return profile;
    }
  }
  
  return null;
}

/**
 * Generates comprehensive company analysis for image content
 */
export function enhanceWithCompanyIntelligence(content: string, identifiedCompanies: string[]): string {
  let enhancedContent = content;
  
  for (const company of identifiedCompanies) {
    const intelligence = getCompanyIntelligence(company);
    
    if (intelligence) {
      enhancedContent += `\n\n## ${intelligence.name} - Company Intelligence\n`;
      enhancedContent += `**Founded:** ${intelligence.foundedYear}\n`;
      enhancedContent += `**Founders:** ${intelligence.founders?.join(", ")}\n`;
      enhancedContent += `**Business Model:** ${intelligence.businessModel}\n`;
      enhancedContent += `**Key Products:** ${intelligence.keyProducts.join(", ")}\n`;
      enhancedContent += `**Industry Position:** ${intelligence.industryPosition}\n`;
      if (intelligence.fundingHistory) {
        enhancedContent += `**Funding:** ${intelligence.fundingHistory}\n`;
      }
      enhancedContent += `**Market Presence:** ${intelligence.marketPresence}\n`;
      enhancedContent += `**Cultural Significance:** ${intelligence.culturalSignificance}\n`;
      
      if (intelligence.recentDevelopments.length > 0) {
        enhancedContent += `**Recent Developments:**\n`;
        intelligence.recentDevelopments.forEach(dev => {
          enhancedContent += `- ${dev}\n`;
        });
      }
    }
  }
  
  return enhancedContent;
}```

### server/data-protection.ts
```typescript
/**
 * Data Protection Service for Note Versioning and Content Preservation
 * 
 * This service analyzes content changes to determine risk levels and
 * protect valuable user-input data from AI overwrites.
 */

import { db } from "./db";
import { notes, noteVersions, type Note, type InsertNoteVersion } from "@shared/schema";
import { eq, desc } from "drizzle-orm";

export interface ContentAnalysis {
  riskLevel: "low" | "medium" | "high";
  userValueSections: string[];
  preservedContent: string[];
  changeDescription: string;
  confidence: number;
}

export interface VersioningOptions {
  changeType: "user_edit" | "ai_enhancement" | "ai_suggestion_applied" | "manual_rollback";
  changedBy: "user" | "ai_openai" | "ai_claude" | "system";
  userApproved?: boolean;
  forcePreserve?: string[];
}

export class DataProtectionService {
  
  /**
   * Analyzes content to identify valuable user-input sections
   */
  static analyzeContentValue(originalContent: string, newContent: string): ContentAnalysis {
    const analysis: ContentAnalysis = {
      riskLevel: "low",
      userValueSections: [],
      preservedContent: [],
      changeDescription: "",
      confidence: 85
    };

    // Identify high-value content patterns
    const highValuePatterns = [
      /\b\d{1,2}:\d{2}\s*(am|pm|AM|PM)\b/g, // Specific times
      /\b\d{1,2}\/\d{1,2}\/\d{2,4}\b/g, // Dates
      /\$\d+(\.\d{2})?\b/g, // Money amounts
      /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g, // Proper names
      /\b\d{3}-\d{3}-\d{4}\b/g, // Phone numbers
      /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, // Emails
      /\b\d+\s+(st|nd|rd|th|Street|Ave|Avenue|Blvd|Boulevard)\b/gi, // Addresses
    ];

    // Check for high-value content
    let hasHighValueContent = false;
    for (const pattern of highValuePatterns) {
      const matches = originalContent.match(pattern);
      if (matches && matches.length > 0) {
        hasHighValueContent = true;
        analysis.userValueSections.push(...matches);
      }
    }

    // Analyze content length and complexity
    const originalLength = originalContent.length;
    const lengthDifference = Math.abs(newContent.length - originalLength);
    const significantChange = lengthDifference > originalLength * 0.3; // 30% change

    // Determine risk level
    if (hasHighValueContent && significantChange) {
      analysis.riskLevel = "high";
      analysis.confidence = 95;
    } else if (hasHighValueContent || significantChange) {
      analysis.riskLevel = "medium";
      analysis.confidence = 88;
    } else {
      analysis.riskLevel = "low";
      analysis.confidence = 85;
    }

    // Generate change description
    if (lengthDifference > originalLength * 0.5) {
      analysis.changeDescription = "Major content restructuring detected";
    } else if (hasHighValueContent) {
      analysis.changeDescription = "Changes detected in content with specific details";
    } else {
      analysis.changeDescription = "Minor content enhancement";
    }

    // Preserve high-value sections
    analysis.preservedContent = analysis.userValueSections;

    return analysis;
  }

  /**
   * Creates a version entry before making changes
   */
  static async createVersion(
    noteId: number, 
    currentContent: string, 
    newContent: string,
    options: VersioningOptions
  ): Promise<void> {
    try {
      // Get current version number
      const currentNote = await db
        .select({ version: notes.version })
        .from(notes)
        .where(eq(notes.id, noteId))
        .limit(1);

      const currentVersion = currentNote[0]?.version || 1;
      const newVersion = currentVersion + 1;

      // Analyze content changes
      const analysis = this.analyzeContentValue(currentContent, newContent);

      // Create version entry
      const versionData: InsertNoteVersion = {
        noteId,
        version: currentVersion,
        content: currentContent,
        changeType: options.changeType,
        changeDescription: analysis.changeDescription,
        changedBy: options.changedBy,
        preservedSections: analysis.preservedContent,
        confidence: analysis.confidence,
        userApproved: options.userApproved || false,
        riskLevel: analysis.riskLevel
      };

      await db.insert(noteVersions).values(versionData);

      // Update note version
      await db
        .update(notes)
        .set({ 
          version: newVersion,
          originalContent: currentNote[0] ? undefined : currentContent // Preserve original only once
        })
        .where(eq(notes.id, noteId));

    } catch (error) {
      console.error("Failed to create version:", error);
      throw new Error("Version creation failed");
    }
  }

  /**
   * Safely applies AI changes with content protection
   */
  static async safeApplyAIChanges(
    noteId: number,
    currentContent: string,
    aiSuggestions: any,
    options: Partial<VersioningOptions> = {}
  ): Promise<{ success: boolean; appliedChanges: string; warnings: string[] }> {
    const warnings: string[] = [];
    
    // Analyze the proposed changes
    const proposedContent = aiSuggestions.enhancedContent || currentContent;
    const analysis = this.analyzeContentValue(currentContent, proposedContent);

    // High-risk changes require user approval
    if (analysis.riskLevel === "high" && !options.userApproved) {
      warnings.push("High-risk changes detected - requires user approval");
      warnings.push(`Protected content: ${analysis.userValueSections.join(", ")}`);
      
      return {
        success: false,
        appliedChanges: currentContent,
        warnings
      };
    }

    // For medium risk, preserve specific sections
    let finalContent = proposedContent;
    if (analysis.riskLevel === "medium") {
      // Preserve high-value sections by merging them back
      for (const section of analysis.userValueSections) {
        if (!proposedContent.includes(section)) {
          warnings.push(`Preserved user data: ${section}`);
          // Add preserved content as a note at the end
          finalContent += `\n\n[Preserved]: ${section}`;
        }
      }
    }

    // Create version before applying changes
    await this.createVersion(noteId, currentContent, finalContent, {
      changeType: "ai_enhancement",
      changedBy: options.changedBy || "ai_openai",
      userApproved: options.userApproved || false,
      ...options
    });

    return {
      success: true,
      appliedChanges: finalContent,
      warnings
    };
  }

  /**
   * Gets version history for a note
   */
  static async getVersionHistory(noteId: number): Promise<any[]> {
    try {
      const versions = await db
        .select()
        .from(noteVersions)
        .where(eq(noteVersions.noteId, noteId))
        .orderBy(desc(noteVersions.version));

      return versions;
    } catch (error) {
      console.error("Failed to get version history:", error);
      return [];
    }
  }

  /**
   * Rolls back to a specific version
   */
  static async rollbackToVersion(noteId: number, targetVersion: number): Promise<boolean> {
    try {
      // Get the target version content
      const versionData = await db
        .select()
        .from(noteVersions)
        .where(eq(noteVersions.noteId, noteId))
        .limit(1);

      if (versionData.length === 0) {
        throw new Error("Version not found");
      }

      const targetContent = versionData[0].content;

      // Get current content for versioning
      const currentNote = await db
        .select()
        .from(notes)
        .where(eq(notes.id, noteId))
        .limit(1);

      if (currentNote.length === 0) {
        throw new Error("Note not found");
      }

      // Create version entry for current state before rollback
      await this.createVersion(noteId, currentNote[0].content, targetContent, {
        changeType: "manual_rollback",
        changedBy: "user"
      });

      // Apply rollback
      await db
        .update(notes)
        .set({ content: targetContent })
        .where(eq(notes.id, noteId));

      return true;
    } catch (error) {
      console.error("Rollback failed:", error);
      return false;
    }
  }

  /**
   * Identifies if instruction suggests safe minor changes
   */
  static isMinorChange(instruction: string): boolean {
    const minorChangePatterns = [
      /change.*time.*from.*to/i,
      /update.*date.*from.*to/i,
      /replace.*\b\w+\b.*with.*\b\w+\b/i,
      /fix.*typo/i,
      /correct.*spelling/i,
      /add.*reminder/i,
      /remove.*completed/i
    ];

    return minorChangePatterns.some(pattern => pattern.test(instruction));
  }

  /**
   * Identifies if instruction suggests potentially risky changes
   */
  static isRiskyChange(instruction: string): boolean {
    const riskyChangePatterns = [
      /rewrite/i,
      /completely.*change/i,
      /start.*over/i,
      /delete.*everything/i,
      /replace.*all/i,
      /summarize.*everything/i
    ];

    return riskyChangePatterns.some(pattern => pattern.test(instruction));
  }
}```

### server/db.ts
```typescript
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "@shared/schema";

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema });```

### server/feature-flags-runtime.ts
```typescript
/* runtime flag helper autogenerated 2025‑06‑22 */
export const FEATURE_FLAGS = {
  INTELLIGENCE_V2_ENABLED:        process.env.FEATURE_INTELLIGENCE_V2 !== 'false',
  VECTOR_SEARCH_ENABLED:          process.env.FEATURE_VECTOR_SEARCH   !== 'false',
  RECURSIVE_REASONING_ENABLED:    process.env.FEATURE_RECURSIVE_REASONING !== 'false',
  RELATIONSHIP_MAPPING_ENABLED:   process.env.FEATURE_RELATIONSHIP_MAPPING !== 'false',
  PROACTIVE_DELIVERY_ENABLED:     process.env.FEATURE_PROACTIVE_DELIVERY   !== 'false',
  ENHANCED_COLLECTIONS_ENABLED:   process.env.FEATURE_ENHANCED_COLLECTIONS !== 'false',
  ADVANCED_NOTIFICATIONS_ENABLED: process.env.FEATURE_ADVANCED_NOTIFICATIONS !== 'false',
} as const;```

### server/file-storage.ts
```typescript
import fs from 'fs';
import path from 'path';
import { randomUUID } from 'crypto';

const UPLOADS_DIR = path.join(process.cwd(), 'uploads');

// Ensure uploads directory exists
if (!fs.existsSync(UPLOADS_DIR)) {
  fs.mkdirSync(UPLOADS_DIR, { recursive: true });
}

export interface SavedFile {
  filename: string;
  originalName: string;
  url: string;
  size: number;
  mimeType: string;
}

export async function saveAudioFile(
  buffer: Buffer, 
  originalName: string = 'recording.webm',
  mimeType: string = 'audio/webm'
): Promise<SavedFile> {
  try {
    // Generate unique filename with proper extension
    let fileExtension = path.extname(originalName);
    
    // If no extension, derive from MIME type
    if (!fileExtension) {
      if (mimeType.startsWith('image/')) {
        if (mimeType.includes('png')) fileExtension = '.png';
        else if (mimeType.includes('gif')) fileExtension = '.gif';
        else if (mimeType.includes('webp')) fileExtension = '.webp';
        else fileExtension = '.jpg';
      } else if (mimeType.startsWith('video/')) {
        if (mimeType.includes('mp4')) fileExtension = '.mp4';
        else if (mimeType.includes('webm')) fileExtension = '.webm';
        else if (mimeType.includes('mov')) fileExtension = '.mov';
        else fileExtension = '.mp4';
      } else if (mimeType.startsWith('audio/')) {
        if (mimeType.includes('mp3')) fileExtension = '.mp3';
        else if (mimeType.includes('wav')) fileExtension = '.wav';
        else fileExtension = '.webm';
      } else if (mimeType.includes('pdf')) {
        fileExtension = '.pdf';
      } else if (mimeType.includes('text/')) {
        fileExtension = '.txt';
      } else {
        fileExtension = '.bin';
      }
    }
    
    const filename = `${randomUUID()}${fileExtension}`;
    const filepath = path.join(UPLOADS_DIR, filename);
    
    // Save file to disk
    await fs.promises.writeFile(filepath, buffer);
    
    return {
      filename,
      originalName,
      url: `/uploads/${filename}`,
      size: buffer.length,
      mimeType
    };
  } catch (error) {
    console.error('Error saving file:', error);
    throw new Error('Failed to save file');
  }
}

export async function deleteFile(filename: string): Promise<void> {
  try {
    const filepath = path.join(UPLOADS_DIR, filename);
    if (fs.existsSync(filepath)) {
      await fs.promises.unlink(filepath);
    }
  } catch (error) {
    console.error('Error deleting file:', error);
    // Don't throw error, just log it
  }
}

export function getFileUrl(filename: string): string {
  return `/uploads/${filename}`;
}```

### server/index.ts
```typescript
// Load environment variables first
import "dotenv/config";

// Set Intelligence-V2 flags explicitly
process.env.FEATURE_INTELLIGENCE_V2 = 'true';
process.env.FEATURE_VECTOR_SEARCH = 'true';
process.env.FEATURE_RECURSIVE_REASONING = 'true';
process.env.FEATURE_RELATIONSHIP_MAPPING = 'true';
process.env.FEATURE_PROACTIVE_DELIVERY = 'true';
process.env.FEATURE_ENHANCED_COLLECTIONS = 'true';
process.env.FEATURE_ADVANCED_NOTIFICATIONS = 'true';
import express, { type Request, Response, NextFunction } from "express";
import path from "path";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { initializeDatabase } from "./init-db";
import { initializeStandardCollections } from "./init-collections";


const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Serve uploaded files statically
app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  // Initialize database with default collections
  await initializeDatabase();
  await initializeStandardCollections();

  const server = await registerRoutes(app);

  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // Use Replit's assigned PORT for preview pane compatibility, fallback to 5000
  const port = Number(process.env.PORT) || 5000;
  server.listen({
    port,
    host: "0.0.0.0",
  }, async () => {
    log(`serving on port ${port}`);

    // Initialize notification system
    try {
      const { initializeNotificationSystem } = await import('./notification-system');
      await initializeNotificationSystem();
    } catch (error) {
      console.error("Failed to initialize notification system:", error);
    }
  });
})();```

### server/init-collections.ts
```typescript
import { storage } from "./storage";

const standardCollections = [
  { name: "Personal", icon: "heart", color: "pink" },
  { name: "Home", icon: "home", color: "green" },
  { name: "Work", icon: "briefcase", color: "purple" },
  { name: "Family", icon: "users", color: "yellow" },
  { name: "Books", icon: "book", color: "orange" },
  { name: "Movies & TV", icon: "play", color: "red" },
  { name: "Restaurants", icon: "utensils", color: "teal" },
  { name: "Travel", icon: "plane", color: "blue" },
  { name: "Other", icon: "help-circle", color: "gray" }
];

export async function initializeStandardCollections() {
  try {
    const existingCollections = await storage.getCollections();
    
    for (const standardCollection of standardCollections) {
      const exists = existingCollections.find(
        c => c.name.toLowerCase() === standardCollection.name.toLowerCase()
      );
      
      if (!exists) {
        await storage.createCollection(standardCollection);
        console.log(`Created standard collection: ${standardCollection.name}`);
      }
    }
    
    console.log("Standard collections initialized");
  } catch (error) {
    console.error("Error initializing standard collections:", error);
  }
}```

### server/init-db.ts
```typescript
import { storage } from "./storage";

export async function initializeDatabase() {
  try {
    // Check if collections already exist
    const existingCollections = await storage.getCollections();
    
    if (existingCollections.length === 0) {
      // Create default collections
      await storage.createCollection({ 
        name: "Coffee & Food Spots", 
        icon: "coffee", 
        color: "orange" 
      });
      
      await storage.createCollection({ 
        name: "Project Ideas", 
        icon: "lightbulb", 
        color: "purple" 
      });
      
      await storage.createCollection({ 
        name: "Reading List", 
        icon: "book", 
        color: "green" 
      });
      
      console.log("Default collections created");
    }
  } catch (error) {
    console.error("Failed to initialize database:", error);
  }
}```

### server/intelligence-v2/collections-extractor.ts
```typescript
import { db } from '../storage.js';
import { collections, collectionItems } from '@shared/schema';

export class CollectionsExtractor {
  static async extract(noteId: number, text: string) {
    // naive list detector (bullets or "X, Y, Z")
    const bulletMatch = text.match(/-\s(.+)/g);
    const inlineList = text.includes(',') ? text.split(',') : [];
    const items = bulletMatch ? bulletMatch.map(l => l.replace(/-\s/, '')) : inlineList;

    if (!items.length) return;

    // simple "Books" heuristic – refine in later iterations
    const title = 'Untitled Collection';
    
    try {
      const [{ id: collectionId }] = await db
        .insert(collections)
        .values({ name: title, collectionType: 'generic' })
        .returning();

      for (let i = 0; i < items.length; i++) {
        const raw = items[i];
        await db.insert(collectionItems).values({
          collectionId: collectionId,
          sourceNoteId: noteId,
          rawText: raw.trim(),
          position: i
        });
      }
    } catch (error) {
      console.warn('Collection extraction failed:', error);
    }
  }
}
```

### server/intelligence-v2/feature-flags.ts
```typescript
/**
 * Intelligence-V2 Feature Flag System
 * Controls rollout of new recursive reasoning capabilities
 */

export interface FeatureFlags {
  INTELLIGENCE_V2_ENABLED: boolean;
  VECTOR_SEARCH_ENABLED: boolean;
  RECURSIVE_REASONING_ENABLED: boolean;
  RELATIONSHIP_MAPPING_ENABLED: boolean;
  PROACTIVE_DELIVERY_ENABLED: boolean;
  ENHANCED_COLLECTIONS_ENABLED: boolean;
  ADVANCED_NOTIFICATIONS_ENABLED: boolean;
}

export class FeatureFlagManager {
  private static instance: FeatureFlagManager;
  private flags: FeatureFlags;

  private constructor() {
    this.flags = this.loadFeatureFlags();
    console.log('🚩 Feature Flags initialized:', this.flags);
  }

  public static getInstance(): FeatureFlagManager {
    if (!FeatureFlagManager.instance) {
      FeatureFlagManager.instance = new FeatureFlagManager();
    }
    return FeatureFlagManager.instance;
  }

  private loadFeatureFlags(): FeatureFlags {
    return {
      INTELLIGENCE_V2_ENABLED: process.env.FEATURE_INTELLIGENCE_V2 === 'true',
      VECTOR_SEARCH_ENABLED: process.env.FEATURE_VECTOR_SEARCH === 'true' || process.env.FEATURE_INTELLIGENCE_V2 === 'true',
      RECURSIVE_REASONING_ENABLED: process.env.FEATURE_RECURSIVE_REASONING === 'true' || process.env.FEATURE_INTELLIGENCE_V2 === 'true',
      RELATIONSHIP_MAPPING_ENABLED: process.env.FEATURE_RELATIONSHIP_MAPPING === 'true' || process.env.FEATURE_INTELLIGENCE_V2 === 'true',
      PROACTIVE_DELIVERY_ENABLED: process.env.FEATURE_PROACTIVE_DELIVERY === 'true' || process.env.FEATURE_INTELLIGENCE_V2 === 'true',
      ENHANCED_COLLECTIONS_ENABLED: process.env.FEATURE_ENHANCED_COLLECTIONS === 'true' || process.env.FEATURE_INTELLIGENCE_V2 === 'true',
      ADVANCED_NOTIFICATIONS_ENABLED: process.env.FEATURE_ADVANCED_NOTIFICATIONS === 'true' || process.env.FEATURE_INTELLIGENCE_V2 === 'true'
    };
  }

  public isEnabled(flag: keyof FeatureFlags): boolean {
    return this.flags[flag] || false;
  }

  public getFlags(): FeatureFlags {
    return { ...this.flags };
  }

  public refreshFlags(): void {
    this.flags = this.loadFeatureFlags();
  }

  public logFlagStatus(): void {
    console.log('🚩 Feature Flags Status:');
    Object.entries(this.flags).forEach(([flag, enabled]) => {
      console.log(`  ${flag}: ${enabled ? '✅ ENABLED' : '❌ DISABLED'}`);
    });
  }
}```

### server/intelligence-v2/intelligence-router-fixed.ts
```typescript
/**
 * Intelligence-V2 Router - Fixed Implementation
 * Main entry point for enhanced recursive reasoning and vector-based intelligence
 */

import { VectorEngine } from './vector-engine.js';
import { RecursiveReasoningEngine, RecursiveAnalysis } from './recursive-reasoning-engine.js';
import { RelationshipMapper } from './relationship-mapper.js';
import { IntentVectorClassifier, type IntentVector } from './intent-vector-classifier.js';
import { CollectionsExtractor } from './collections-extractor.js';
import { FeatureFlagManager } from './feature-flags.js';
import { storage } from '../storage.js';
import { makeTitle } from '../utils/title-governor.js';

export interface IntelligenceV2Input {
  id?: string;
  content: string;
  mode: "text" | "voice" | "image" | "file";
  context?: {
    source?: string;
    location?: any;
    previousConversation?: any;
  };
  userId?: string;
  timestamp?: string;
}

export interface IntelligenceV2Result {
  // Core processing results
  id: string;
  title: string;
  summary: string;
  enhancedContent: string;
  intent: string;
  urgency: 'low' | 'medium' | 'high' | 'critical';
  complexity: number;
  
  // Intelligence-v2 enhancements
  recursiveAnalysis: RecursiveAnalysis;
  vectorSimilarities: Array<{ noteId: number; similarity: number; reasoning: string }>;
  relationshipInsights: Array<{ type: string; target: string; strength: number; context: string }>;
  proactiveRecommendations: {
    immediate: string[];
    upcoming: string[];
    strategic: string[];
  };
  
  // Traditional outputs for compatibility
  todos: ProcessedTodo[];
  smartActions: SmartAction[];
  entities: Entity[];
  suggestedLinks: Link[];
  nextSteps: string[];
  microQuestions: string[];
  fromTheWeb: WebResult[];
  tags: string[];
  relatedTopics: string[];
  confidence: number;
  processingPath: 'memory' | 'commerce';
  timestamp: string;
  classificationScores: Record<string, number>;
}

interface ProcessedTodo {
  title: string;
  priority: string;
  due?: string;
  isReminder?: boolean;
  reminderType?: string;
  notificationStructure?: any;
}

interface SmartAction {
  label: string;
  action: string;
}

interface Entity {
  name: string;
  type: string;
  details?: string;
}

interface Link {
  title: string;
  url: string;
  type: string;
}

interface WebResult {
  title: string;
  snippet: string;
  url: string;
  relevance: number;
}

export class IntelligenceV2Router {
  private vectorEngine: VectorEngine;
  private reasoningEngine: RecursiveReasoningEngine;
  private relationshipMapper: RelationshipMapper;
  private openai: any;

  constructor(openaiClient: any) {
    this.openai = openaiClient;
    this.vectorEngine = new VectorEngine(openaiClient);
    this.reasoningEngine = new RecursiveReasoningEngine(openaiClient);
    this.relationshipMapper = new RelationshipMapper(openaiClient);
  }

  /**
   * Main processing entry point with full intelligence-v2 capabilities
   */
  async processWithIntelligenceV2(
    input: IntelligenceV2Input,
    userContext?: any
  ): Promise<IntelligenceV2Result> {
    try {
      console.log('🧠 Processing with Intelligence-V2:', input.content.substring(0, 100));

      // 1. Get existing notes for context
      const allNotes = await storage.getAllNotes();
      
      // 2. Classify intent & entities (multi‑label)
      const intentVector: IntentVector = await IntentVectorClassifier.classify(
        input.content
      );

      // 3. Perform semantic search to find related content
      const semanticMatches = await this.vectorEngine.performSemanticSearch(
        { query: input.content, limit: 15 },
        allNotes
      );

      // 4. Build temporal and user context
      const temporalContext = await this.buildTemporalContext(input, userContext);
      
      // 5. Perform REAL recursive reasoning (can be toggled)
      let recursiveAnalysis = null;
      if (FeatureFlagManager.getInstance().isEnabled('RECURSIVE_REASONING_ENABLED')) {
        try {
          recursiveAnalysis = await this.reasoningEngine.performRecursiveAnalysis(
            input.content,
            userContext,
            semanticMatches,
            temporalContext
          );
          console.log('✅ Recursive reasoning finished');
        } catch (err) {
          console.warn('⚠️ Recursive reasoning failed:', (err as Error).message);
        }
      } else {
        console.log('🔄 Recursive reasoning disabled, using fallback');
        // Create basic fallback analysis
        recursiveAnalysis = {
          immediateProcessing: {
            understanding: `Enhanced analysis: ${input.content}`,
            entities: [],
            intent: semanticMatches.length > 0 ? 'research' : 'general',
            urgency: 'medium' as const,
            complexity: Math.min(10, Math.max(1, Math.ceil(input.content.length / 50))),
            temporalAnalysis: {
              explicitTimes: [],
              implicitUrgency: 'normal processing pace',
              deadlineImplications: 'no immediate deadlines detected',
              recurringPatterns: 'analyzing for patterns'
            }
          },
          recursiveReasoning: {
            step1Anticipation: {
              likelyNextNeeds: ['Follow-up research', 'Implementation planning'],
              followUpQuestions: ['What are the next steps?', 'How to prioritize?'],
              requiredInformation: ['Additional context', 'Resource requirements'],
              potentialActions: ['Create action plan', 'Set reminders'],
              cascadingEffects: ['Improved productivity'],
              optimizationOpportunities: ['Process automation'],
              longTermValue: 'Strategic planning enhancement',
              learningOpportunities: ['Pattern recognition']
            },
            step2Projection: {
              likelyNextNeeds: ['Progress tracking', 'Quality assurance'],
              followUpQuestions: ['Is this on track?', 'Any blockers?'],
              requiredInformation: ['Status updates', 'Performance metrics'],
              potentialActions: ['Monitor progress', 'Adjust strategy'],
              cascadingEffects: ['Enhanced outcomes'],
              optimizationOpportunities: ['Workflow improvements'],
              longTermValue: 'Continuous improvement',
              learningOpportunities: ['Best practices']
            },
            step3Implications: {
              likelyNextNeeds: ['Results analysis', 'Knowledge transfer'],
              followUpQuestions: ['What did we learn?', 'How to replicate?'],
              requiredInformation: ['Outcome data', 'Lessons learned'],
              potentialActions: ['Document insights', 'Share knowledge'],
              cascadingEffects: ['Organizational learning'],
              optimizationOpportunities: ['System-wide improvements'],
              longTermValue: 'Knowledge base enhancement',
              learningOpportunities: ['Strategic insights']
            }
          },
          contextualIntelligence: {
            crossReferences: semanticMatches.map(match => ({
              contentId: match.noteId?.toString() || 'unknown',
              relationship: 'semantic_similarity',
              strength: match.similarity,
              reasoning: `${(match.similarity * 100).toFixed(1)}% similarity`
            })),
            patternRecognition: semanticMatches.length > 2 ? 
              `Found ${semanticMatches.length} related items suggesting recurring themes` : 
              'Limited pattern data available',
            anomalyDetection: 'No anomalies detected',
            knowledgeGaps: ['Detailed analysis', 'Context expansion'],
            unexpectedConnections: []
          },
          proactiveDelivery: {
            surfaceImmediately: [],
            prepareForLater: [],
            suggestedActions: [
              {
                action: 'Review and organize content',
                reasoning: 'Maintain information quality',
                priority: 7
              },
              {
                action: 'Create follow-up reminders',
                reasoning: 'Ensure progress tracking',
                priority: 6
              }
            ],
            preventiveMeasures: [],
            optimizationSuggestions: []
          }
        };
      }

      // 6. Map relationships for this content
      const noteId = input.id || 'temp';
      const relationships = await this.relationshipMapper.mapRelationships(
        noteId,
        input.content,
        allNotes
      );

      // 7. Update vectors if we have a valid note ID
      if (input.id && !isNaN(parseInt(input.id))) {
        try {
          await this.vectorEngine.updateNoteVectors(parseInt(input.id), input.content, storage);
        } catch (vectorError) {
          console.warn('Vector update failed:', (vectorError as Error).message);
        }
      } else {
        console.warn('Skipping vector update - invalid note ID:', input.id);
      }

      // 8. Generate proactive recommendations
      const proactiveRecommendations = recursiveAnalysis ? 
        this.reasoningEngine.generateProactiveRecommendations(recursiveAnalysis) : 
        { immediate: [], upcoming: [], strategic: [] };

      // 9. Extract traditional outputs for compatibility
      const traditionalOutputs = this.extractTraditionalOutputs(recursiveAnalysis);

      // 10. Build comprehensive result
      const result: IntelligenceV2Result = {
        id: noteId,
        title: makeTitle(
          recursiveAnalysis?.immediateProcessing?.understanding || input.content
        ),
        summary: this.generateIntelligentSummary(recursiveAnalysis),
        enhancedContent: await this.enhanceContentWithInsights(input.content, recursiveAnalysis, semanticMatches),
        intent: recursiveAnalysis?.immediateProcessing?.intent || 'general',
        urgency: recursiveAnalysis?.immediateProcessing?.urgency || 'medium',
        complexity: recursiveAnalysis?.immediateProcessing?.complexity || 3,
        
        // Intelligence-v2 enhancements
        recursiveAnalysis: recursiveAnalysis || {} as RecursiveAnalysis,
        vectorSimilarities: semanticMatches.map(match => ({
          noteId: match.noteId,
          similarity: match.similarity,
          reasoning: match.reasoning
        })),
        relationshipInsights: relationships,
        proactiveRecommendations,
        
        // Traditional outputs
        ...traditionalOutputs,
        confidence: this.calculateOverallConfidence(recursiveAnalysis, semanticMatches),
        processingPath: this.determineProcessingPath(recursiveAnalysis),
        timestamp: new Date().toISOString(),
        classificationScores: this.generateClassificationScores(recursiveAnalysis)
      };

      console.log('✅ Intelligence-V2 processing completed with', semanticMatches.length, 'semantic matches and', relationships.length, 'relationships');
      
      return result;

    } catch (error) {
      console.error('❌ Intelligence-V2 processing failed:', (error as Error).message);
      
      // Fallback to basic processing
      return this.fallbackToBasicProcessing(input);
    }
  }

  private async buildTemporalContext(input: IntelligenceV2Input, userContext?: any): Promise<any> {
    const now = new Date();
    return {
      currentTime: now.toISOString(),
      timeOfDay: this.getTimeOfDay(now),
      dayOfWeek: now.toLocaleDateString('en-US', { weekday: 'long' }),
      userTimezone: userContext?.timezone || 'UTC',
      recentActivity: userContext?.recentActivity || [],
      upcomingEvents: userContext?.upcomingEvents || []
    };
  }

  private generateIntelligentSummary(analysis: RecursiveAnalysis | null): string {
    if (!analysis) {
      return "Basic content analysis completed";
    }
    
    return analysis.immediateProcessing?.understanding?.substring(0, 200) + 
           (analysis.immediateProcessing?.understanding?.length > 200 ? "..." : "");
  }

  private async enhanceContentWithInsights(
    originalContent: string,
    analysis: RecursiveAnalysis | null,
    semanticMatches: any[]
  ): Promise<string> {
    if (!analysis) {
      return originalContent;
    }

    let enhanced = originalContent;
    
    // Add insights from analysis
    const insights = analysis.contextualIntelligence?.patternRecognition;
    if (insights) {
      enhanced += `\n\n**Insights:** ${insights}`;
    }

    // Add related content references
    if (semanticMatches.length > 0) {
      const topMatch = semanticMatches[0];
      enhanced += `\n\n**Related:** ${topMatch.content.substring(0, 100)}...`;
    }

    return enhanced;
  }

  private extractTraditionalOutputs(analysis: RecursiveAnalysis | null) {
    return {
      todos: this.extractTodos(analysis),
      smartActions: this.extractSmartActions(analysis),
      entities: this.extractEntities(analysis),
      suggestedLinks: [],
      nextSteps: this.extractNextSteps(analysis),
      microQuestions: this.extractMicroQuestions(analysis),
      fromTheWeb: [],
      tags: this.extractTags(analysis),
      relatedTopics: this.extractRelatedTopics(analysis)
    };
  }

  private extractTodos(analysis: RecursiveAnalysis | null): ProcessedTodo[] {
    if (!analysis?.proactiveDelivery?.suggestedActions) {
      return [];
    }

    return analysis.proactiveDelivery.suggestedActions
      .filter(action => action.action.includes('todo') || action.action.includes('task'))
      .map(action => ({
        title: action.action,
        priority: action.priority > 7 ? 'high' : action.priority > 5 ? 'medium' : 'low',
        due: undefined,
        isReminder: false
      }));
  }

  private extractSmartActions(analysis: RecursiveAnalysis | null): SmartAction[] {
    if (!analysis?.proactiveDelivery?.suggestedActions) {
      return [];
    }

    return analysis.proactiveDelivery.suggestedActions.map(action => ({
      label: action.action,
      action: action.reasoning
    }));
  }

  private extractEntities(analysis: RecursiveAnalysis | null): Entity[] {
    if (!analysis?.immediateProcessing?.entities) {
      return [];
    }

    return analysis.immediateProcessing.entities.map(entity => ({
      name: entity,
      type: 'general',
      details: undefined
    }));
  }

  private extractNextSteps(analysis: RecursiveAnalysis | null): string[] {
    return analysis?.recursiveReasoning?.step1Anticipation?.potentialActions || [];
  }

  private extractMicroQuestions(analysis: RecursiveAnalysis | null): string[] {
    return analysis?.recursiveReasoning?.step1Anticipation?.followUpQuestions || [];
  }

  private extractTags(analysis: RecursiveAnalysis | null): string[] {
    if (!analysis?.immediateProcessing?.entities) {
      return [];
    }

    return analysis.immediateProcessing.entities
      .map(entity => entity.toLowerCase())
      .filter(tag => tag.length > 2);
  }

  private extractRelatedTopics(analysis: RecursiveAnalysis | null): string[] {
    if (!analysis?.contextualIntelligence?.crossReferences) {
      return [];
    }

    return analysis.contextualIntelligence.crossReferences
      .map(ref => ref.relationship)
      .filter(topic => topic && topic.length > 0);
  }

  private calculateOverallConfidence(analysis: RecursiveAnalysis | null, semanticMatches: any[]): number {
    if (!analysis) return 0.3;
    return Math.min(0.9, 0.5 + (semanticMatches.length * 0.05));
  }

  private determineProcessingPath(analysis: RecursiveAnalysis | null): 'memory' | 'commerce' {
    return analysis?.immediateProcessing?.intent === 'commerce' ? 'commerce' : 'memory';
  }

  private generateClassificationScores(analysis: RecursiveAnalysis | null): Record<string, number> {
    return {
      complexity: analysis?.immediateProcessing?.complexity || 0,
      urgency: this.mapUrgencyToScore(analysis?.immediateProcessing?.urgency || 'medium'),
      confidence: analysis ? 0.8 : 0.3
    };
  }

  private mapUrgencyToScore(urgency: string): number {
    switch (urgency) {
      case 'critical': return 1.0;
      case 'high': return 0.8;
      case 'medium': return 0.6;
      case 'low': return 0.4;
      default: return 0.5;
    }
  }

  private getTimeOfDay(date: Date): string {
    const hour = date.getHours();
    if (hour < 6) return 'early_morning';
    if (hour < 12) return 'morning';
    if (hour < 17) return 'afternoon';
    if (hour < 21) return 'evening';
    return 'night';
  }

  private async fallbackToBasicProcessing(input: IntelligenceV2Input): Promise<IntelligenceV2Result> {
    console.log('⚠️ Using fallback basic processing');
    
    return {
      id: input.id || 'temp',
      title: makeTitle(input.content),
      summary: "Basic processing fallback",
      enhancedContent: input.content,
      intent: 'general',
      urgency: 'medium',
      complexity: 3,
      recursiveAnalysis: {} as RecursiveAnalysis,
      vectorSimilarities: [],
      relationshipInsights: [],
      proactiveRecommendations: { immediate: [], upcoming: [], strategic: [] },
      todos: [],
      smartActions: [],
      entities: [],
      suggestedLinks: [],
      nextSteps: [],
      microQuestions: [],
      fromTheWeb: [],
      tags: [],
      relatedTopics: [],
      confidence: 0.3,
      processingPath: 'memory',
      timestamp: new Date().toISOString(),
      classificationScores: { basic: 1.0 }
    };
  }

  async healthCheck(): Promise<{ status: string; components: Record<string, any> }> {
    const components: Record<string, any> = {};
    let allHealthy = true;

    try {
      // Check vector engine
      await this.vectorEngine.generateDenseEmbedding("test");
      components['vectorEngine'] = { status: 'healthy' };
    } catch (error) {
      components['vectorEngine'] = { status: 'unhealthy', error: (error as Error).message };
      allHealthy = false;
    }

    return {
      status: allHealthy ? 'healthy' : 'degraded',
      components
    };
  }
}```

### server/intelligence-v2/intelligence-router.ts
```typescript
import OpenAI from 'openai';
import { VectorEngine } from './vector-engine.js';
import { RecursiveReasoningEngine } from './recursive-reasoning-engine.js';
import { IntentVectorClassifier, type IntentVector } from './intent-vector-classifier.js';
import { CollectionsExtractor } from './collections-extractor.js';
import { FEATURE_FLAGS } from '../feature-flags-runtime.js';
import { storage } from '../storage.js';
import { makeTitle } from '../utils/title-governor.js';
import { buildPrompt } from '../ai/prompt-specs.js';

export interface IntelligenceV2Input { 
  id?:string; 
  content:string; 
  mode:'text'|'voice'|'image'|'file'; 
  userId?: string;
  userProfile?: any;
}
export interface IntelligenceV2Result { id:string; title:string; original:string; aiBody:string; perspective:string; timestamp:string; }

export class IntelligenceV2Router {
  private vector:VectorEngine; private reason:RecursiveReasoningEngine; private openai:OpenAI;
  constructor(openai:OpenAI){ 
    console.log("IntelligenceV2Router initialized with API key:", openai ? "present" : "missing");
    // Test the OpenAI instance immediately
    this.testAPIConnection(openai);
    this.openai=openai; 
    this.vector=new VectorEngine(openai); 
    this.reason=new RecursiveReasoningEngine(openai,this.vector); 
  }

  private async testAPIConnection(openai: OpenAI) {
    try {
      console.log("Testing OpenAI connection with simple call...");
      const testResponse = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: 'test' }],
        max_tokens: 5
      });
      console.log("✅ OpenAI connection test successful:", testResponse.choices[0].message.content);
    } catch (error: any) {
      console.error("❌ OpenAI connection test failed:", error.message);
      console.error("Status:", error.status);
    }
  }

  async processNoteV2(input:IntelligenceV2Input):Promise<IntelligenceV2Result>{
    const userProfile = input.userProfile || { personalBio: "" };
    
    const prompt = buildPrompt(userProfile.personalBio || "", input.content);
    
    console.log("=== EXACT OPENAI INPUT ===");
    console.log("MODEL:", 'gpt-4o');
    console.log("TEMPERATURE:", 0.4);
    console.log("SYSTEM PROMPT (word-for-word):");
    console.log(prompt);
    console.log("=== END OPENAI INPUT ===");
    
    console.log("=== OPENAI API CALL DEBUG ===");
    console.log("Model: gpt-4o");
    const actualKey = process.env.OPENAI_API_KEY_MIRA || process.env.OPENAI_API_KEY;
    console.log("API Key present:", !!actualKey);
    console.log("API Key first 10 chars:", actualKey?.substring(0, 10) || 'undefined');
    console.log("Prompt length:", prompt.length);
    
    let response;
    try {
      // Use gpt-3.5-turbo with strict JSON mode
      response = await this.openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: 'You are a JSON processor. Respond only with valid JSON.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.1,
        max_tokens: 1500,
        response_format: { type: "json_object" }
      });
      console.log("OpenAI API call successful with JSON mode");
    } catch (apiError: any) {
      console.error("=== OPENAI API ERROR DETAILS ===");
      console.error("Error type:", apiError.constructor.name);
      console.error("Status code:", apiError.status);
      console.error("Error message:", apiError.message);
      console.error("Request ID:", apiError.requestID);
      console.error("Error code:", apiError.code);
      console.error("Error param:", apiError.param);
      console.error("Error type field:", apiError.type);
      
      // Check if it's a 404 indicating model or API key issue
      if (apiError.status === 404) {
        console.error("404 Error - Possible causes:");
        console.error("1. Invalid API key");
        console.error("2. Model 'gpt-4o' not available for this API key");
        console.error("3. API endpoint issue");
        
        // Try with gpt-4o as fallback
        console.log("Attempting fallback to gpt-4o...");
        try {
          response = await this.openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [{ role: 'system', content: prompt }],
            temperature: 0.4,
            max_tokens: 1000
          });
          console.log("Fallback to gpt-4o successful");
        } catch (fallbackError: any) {
          console.error("gpt-4o also failed:", fallbackError.message);
          throw new Error(`OpenAI API access issue: ${apiError.message}. Please verify your API key is valid and has proper model access.`);
        }
      } else {
        throw apiError;
      }
    }
    
    const { choices } = response;
    
    console.log("=== EXACT OPENAI OUTPUT ===");
    console.log("RAW RESPONSE:");
    console.log(choices[0].message!.content);
    console.log("=== END OPENAI OUTPUT ===");
    
    // Robust markdown cleaning
    let cleanResponse = choices[0].message!.content!.trim();
    console.log("=== CLEANING PROCESS ===");
    console.log("Original response length:", cleanResponse.length);
    console.log("First 50 chars:", cleanResponse.substring(0, 50));
    console.log("Last 50 chars:", cleanResponse.substring(cleanResponse.length - 50));
    
    // Remove all markdown wrappers - be more aggressive
    cleanResponse = cleanResponse
      .replace(/^```json\s*/m, '')
      .replace(/^```\s*/m, '')
      .replace(/\s*```\s*$/m, '')
      .trim();
    
    // Additional safety - find the JSON object boundaries
    const jsonStart = cleanResponse.indexOf('{');
    const jsonEnd = cleanResponse.lastIndexOf('}');
    
    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
      cleanResponse = cleanResponse.substring(jsonStart, jsonEnd + 1);
      console.log("Extracted JSON boundaries");
    }
    
    console.log("After cleaning length:", cleanResponse.length);
    console.log("Cleaned first 50 chars:", cleanResponse.substring(0, 50));
    console.log("=== END CLEANING PROCESS ===");
    
    console.log("=== CLEANED RESPONSE ===");
    console.log(cleanResponse);
    console.log("=== END CLEANED RESPONSE ===");
    
    let parsed;
    try {
      parsed = JSON.parse(cleanResponse);
      console.log("=== JSON PARSING SUCCESS ===");
    } catch (parseError) {
      console.error("=== JSON PARSING FAILED ===");
      console.error("Parse error:", parseError.message);
      console.error("Problematic content:", cleanResponse.substring(0, 200));
      throw new Error(`JSON parsing failed: ${parseError.message}`);
    }

    console.log("=== PARSED JSON RESULT ===");
    console.log(JSON.stringify(parsed, null, 2));
    console.log("=== END PARSED RESULT ===");

    if(input.id){ this.vector.updateNoteVectors(Number(input.id),input.content,storage).catch(()=>{}); }

    return{
      id: input.id ?? 'temp',
      timestamp: new Date().toISOString(),
      richContext: parsed,
      ...parsed
    };
  }
}

/* singleton + helper export */
const openai=new OpenAI({apiKey:process.env.OPENAI_API_KEY!});
const singleton=new IntelligenceV2Router(openai);
export async function processWithIntelligenceV2(i:IntelligenceV2Input){ return singleton.processNoteV2(i);}
export default singleton;```

### server/intelligence-v2/intent-vector-classifier.ts
```typescript
import OpenAI from 'openai';
import { z } from 'zod';

export type ActionLabel = 'remind' | 'buy' | 'research' | 'log' | 'schedule' | 'delegate' | 'track';
export interface IntentVector {
  primaryActions: ActionLabel[];
  domainContexts: string[];
  temporalClass: 'immediate' | 'short-term' | 'long-term' | 'evergreen';
  collaborationScope: 'private' | 'shared-internal' | 'shared-external';
  affectTone?: 'neutral' | 'celebratory' | 'sensitive' | 'urgent';
}

const schema = z.object({
  primaryActions: z.array(z.string()).transform(actions => 
    actions.map(action => {
      const actionMap: Record<string, ActionLabel> = {
        'remind': 'remind', 'buy': 'buy', 'research': 'research', 
        'log': 'log', 'schedule': 'schedule', 'delegate': 'delegate', 'track': 'track'
      };
      return actionMap[action.toLowerCase()] || 'research';
    }) as ActionLabel[]
  ),
  domainContexts: z.array(z.string()),
  temporalClass: z.union([z.string(), z.array(z.string())]).transform(val => 
    Array.isArray(val) ? val[0] || 'immediate' : val
  ),
  collaborationScope: z.union([z.string(), z.array(z.string())]).transform(val => 
    Array.isArray(val) ? val[0] || 'private' : val
  ),
  affectTone: z.union([z.string(), z.array(z.string())]).transform(val => 
    Array.isArray(val) ? val[0] || 'neutral' : val
  ).optional()
});

export class IntentVectorClassifier {
  private static openai = new OpenAI();

  static async classify(text: string): Promise<IntentVector> {
    const prompt = `
You are Mira's intent classifier. 
Classify the NOTE into the IntentVector JSON with keys:
primaryActions, domainContexts, temporalClass, collaborationScope, affectTone.
Respond with ONLY valid JSON.
NOTE: """${text}"""
`.trim();

    const chat = await this.openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2
    });

    let raw = chat.choices[0]?.message?.content ?? '{}';
    
    // Strip markdown code blocks if present
    if (raw.startsWith('```json')) {
      raw = raw.replace(/^```json\s*/, '').replace(/\s*```$/, '');
    } else if (raw.startsWith('```')) {
      raw = raw.replace(/^```\s*/, '').replace(/\s*```$/, '');
    }
    
    const parsed = JSON.parse(raw.trim());
    return schema.parse(parsed);
  }
}
```

### server/intelligence-v2/recursive-reasoning-engine.ts
```typescript
/**
 * Intelligence-V2 Recursive Reasoning Engine
 * Implements sophisticated 2-3 step ahead thinking for proactive intelligence
 */

import { VectorEngine, SemanticSearchResult } from './vector-engine.js';

export interface RecursiveAnalysis {
  immediateProcessing: {
    understanding: string;
    entities: Entity[];
    intent: string;
    urgency: 'critical' | 'high' | 'medium' | 'low';
    complexity: number;
    temporalAnalysis: TemporalAnalysis;
  };
  recursiveReasoning: {
    step1Anticipation: StepProjection;
    step2Projection: StepProjection;
    step3Implications: StepProjection;
  };
  contextualIntelligence: {
    crossReferences: CrossReference[];
    patternRecognition: string;
    anomalyDetection: string;
    knowledgeGaps: string[];
    unexpectedConnections: UnexpectedConnection[];
  };
  proactiveDelivery: {
    surfaceImmediately: ProactiveAction[];
    prepareForLater: ProactiveAction[];
    suggestedActions: SuggestedAction[];
    preventiveMeasures: PreventiveMeasure[];
    optimizationSuggestions: OptimizationSuggestion[];
  };
}

export interface Entity {
  name: string;
  type: string;
  relevance: number;
  relationships: string[];
}

export interface TemporalAnalysis {
  explicitTimes: TimeReference[];
  implicitUrgency: string;
  deadlineImplications: string;
  recurringPatterns: string;
}

export interface TimeReference {
  text: string;
  parsed: string;
  confidence: number;
  precision: 'exact' | 'approximate' | 'relative';
}

export interface StepProjection {
  likelyNextNeeds: string[];
  followUpQuestions: string[];
  requiredInformation: string[];
  potentialActions: string[];
  cascadingEffects?: string[];
  optimizationOpportunities?: string[];
  longTermValue?: string;
  learningOpportunities?: string[];
}

export interface CrossReference {
  contentId: string;
  relationship: string;
  strength: number;
  reasoning: string;
}

export interface UnexpectedConnection {
  connection: string;
  value: string;
  confidence: number;
}

export interface ProactiveAction {
  contentId?: string;
  reason: string;
  timing: string;
}

export interface SuggestedAction {
  action: string;
  reasoning: string;
  priority: number;
}

export interface PreventiveMeasure {
  risk: string;
  prevention: string;
  urgency: string;
}

export interface OptimizationSuggestion {
  area: string;
  suggestion: string;
  impact: string;
}

export class RecursiveReasoningEngine {
  private vectorEngine: VectorEngine;
  private openai: any;

  constructor(openaiClient: any, vectorEngine: VectorEngine) {
    this.openai = openaiClient;
    this.vectorEngine = vectorEngine;
  }

  /**
   * Perform comprehensive recursive analysis of input
   */
  async performRecursiveAnalysis(
    input: string,
    userContext: any,
    relatedContent: SemanticSearchResult[],
    temporalContext: any
  ): Promise<RecursiveAnalysis> {
    try {
      const prompt = this.buildRecursivePrompt(input, userContext, relatedContent, temporalContext);
      
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'system', content: prompt }],
        temperature: 0.3,
        response_format: { type: 'json_object' }
      });

      const analysis = JSON.parse(response.choices[0].message.content);
      
      // Enhance with vector-based insights
      const enhancedAnalysis = await this.enhanceWithVectorInsights(analysis, input, relatedContent);
      
      return enhancedAnalysis;
    } catch (error) {
      console.error('Recursive reasoning analysis failed:', error);
      throw new Error('Failed to perform recursive analysis');
    }
  }

  /**
   * Build sophisticated prompt for recursive reasoning
   */
  private buildRecursivePrompt(
    input: string,
    userContext: any,
    relatedContent: SemanticSearchResult[],
    temporalContext: any
  ): string {
    return `
SYSTEM: You are Mira's Advanced Intelligence Core with recursive reasoning capabilities. Process this input thinking 2-3 steps ahead to anticipate user needs and deliver proactive intelligence.

CORE_DIRECTIVE: Think recursively - don't just process what the user said, anticipate what they'll need next and proactively prepare solutions.

ANALYSIS_FRAMEWORK:
1. IMMEDIATE_UNDERSTANDING:
   - Parse content with semantic depth
   - Extract entities, relationships, and implicit context
   - Classify intent with confidence scoring
   - Assess temporal urgency and complexity

2. RECURSIVE_REASONING (Critical - Think Ahead):
   Step 1 Projection: What will the user likely need next?
   Step 2 Projection: What follows after that?
   Step 3 Projection: What are the longer-term implications?

3. CONTEXTUAL_INTELLIGENCE:
   - Cross-reference with user's knowledge base
   - Identify patterns and anomalies
   - Find unexpected but valuable connections
   - Generate predictive insights

4. PROACTIVE_DELIVERY:
   - Surface relevant content before it's requested
   - Anticipate information needs
   - Suggest optimization opportunities
   - Identify and prevent potential issues

USER_INPUT: "${input}"
USER_CONTEXT: ${JSON.stringify(userContext)}
TEMPORAL_STATE: ${JSON.stringify(temporalContext)}
RELATED_CONTENT: ${JSON.stringify(relatedContent.slice(0, 5))}

PROCESSING_RULES:
- Think 2-3 steps ahead of user needs
- Connect disparate information intelligently
- Anticipate follow-up questions and actions
- Identify optimization opportunities proactively
- Surface unexpected but valuable insights
- Maintain temporal awareness and urgency sensitivity

REQUIRED_OUTPUT_STRUCTURE:
{
  "immediateProcessing": {
    "understanding": "Deep semantic comprehension",
    "entities": [{"name": "string", "type": "string", "relevance": 0.95, "relationships": []}],
    "intent": "primary_intent_with_confidence",
    "urgency": "critical|high|medium|low",
    "complexity": 1-10,
    "temporalAnalysis": {
      "explicitTimes": [{"text": "string", "parsed": "ISO_date", "confidence": 0.95, "precision": "exact|approximate|relative"}],
      "implicitUrgency": "assessment of time pressure",
      "deadlineImplications": "impact analysis",
      "recurringPatterns": "detected patterns"
    }
  },
  
  "recursiveReasoning": {
    "step1Anticipation": {
      "likelyNextNeeds": ["anticipated need 1", "anticipated need 2"],
      "followUpQuestions": ["question 1", "question 2"],
      "requiredInformation": ["info need 1", "info need 2"],
      "potentialActions": ["action 1", "action 2"],
      "cascadingEffects": ["effect 1", "effect 2"],
      "optimizationOpportunities": ["opportunity 1", "opportunity 2"],
      "longTermValue": "strategic value",
      "learningOpportunities": ["learning 1", "learning 2"]
    },
    "step2Projection": {
      "likelyNextNeeds": ["subsequent need 1", "subsequent need 2"],
      "followUpQuestions": ["follow-up question 1", "follow-up question 2"],
      "requiredInformation": ["future info need 1", "future info need 2"],
      "potentialActions": ["future action 1", "future action 2"],
      "cascadingEffects": ["effect 1", "effect 2"],
      "optimizationOpportunities": ["opportunity 1", "opportunity 2"],
      "longTermValue": "extended value",
      "learningOpportunities": ["learning 2", "learning 3"]
    },
    "step3Implications": {
      "likelyNextNeeds": ["long-term need 1", "long-term need 2"],
      "followUpQuestions": ["strategic question 1", "strategic question 2"],
      "requiredInformation": ["strategic info 1", "strategic info 2"],
      "potentialActions": ["strategic action 1", "strategic action 2"],
      "cascadingEffects": ["system effect 1", "system effect 2"],
      "optimizationOpportunities": ["strategic optimization 1", "strategic optimization 2"],
      "longTermValue": "transformational value",
      "learningOpportunities": ["strategic learning 1", "strategic learning 2"]
    }
  },
  
  "contextualIntelligence": {
    "crossReferences": [{"contentId": "string", "relationship": "string", "strength": 0.95, "reasoning": "why connected"}],
    "patternRecognition": "identified patterns and their significance",
    "anomalyDetection": "unusual aspects requiring attention",
    "knowledgeGaps": ["gap 1 with research suggestion", "gap 2 with action plan"],
    "unexpectedConnections": [{"connection": "string", "value": "why valuable", "confidence": 0.85}]
  },
  
  "proactiveDelivery": {
    "surface_immediately": [{"content_id": "string", "reason": "specific value proposition", "timing": "now"}],
    "prepare_for_later": [{"content_id": "string", "reason": "anticipated future need", "timing": "ISO_datetime"}],
    "suggested_actions": [{"action": "specific actionable step", "reasoning": "why this helps", "priority": 1-10}],
    "preventive_measures": [{"risk": "identified risk", "prevention": "specific prevention", "urgency": "high|medium|low"}],
    "optimization_suggestions": [{"area": "improvement area", "suggestion": "specific optimization", "impact": "expected benefit"}]
  }
}

CRITICAL: Focus on recursive reasoning - think ahead, anticipate needs, and deliver proactive value.
OUTPUT ONLY JSON:
`;
  }

  /**
   * Enhance analysis with vector-based insights
   */
  private async enhanceWithVectorInsights(
    analysis: any,
    input: string,
    relatedContent: SemanticSearchResult[]
  ): Promise<RecursiveAnalysis> {
    // Ensure contextualIntelligence structure exists with proper camelCase
    if (!analysis.contextualIntelligence) {
      analysis.contextualIntelligence = {
        crossReferences: [],
        patternRecognition: '',
        anomalyDetection: '',
        knowledgeGaps: [],
        unexpectedConnections: []
      };
    }

    // Add vector-based cross-references with safe property access
    const vectorCrossReferences = relatedContent.map(content => ({
      contentId: content.noteId?.toString() || 'unknown',
      relationship: content.reasoning || 'semantic_similarity',
      strength: content.similarity,
      reasoning: `Vector similarity: ${(content.similarity * 100).toFixed(1)}%`
    }));

    // Safely merge with existing cross-references
    analysis.contextualIntelligence.crossReferences = [
      ...(analysis.contextualIntelligence.crossReferences || []),
      ...vectorCrossReferences
    ].slice(0, 10);

    // Add pattern recognition insights
    if (relatedContent.length > 2) {
      analysis.contextualIntelligence.patternRecognition = 
        `Vector analysis reveals ${relatedContent.length} related items suggesting recurring themes.`;
    }

    return analysis as RecursiveAnalysis;
  }

  /**
   * Find unexpected semantic connections between content
   */
  private async findSemanticConnections(
    input: string,
    relatedContent: SemanticSearchResult[]
  ): Promise<UnexpectedConnection[]> {
    const connections: UnexpectedConnection[] = [];

    // Look for non-obvious but valuable connections
    for (const content of relatedContent.slice(0, 3)) {
      if (content.similarity > 0.4 && content.similarity < 0.7) {
        // Mid-range similarity might indicate unexpected connections
        connections.push({
          connection: `Semantic bridge between "${input}" and previous note "${content.content.substring(0, 50)}..."`,
          value: `Provides complementary perspective or background context`,
          confidence: content.similarity
        });
      }
    }

    return connections;
  }

  /**
   * Predict next user actions based on patterns
   */
  async predictNextActions(
    currentInput: string,
    userHistory: any[],
    analysis: RecursiveAnalysis
  ): Promise<string[]> {
    try {
      const prompt = `
SYSTEM: Predict the next 3 most likely actions this user will take based on their current input and historical patterns.

CURRENT_INPUT: "${currentInput}"
USER_PATTERNS: ${JSON.stringify(userHistory.slice(0, 10))}
ANALYSIS_CONTEXT: ${JSON.stringify(analysis.immediateProcessing)}

Provide 3 specific, actionable predictions of what the user will likely do next.
Consider their typical workflows, timing patterns, and context.

OUTPUT JSON:
{
  "predictions": [
    "specific action prediction 1",
    "specific action prediction 2", 
    "specific action prediction 3"
  ]
}
`;

      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'system', content: prompt }],
        temperature: 0.2,
        response_format: { type: 'json_object' }
      });

      const predictions = JSON.parse(response.choices[0].message.content);
      return predictions.predictions || [];
    } catch (error) {
      console.error('Action prediction failed:', error);
      return [];
    }
  }

  /**
   * Generate proactive recommendations based on recursive analysis
   */
  generateProactiveRecommendations(analysis: RecursiveAnalysis): {
    immediate: string[];
    upcoming: string[];
    strategic: string[];
  } {
    // Safe property access with comprehensive fallbacks
    if (!analysis) {
      return { immediate: [], upcoming: [], strategic: [] };
    }

    const immediate = analysis.proactiveDelivery?.suggestedActions
      ?.filter((action: any) => action.priority >= 8)
      ?.map((action: any) => action.action) || [];
    
    const upcoming = [
      ...(analysis.recursiveReasoning?.step1Anticipation?.potentialActions || []),
      ...(analysis.recursiveReasoning?.step2Projection?.potentialActions || [])
    ].slice(0, 5);
    
    const strategic = analysis.recursiveReasoning?.step3Implications?.potentialActions || [];

    return {
      immediate,
      upcoming,
      strategic
    };
  }

  /**
   * Assess the quality and confidence of recursive analysis
   */
  assessAnalysisQuality(analysis: RecursiveAnalysis): {
    overallConfidence: number;
    reasoningDepth: number;
    proactiveValue: number;
    recommendations: string[];
  } {
    // Calculate confidence based on various factors
    const entityConfidence = analysis.immediateProcessing?.entities
      ?.reduce((sum: number, entity: any) => sum + (entity.relevance || 0), 0) / (analysis.immediateProcessing?.entities?.length || 1) || 0;
    
    const crossReferenceStrength = analysis.contextualIntelligence?.crossReferences
      ?.reduce((sum: number, ref: any) => sum + (ref.strength || 0), 0) / (analysis.contextualIntelligence?.crossReferences?.length || 1) || 0;
    
    const reasoningDepth = 
      (analysis.recursiveReasoning?.step1Anticipation?.likelyNextNeeds?.length || 0) +
      (analysis.recursiveReasoning?.step2Projection?.likelyNextNeeds?.length || 0) +
      (analysis.recursiveReasoning?.step3Implications?.likelyNextNeeds?.length || 0);
    
    const proactiveValue = 
      (analysis.proactiveDelivery?.suggestedActions?.length || 0) +
      (analysis.proactiveDelivery?.preventiveMeasures?.length || 0) +
      (analysis.proactiveDelivery?.optimizationSuggestions?.length || 0);

    const overallConfidence = (entityConfidence + crossReferenceStrength) / 2;

    const recommendations = [];
    if (overallConfidence < 0.6) {
      recommendations.push("Consider gathering more context for higher confidence analysis");
    }
    if (reasoningDepth < 6) {
      recommendations.push("Recursive reasoning could be deeper - consider more projection steps");
    }
    if (proactiveValue < 3) {
      recommendations.push("Limited proactive value identified - explore more anticipatory suggestions");
    }

    return {
      overallConfidence,
      reasoningDepth,
      proactiveValue,
      recommendations
    };
  }
}```

### server/intelligence-v2/relationship-mapper.ts
```typescript
/**
 * Intelligence-V2 Relationship Mapper
 * Builds and maintains contextual relationships between notes, entities, and concepts
 */

import { VectorEngine, SemanticSearchResult } from './vector-engine.js';

export interface Relationship {
  id: string;
  sourceId: string;
  targetId: string;
  type: RelationshipType;
  strength: number;
  context: string;
  confidence: number;
  discoveredAt: Date;
  lastVerified: Date;
}

export enum RelationshipType {
  SEMANTIC = 'semantic',
  TEMPORAL = 'temporal',
  CAUSAL = 'causal',
  REFERENCE = 'reference',
  UPDATE = 'update',
  CONTINUATION = 'continuation',
  CONTRADICTION = 'contradiction',
  SUPPORTS = 'supports',
  DEPENDS_ON = 'depends_on',
  TRIGGERS = 'triggers'
}

export interface RelationshipGraph {
  nodes: GraphNode[];
  edges: GraphEdge[];
  clusters: NodeCluster[];
}

export interface GraphNode {
  id: string;
  type: 'note' | 'entity' | 'concept' | 'todo' | 'collection';
  label: string;
  weight: number;
  metadata: Record<string, any>;
}

export interface GraphEdge {
  source: string;
  target: string;
  type: RelationshipType;
  weight: number;
  metadata: Record<string, any>;
}

export interface NodeCluster {
  id: string;
  nodes: string[];
  theme: string;
  strength: number;
  suggestedActions: string[];
}

export class RelationshipMapper {
  private vectorEngine: VectorEngine;
  private openai: any;
  private relationships: Map<string, Relationship[]> = new Map();

  constructor(openaiClient: any, vectorEngine: VectorEngine) {
    this.openai = openaiClient;
    this.vectorEngine = vectorEngine;
  }

  /**
   * Analyze and map relationships for a new note
   */
  async mapRelationships(
    noteId: string,
    content: string,
    allNotes: any[],
    storage: any
  ): Promise<Relationship[]> {
    try {
      // Get semantic matches
      const semanticMatches = await this.vectorEngine.performSemanticSearch(
        { query: content, limit: 20 },
        allNotes.filter(note => note.id.toString() !== noteId)
      );

      // Find temporal relationships
      const temporalRelationships = await this.findTemporalRelationships(
        noteId,
        content,
        allNotes
      );

      // Detect update relationships
      const updateRelationships = await this.detectUpdateRelationships(
        noteId,
        content,
        semanticMatches
      );

      // Find causal relationships
      const causalRelationships = await this.findCausalRelationships(
        noteId,
        content,
        semanticMatches
      );

      // Combine all relationships
      const allRelationships = [
        ...this.createSemanticRelationships(noteId, semanticMatches),
        ...temporalRelationships,
        ...updateRelationships,
        ...causalRelationships
      ];

      // Store relationships
      this.relationships.set(noteId, allRelationships);

      // Persist to storage if available
      if (storage && storage.storeRelationships) {
        await storage.storeRelationships(noteId, allRelationships);
      }

      return allRelationships;
    } catch (error) {
      console.error(`Failed to map relationships for note ${noteId}:`, error);
      return [];
    }
  }

  /**
   * Create semantic relationships from vector search results
   */
  private createSemanticRelationships(
    noteId: string,
    semanticMatches: SemanticSearchResult[]
  ): Relationship[] {
    return semanticMatches
      .filter(match => match.similarity > 0.4)
      .map(match => ({
        id: `${noteId}-${match.noteId}-semantic`,
        sourceId: noteId,
        targetId: match.noteId.toString(),
        type: RelationshipType.SEMANTIC,
        strength: match.similarity,
        context: match.reasoning,
        confidence: match.similarity,
        discoveredAt: new Date(),
        lastVerified: new Date()
      }));
  }

  /**
   * Find temporal relationships based on time references and patterns
   */
  private async findTemporalRelationships(
    noteId: string,
    content: string,
    allNotes: any[]
  ): Promise<Relationship[]> {
    const relationships: Relationship[] = [];

    try {
      const timeAnalysis = await this.analyzeTemporalContent(content);
      
      if (timeAnalysis.hasTimeReferences) {
        // Find notes with similar time patterns
        const timeRelatedNotes = allNotes.filter(note => {
          if (note.id.toString() === noteId) return false;
          return this.hasTemporalOverlap(timeAnalysis, note);
        });

        timeRelatedNotes.forEach(note => {
          relationships.push({
            id: `${noteId}-${note.id}-temporal`,
            sourceId: noteId,
            targetId: note.id.toString(),
            type: RelationshipType.TEMPORAL,
            strength: 0.7,
            context: `Shares temporal context with note ${note.id}`,
            confidence: 0.8,
            discoveredAt: new Date(),
            lastVerified: new Date()
          });
        });
      }
    } catch (error) {
      console.error('Temporal relationship analysis failed:', error);
    }

    return relationships;
  }

  /**
   * Detect update relationships (when content modifies existing notes)
   */
  private async detectUpdateRelationships(
    noteId: string,
    content: string,
    semanticMatches: SemanticSearchResult[]
  ): Promise<Relationship[]> {
    const relationships: Relationship[] = [];

    // Look for high-similarity matches that might be updates
    const potentialUpdates = semanticMatches.filter(match => 
      match.similarity > 0.8 && this.hasUpdateSignals(content)
    );

    for (const match of potentialUpdates) {
      const updateAnalysis = await this.analyzeUpdateRelationship(content, match.content);
      
      if (updateAnalysis.isUpdate) {
        relationships.push({
          id: `${noteId}-${match.noteId}-update`,
          sourceId: noteId,
          targetId: match.noteId.toString(),
          type: RelationshipType.UPDATE,
          strength: updateAnalysis.confidence,
          context: updateAnalysis.reasoning,
          confidence: updateAnalysis.confidence,
          discoveredAt: new Date(),
          lastVerified: new Date()
        });
      }
    }

    return relationships;
  }

  /**
   * Find causal relationships (cause and effect connections)
   */
  private async findCausalRelationships(
    noteId: string,
    content: string,
    semanticMatches: SemanticSearchResult[]
  ): Promise<Relationship[]> {
    const relationships: Relationship[] = [];

    try {
      const causalSignals = this.detectCausalSignals(content);
      
      if (causalSignals.hasCausalLanguage) {
        const relevantMatches = semanticMatches.filter(match => match.similarity > 0.5);
        
        for (const match of relevantMatches) {
          const causalAnalysis = await this.analyzeCausalRelationship(content, match.content);
          
          if (causalAnalysis.hasCausalConnection) {
            relationships.push({
              id: `${noteId}-${match.noteId}-causal`,
              sourceId: noteId,
              targetId: match.noteId.toString(),
              type: causalAnalysis.direction === 'forward' ? RelationshipType.TRIGGERS : RelationshipType.DEPENDS_ON,
              strength: causalAnalysis.strength,
              context: causalAnalysis.explanation,
              confidence: causalAnalysis.confidence,
              discoveredAt: new Date(),
              lastVerified: new Date()
            });
          }
        }
      }
    } catch (error) {
      console.error('Causal relationship analysis failed:', error);
    }

    return relationships;
  }

  /**
   * Build relationship graph for visualization and analysis
   */
  buildRelationshipGraph(noteIds: string[]): RelationshipGraph {
    const nodes: GraphNode[] = [];
    const edges: GraphEdge[] = [];
    const processedNodes = new Set<string>();

    // Build nodes and edges from relationships
    noteIds.forEach(noteId => {
      const noteRelationships = this.relationships.get(noteId) || [];
      
      // Add source node if not already processed
      if (!processedNodes.has(noteId)) {
        nodes.push({
          id: noteId,
          type: 'note',
          label: `Note ${noteId}`,
          weight: noteRelationships.length,
          metadata: { relationshipCount: noteRelationships.length }
        });
        processedNodes.add(noteId);
      }

      // Add relationships as edges
      noteRelationships.forEach(rel => {
        // Add target node if not already processed
        if (!processedNodes.has(rel.targetId)) {
          nodes.push({
            id: rel.targetId,
            type: 'note',
            label: `Note ${rel.targetId}`,
            weight: 1,
            metadata: {}
          });
          processedNodes.add(rel.targetId);
        }

        // Add edge
        edges.push({
          source: rel.sourceId,
          target: rel.targetId,
          type: rel.type,
          weight: rel.strength,
          metadata: {
            context: rel.context,
            confidence: rel.confidence,
            discoveredAt: rel.discoveredAt
          }
        });
      });
    });

    // Identify clusters
    const clusters = this.identifyClusters(nodes, edges);

    return { nodes, edges, clusters };
  }

  /**
   * Get relationships for a specific note
   */
  getRelationships(noteId: string): Relationship[] {
    return this.relationships.get(noteId) || [];
  }

  /**
   * Find strongest relationships across all notes
   */
  getStrongestRelationships(limit: number = 10): Relationship[] {
    const allRelationships: Relationship[] = [];
    
    this.relationships.forEach(relationships => {
      allRelationships.push(...relationships);
    });

    return allRelationships
      .sort((a, b) => b.strength - a.strength)
      .slice(0, limit);
  }

  /**
   * Private helper methods
   */

  private async analyzeTemporalContent(content: string): Promise<any> {
    const timePatterns = [
      /\b(?:today|tomorrow|yesterday)\b/i,
      /\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b/i,
      /\b\d{1,2}:\d{2}\s*(?:am|pm)?\b/i,
      /\b(?:next|last)\s+(?:week|month|year)\b/i
    ];

    const hasTimeReferences = timePatterns.some(pattern => pattern.test(content));
    
    return {
      hasTimeReferences,
      timeReferences: content.match(/\b(?:\d{1,2}:\d{2}|\w+day)\b/gi) || []
    };
  }

  private hasTemporalOverlap(timeAnalysis: any, note: any): boolean {
    // Simple overlap detection - can be enhanced
    return timeAnalysis.timeReferences.some((timeRef: string) => 
      note.content.toLowerCase().includes(timeRef.toLowerCase())
    );
  }

  private hasUpdateSignals(content: string): boolean {
    const updateSignals = [
      /\b(?:update|change|modify|correct|fix)\b/i,
      /\b(?:actually|instead|rather)\b/i,
      /\b(?:new|latest|revised)\b/i
    ];

    return updateSignals.some(signal => signal.test(content));
  }

  private async analyzeUpdateRelationship(newContent: string, existingContent: string): Promise<any> {
    try {
      const prompt = `
Analyze if the new content is an update to the existing content.

EXISTING: "${existingContent}"
NEW: "${newContent}"

Determine:
1. Is this an update/modification?
2. Confidence level (0-1)
3. Type of update
4. Reasoning

OUTPUT JSON:
{
  "isUpdate": boolean,
  "confidence": number,
  "updateType": "correction|addition|replacement|enhancement",
  "reasoning": "explanation"
}
`;

      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'system', content: prompt }],
        temperature: 0.1,
        response_format: { type: 'json_object' }
      });

      return JSON.parse(response.choices[0].message.content);
    } catch (error) {
      return { isUpdate: false, confidence: 0, reasoning: 'Analysis failed' };
    }
  }

  private detectCausalSignals(content: string): any {
    const causalPatterns = [
      /\b(?:because|since|due to|caused by)\b/i,
      /\b(?:therefore|thus|consequently|as a result)\b/i,
      /\b(?:leads to|results in|triggers|enables)\b/i,
      /\b(?:if|when|after|before)\b.*\b(?:then|will|would)\b/i
    ];

    const hasCausalLanguage = causalPatterns.some(pattern => pattern.test(content));
    
    return {
      hasCausalLanguage,
      patterns: causalPatterns.filter(pattern => pattern.test(content))
    };
  }

  private async analyzeCausalRelationship(content1: string, content2: string): Promise<any> {
    try {
      const prompt = `
Analyze the causal relationship between these two pieces of content.

CONTENT 1: "${content1}"
CONTENT 2: "${content2}"

Determine:
1. Is there a causal connection?
2. Direction (which causes which)
3. Strength (0-1)
4. Explanation

OUTPUT JSON:
{
  "hasCausalConnection": boolean,
  "direction": "forward|backward|bidirectional",
  "strength": number,
  "confidence": number,
  "explanation": "reasoning"
}
`;

      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'system', content: prompt }],
        temperature: 0.1,
        response_format: { type: 'json_object' }
      });

      return JSON.parse(response.choices[0].message.content);
    } catch (error) {
      return { hasCausalConnection: false, strength: 0, explanation: 'Analysis failed' };
    }
  }

  private identifyClusters(nodes: GraphNode[], edges: GraphEdge[]): NodeCluster[] {
    // Simple clustering based on relationship density
    const clusters: NodeCluster[] = [];
    const processedNodes = new Set<string>();

    nodes.forEach(node => {
      if (processedNodes.has(node.id)) return;

      const connectedNodes = this.findConnectedNodes(node.id, edges);
      if (connectedNodes.length >= 2) {
        clusters.push({
          id: `cluster-${clusters.length}`,
          nodes: [node.id, ...connectedNodes],
          theme: `Related content cluster ${clusters.length + 1}`,
          strength: connectedNodes.length,
          suggestedActions: [`Review cluster of ${connectedNodes.length + 1} related items`]
        });

        connectedNodes.forEach(nodeId => processedNodes.add(nodeId));
        processedNodes.add(node.id);
      }
    });

    return clusters;
  }

  private findConnectedNodes(nodeId: string, edges: GraphEdge[]): string[] {
    const connected = new Set<string>();
    
    edges.forEach(edge => {
      if (edge.source === nodeId) {
        connected.add(edge.target);
      } else if (edge.target === nodeId) {
        connected.add(edge.source);
      }
    });

    return Array.from(connected);
  }
}```

### server/intelligence-v2/vector-engine.ts
```typescript
/**
 * Intelligence-V2 Vector Engine
 * Handles dense and sparse vector operations for semantic search and relationship mapping
 */

export interface VectorEmbedding {
  dense: number[];
  sparse?: Record<string, number>;
  metadata: {
    model: string;
    dimensions: number;
    confidence: number;
    timestamp: Date;
  };
}

export interface SemanticSearchResult {
  noteId: number;
  content: string;
  similarity: number;
  reasoning: string;
  relationships: string[];
}

export interface VectorSearchQuery {
  query: string;
  embedding?: VectorEmbedding;
  filters?: {
    timeRange?: { start: Date; end: Date };
    collections?: number[];
    contentTypes?: string[];
    minSimilarity?: number;
  };
  limit?: number;
}

import OpenAI from 'openai';

export class VectorEngine {
  private openai: OpenAI;

  constructor(openaiClient: OpenAI) {
    this.openai = openaiClient;
  }

  /**
   * Generate dense vector embedding using OpenAI text-embedding-3-large
   */
  async generateDenseEmbedding(text: string): Promise<VectorEmbedding> {
    try {
      const response = await this.openai.embeddings.create({
        model: 'text-embedding-3-large',
        input: text,
        encoding_format: 'float'
      });

      return {
        dense: response.data[0].embedding,
        metadata: {
          model: 'text-embedding-3-large',
          dimensions: response.data[0].embedding.length,
          confidence: 1.0,
          timestamp: new Date()
        }
      };
    } catch (error) {
      console.error('Failed to generate dense embedding:', error);
      throw new Error('Vector embedding generation failed');
    }
  }

  /**
   * Generate sparse vector for keyword-based matching
   */
  generateSparseEmbedding(text: string): Record<string, number> {
    const words = text.toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 2);

    const frequencies: Record<string, number> = {};
    const totalWords = words.length;

    // Calculate TF (Term Frequency)
    words.forEach(word => {
      frequencies[word] = (frequencies[word] || 0) + 1;
    });

    // Normalize to TF scores
    Object.keys(frequencies).forEach(word => {
      frequencies[word] = frequencies[word] / totalWords;
    });

    return frequencies;
  }

  /**
   * Calculate cosine similarity between dense vectors
   */
  calculateCosineSimilarity(vectorA: number[], vectorB: number[]): number {
    if (vectorA.length !== vectorB.length) {
      throw new Error('Vector dimensions must match');
    }

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < vectorA.length; i++) {
      dotProduct += vectorA[i] * vectorB[i];
      normA += vectorA[i] * vectorA[i];
      normB += vectorB[i] * vectorB[i];
    }

    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);

    if (normA === 0 || normB === 0) {
      return 0;
    }

    return dotProduct / (normA * normB);
  }

  /**
   * Calculate sparse vector similarity using Jaccard coefficient
   */
  calculateSparseSimilarity(sparseA: Record<string, number>, sparseB: Record<string, number>): number {
    const keysAArray = Object.keys(sparseA);
    const keysBArray = Object.keys(sparseB);
    
    const intersection = keysAArray.filter(x => keysBArray.includes(x));
    const allKeys = keysAArray.concat(keysBArray);
    const uniqueKeys: string[] = [];
    const seen = new Set<string>();
    
    for (const key of allKeys) {
      if (!seen.has(key)) {
        seen.add(key);
        uniqueKeys.push(key);
      }
    }
    const union = uniqueKeys;

    if (union.length === 0) return 0;
    return intersection.length / union.length;
  }

  /**
   * Hybrid search combining dense and sparse similarities
   */
  calculateHybridSimilarity(
    denseA: number[], 
    denseB: number[],
    sparseA: Record<string, number>,
    sparseB: Record<string, number>,
    denseWeight: number = 0.7
  ): number {
    const denseSim = this.calculateCosineSimilarity(denseA, denseB);
    const sparseSim = this.calculateSparseSimilarity(sparseA, sparseB);
    
    return (denseSim * denseWeight) + (sparseSim * (1 - denseWeight));
  }

  /**
   * Perform semantic search across notes using hybrid approach
   */
  async performSemanticSearch(
    query: VectorSearchQuery,
    existingNotes: Array<{
      id: number;
      content: string;
      vectorDense?: string;
      vectorSparse?: string;
    }>
  ): Promise<SemanticSearchResult[]> {
    // Generate query embedding if not provided
    let queryEmbedding = query.embedding;
    if (!queryEmbedding) {
      queryEmbedding = await this.generateDenseEmbedding(query.query);
    }

    const querySparse = this.generateSparseEmbedding(query.query);
    const results: SemanticSearchResult[] = [];

    for (const note of existingNotes) {
      try {
        // pgvector comes out like '{0.12,0.34,…}' – convert to number[]
        let noteDense: number[] | null = null;
        if (note.vectorDense) {
          const trimmed = note.vectorDense.replace(/[{}]/g, '');
          noteDense = trimmed.split(',').map(Number);
        }
        
        const noteSparse = note.vectorSparse ? JSON.parse(note.vectorSparse) : {};

        if (!noteDense) continue; // Skip notes without dense vectors

        // Calculate hybrid similarity
        const similarity = this.calculateHybridSimilarity(
          queryEmbedding.dense,
          noteDense,
          querySparse,
          noteSparse
        );

        // Apply minimum similarity filter
        const minSimilarity = query.filters?.minSimilarity || 0.3;
        if (similarity < minSimilarity) continue;

        // Generate reasoning for the match
        const reasoning = this.generateMatchReasoning(similarity, query.query, note.content);

        results.push({
          noteId: note.id,
          content: note.content,
          similarity,
          reasoning,
          relationships: [] // To be enhanced with relationship mapping
        });
      } catch (error) {
        console.error(`Error processing note ${note.id} for semantic search:`, error);
        continue;
      }
    }

    // Sort by similarity and apply limit
    results.sort((a, b) => b.similarity - a.similarity);
    const limit = query.limit || 10;
    return results.slice(0, limit);
  }

  /**
   * Generate human-readable reasoning for similarity matches
   */
  private generateMatchReasoning(similarity: number, query: string, content: string): string {
    if (similarity > 0.8) {
      return `Very high semantic similarity - content directly relates to "${query}"`;
    } else if (similarity > 0.6) {
      return `Strong conceptual connection found with "${query}"`;
    } else if (similarity > 0.4) {
      return `Moderate relevance detected through shared concepts`;
    } else {
      return `Weak but potentially useful connection identified`;
    }
  }

  /**
   * Update note vectors in database
   */
  async updateNoteVectors(noteId: number, content: string, storage: any): Promise<void> {
    try {
      // Generate both dense and sparse vectors
      const denseEmbedding = await this.generateDenseEmbedding(content);
      const sparseEmbedding = this.generateSparseEmbedding(content);

      // Convert vectors to pgvector literal  '{1,2,3}'
      const denseVector = `{${denseEmbedding.dense.join(',')}}`;
      const sparseVector = JSON.stringify(sparseEmbedding);   // still JSON

      // Update note with vector data
      await storage.updateNote(noteId, {
        vectorDense: denseVector,
        vectorSparse: sparseVector
      });

      console.log(`Updated vectors for note ${noteId}`);
    } catch (error) {
      console.error(`Failed to update vectors for note ${noteId}:`, error);
      throw error;
    }
  }

  /**
   * Batch process existing notes to generate vectors
   */
  async batchProcessVectors(storage: any, batchSize: number = 10): Promise<void> {
    try {
      console.log('Starting batch vector processing...');
      
      // Get notes without vectors
      const notes = await storage.getAllNotes();
      const notesToProcess = notes.filter((note: any) => !note.vectorDense);

      console.log(`Processing ${notesToProcess.length} notes in batches of ${batchSize}`);

      for (let i = 0; i < notesToProcess.length; i += batchSize) {
        const batch = notesToProcess.slice(i, i + batchSize);
        
        await Promise.all(
          batch.map((note: any) => this.updateNoteVectors(note.id, note.content, storage))
        );

        console.log(`Processed batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(notesToProcess.length / batchSize)}`);
        
        // Add delay to avoid rate limiting
        if (i + batchSize < notesToProcess.length) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      console.log('Batch vector processing completed');
    } catch (error) {
      console.error('Batch vector processing failed:', error);
      throw error;
    }
  }
}```

### server/notification-system.ts
```typescript

import { storage } from "./storage";
import type { Todo } from "@shared/schema";

interface NotificationSchedule {
  todoId: number;
  title: string;
  scheduledTime: Date;
  type: 'immediate' | 'before' | 'recurring';
  leadTime?: string; // e.g., "15 minutes", "1 hour", "1 day"
}

class NotificationSystem {
  private scheduledNotifications: Map<number, NotificationSchedule[]> = new Map();
  private notificationInterval: NodeJS.Timeout | null = null;

  constructor() {
    this.startNotificationChecker();
  }

  /**
   * Start the notification checking system
   */
  startNotificationChecker() {
    // Check for due notifications every minute
    this.notificationInterval = setInterval(async () => {
      await this.checkAndSendNotifications();
    }, 60000); // 60 seconds

    console.log("📬 Notification system started - checking every minute");
  }

  /**
   * Stop the notification system
   */
  stopNotificationChecker() {
    if (this.notificationInterval) {
      clearInterval(this.notificationInterval);
      this.notificationInterval = null;
    }
  }

  /**
   * Schedule notifications for a todo/reminder
   */
  async scheduleNotifications(todo: Todo) {
    if (!todo.isActiveReminder || !todo.timeDue) {
      return; // Only schedule for active reminders with due times
    }

    const schedules: NotificationSchedule[] = [];
    const dueTime = new Date(todo.timeDue);
    const now = new Date();

    // Skip if due time is in the past
    if (dueTime <= now) {
      console.log(`⏰ Skipping notification for past due reminder: ${todo.title}`);
      return;
    }

    // Parse notification structure
    const notificationConfig = todo.plannedNotificationStructure;
    if (notificationConfig?.enabled && notificationConfig.leadTimeNotifications) {
      
      for (const leadTimeStr of notificationConfig.leadTimeNotifications) {
        const leadTimeMs = this.parseLeadTime(leadTimeStr);
        if (leadTimeMs > 0) {
          const notificationTime = new Date(dueTime.getTime() - leadTimeMs);
          
          // Only schedule if notification time is in the future
          if (notificationTime > now) {
            schedules.push({
              todoId: todo.id,
              title: todo.title,
              scheduledTime: notificationTime,
              type: 'before',
              leadTime: leadTimeStr
            });
          }
        }
      }
    }

    // Schedule notification at due time
    schedules.push({
      todoId: todo.id,
      title: todo.title,
      scheduledTime: dueTime,
      type: 'immediate'
    });

    this.scheduledNotifications.set(todo.id, schedules);
    
    console.log(`📅 Scheduled ${schedules.length} notifications for: ${todo.title}`);
    schedules.forEach(schedule => {
      console.log(`  - ${schedule.type}: ${schedule.scheduledTime.toLocaleString()}`);
    });
  }

  /**
   * Parse lead time string to milliseconds
   */
  private parseLeadTime(leadTimeStr: string): number {
    const patterns = [
      { regex: /(\d+)\s*minutes?\s*before/i, multiplier: 60 * 1000 },
      { regex: /(\d+)\s*hours?\s*before/i, multiplier: 60 * 60 * 1000 },
      { regex: /(\d+)\s*days?\s*before/i, multiplier: 24 * 60 * 60 * 1000 },
      { regex: /(\d+)\s*weeks?\s*before/i, multiplier: 7 * 24 * 60 * 60 * 1000 },
      { regex: /(\d+)\s*min/i, multiplier: 60 * 1000 },
      { regex: /(\d+)\s*hr/i, multiplier: 60 * 60 * 1000 }
    ];

    for (const pattern of patterns) {
      const match = leadTimeStr.match(pattern.regex);
      if (match) {
        const value = parseInt(match[1]);
        return value * pattern.multiplier;
      }
    }

    return 0; // Invalid format
  }

  /**
   * Check for due notifications and send them
   */
  private async checkAndSendNotifications() {
    const now = new Date();
    const notifications: NotificationSchedule[] = [];

    // Collect all due notifications
    for (const [todoId, schedules] of this.scheduledNotifications.entries()) {
      const dueNotifications = schedules.filter(schedule => 
        schedule.scheduledTime <= now
      );

      notifications.push(...dueNotifications);

      // Remove sent notifications from schedule
      if (dueNotifications.length > 0) {
        const remainingSchedules = schedules.filter(schedule => 
          schedule.scheduledTime > now
        );
        
        if (remainingSchedules.length > 0) {
          this.scheduledNotifications.set(todoId, remainingSchedules);
        } else {
          this.scheduledNotifications.delete(todoId);
        }
      }
    }

    // Send notifications
    for (const notification of notifications) {
      await this.sendNotification(notification);
    }

    if (notifications.length > 0) {
      console.log(`📬 Sent ${notifications.length} notifications`);
    }
  }

  /**
   * Send a notification (placeholder for various notification methods)
   */
  private async sendNotification(notification: NotificationSchedule) {
    console.log(`🔔 NOTIFICATION: ${notification.title}`);
    console.log(`   Type: ${notification.type}`);
    console.log(`   Time: ${notification.scheduledTime.toLocaleString()}`);
    
    if (notification.leadTime) {
      console.log(`   Lead time: ${notification.leadTime}`);
    }

    // Here you would integrate with:
    // - Web Push API for browser notifications
    // - Service Worker for PWA notifications
    // - Email notifications
    // - SMS notifications
    // - WebSocket for real-time updates
    
    // For now, we'll update the todo with notification metadata
    try {
      await storage.updateTodo(notification.todoId, {
        lastNotificationSent: new Date(),
        nextNotificationDue: this.calculateNextNotification(notification)
      });
    } catch (error) {
      console.error("Error updating todo notification metadata:", error);
    }
  }

  /**
   * Calculate next notification time for recurring reminders
   */
  private calculateNextNotification(notification: NotificationSchedule): Date | undefined {
    const todo = storage.getTodos().then(todos => 
      todos.find(t => t.id === notification.todoId)
    );

    // TODO: Implement recurring notification logic based on repeatPattern
    return undefined;
  }

  /**
   * Refresh notifications by reloading all active reminders
   */
  async refreshNotifications() {
    console.log("🔄 Refreshing notification schedules...");
    
    // Clear existing schedules
    this.scheduledNotifications.clear();

    // Get all active reminders
    const todos = await storage.getTodos();
    console.log(`📋 Total todos fetched: ${todos.length}`);
    
    // Debug: Show first few todos with their reminder status
    todos.slice(0, 5).forEach(todo => {
      console.log(`🔍 Todo: "${todo.title}" - isActiveReminder: ${todo.isActiveReminder} (type: ${typeof todo.isActiveReminder}) - timeDue: ${todo.timeDue}`);
    });
    
    const activeReminders = todos.filter(todo => {
      const isActive = todo.isActiveReminder === true;
      const notCompleted = !todo.completed;
      const notArchived = !todo.archived;
      const hasDueTime = todo.timeDue != null;
      
      if (isActive) {
        console.log(`📝 Active reminder found: "${todo.title}" - Due: ${todo.timeDue} - Completed: ${todo.completed} - Archived: ${todo.archived}`);
      }
      
      return isActive && notCompleted && notArchived;
    });

    console.log(`📋 Found ${activeReminders.length} active reminders to schedule`);

    // Schedule notifications for each active reminder
    for (const reminder of activeReminders) {
      console.log(`📅 Scheduling notifications for: "${reminder.title}"`);
      await this.scheduleNotifications(reminder);
    }

    console.log(`📅 Total scheduled notification sets: ${this.scheduledNotifications.size}`);
  }

  /**
   * Get current notification status
   */
  getNotificationStatus() {
    const totalScheduled = Array.from(this.scheduledNotifications.values())
      .reduce((total, schedules) => total + schedules.length, 0);

    return {
      activeReminders: this.scheduledNotifications.size,
      totalScheduledNotifications: totalScheduled,
      nextNotification: this.getNextNotification()
    };
  }

  /**
   * Get the next upcoming notification
   */
  private getNextNotification(): NotificationSchedule | null {
    let earliest: NotificationSchedule | null = null;

    for (const schedules of this.scheduledNotifications.values()) {
      for (const schedule of schedules) {
        if (!earliest || schedule.scheduledTime < earliest.scheduledTime) {
          earliest = schedule;
        }
      }
    }

    return earliest;
  }
}

// Export singleton instance
export const notificationSystem = new NotificationSystem();

// Initialize on server start
export async function initializeNotificationSystem() {
  console.log("🚀 Initializing notification system...");
  await notificationSystem.refreshNotifications();
  
  const status = notificationSystem.getNotificationStatus();
  console.log("📊 Notification system status:", status);
  
  if (status.nextNotification) {
    console.log(`⏰ Next notification: "${status.nextNotification.title}" at ${status.nextNotification.scheduledTime.toLocaleString()}`);
  }
}
```

### server/onboarding-questions.ts
```typescript
export const onboardingQuestions = {
  basic: [
    {
      id: 'name',
      question: 'What should I call you?',
      placeholder: 'Your preferred name...',
      category: 'identity'
    },
    {
      id: 'role',
      question: 'What do you do for work or study?',
      placeholder: 'Your profession, role, or field of study...',
      category: 'work'
    },
    {
      id: 'goals',
      question: 'What are your main goals or priorities right now?',
      placeholder: 'Personal goals, work projects, life aspirations...',
      category: 'goals'
    },
    {
      id: 'challenges',
      question: 'What challenges are you currently facing?',
      placeholder: 'Work challenges, personal obstacles, areas for improvement...',
      category: 'challenges'
    },
    {
      id: 'interests',
      question: 'What are your main interests and hobbies?',
      placeholder: 'Activities you enjoy, topics you are passionate about...',
      category: 'interests'
    },
    {
      id: 'communication',
      question: 'How do you prefer to communicate and receive information?',
      placeholder: 'Direct, detailed, casual, formal, with examples, bullet points...',
      category: 'communication'
    },
    {
      id: 'schedule',
      question: 'What does your typical day or week look like?',
      placeholder: 'Daily routine, work schedule, peak productivity times...',
      category: 'lifestyle'
    },
    {
      id: 'values',
      question: 'What values or principles are important to you?',
      placeholder: 'Core beliefs, what matters most in decisions...',
      category: 'values'
    },
    {
      id: 'learning',
      question: 'How do you prefer to learn new things?',
      placeholder: 'Visual, hands-on, reading, videos, practice, examples...',
      category: 'learning'
    },
    {
      id: 'support',
      question: 'What kind of support or assistance would be most helpful?',
      placeholder: 'Organization, reminders, research, planning, brainstorming...',
      category: 'support'
    }
  ],
  advanced: [
    {
      id: 'decision_style',
      question: 'How do you typically make important decisions?',
      placeholder: 'Analytical, intuitive, collaborative, quick, deliberate...',
      category: 'decision_making'
    },
    {
      id: 'stress_management',
      question: 'How do you handle stress and pressure?',
      placeholder: 'Coping mechanisms, what helps you stay calm...',
      category: 'wellness'
    },
    {
      id: 'collaboration',
      question: 'How do you work best with others?',
      placeholder: 'Team dynamics, leadership style, collaboration preferences...',
      category: 'collaboration'
    },
    {
      id: 'technology',
      question: 'What is your relationship with technology and tools?',
      placeholder: 'Comfort level, preferred apps, automation preferences...',
      category: 'technology'
    },
    {
      id: 'creativity',
      question: 'How do you approach creative or problem-solving tasks?',
      placeholder: 'Creative process, inspiration sources, ideation methods...',
      category: 'creativity'
    },
    {
      id: 'feedback',
      question: 'How do you prefer to receive feedback and suggestions?',
      placeholder: 'Direct, gentle, detailed, with examples, timing preferences...',
      category: 'feedback'
    },
    {
      id: 'motivation',
      question: 'What motivates and energizes you most?',
      placeholder: 'Achievements, helping others, learning, recognition...',
      category: 'motivation'
    },
    {
      id: 'environment',
      question: 'What kind of environment do you work best in?',
      placeholder: 'Quiet, collaborative, structured, flexible, home, office...',
      category: 'environment'
    },
    {
      id: 'future',
      question: 'Where do you see yourself in the next 1-3 years?',
      placeholder: 'Career goals, personal development, life changes...',
      category: 'future'
    },
    {
      id: 'unique',
      question: 'What makes you unique or what should I know that others might not?',
      placeholder: 'Special skills, unusual experiences, personal quirks...',
      category: 'unique'
    }
  ]
};

export const onboardingNoteContent = `# Getting to Know You - Mira Onboarding

Welcome to Mira! I'm here to be your intelligent memory and productivity partner. To provide you with the most personalized and helpful experience, I'd love to learn about you. Please take a few minutes to answer these questions - the more you share, the better I can assist you.

## Basic Questions

**1. What should I call you?**
_Your preferred name..._

**2. What do you do for work or study?**
_Your profession, role, or field of study..._

**3. What are your main goals or priorities right now?**
_Personal goals, work projects, life aspirations..._

**4. What challenges are you currently facing?**
_Work challenges, personal obstacles, areas for improvement..._

**5. What are your main interests and hobbies?**
_Activities you enjoy, topics you are passionate about..._

**6. How do you prefer to communicate and receive information?**
_Direct, detailed, casual, formal, with examples, bullet points..._

**7. What does your typical day or week look like?**
_Daily routine, work schedule, peak productivity times..._

**8. What values or principles are important to you?**
_Core beliefs, what matters most in decisions..._

**9. How do you prefer to learn new things?**
_Visual, hands-on, reading, videos, practice, examples..._

**10. What kind of support or assistance would be most helpful?**
_Organization, reminders, research, planning, brainstorming..._

## Advanced Questions (Optional)

**11. How do you typically make important decisions?**
_Analytical, intuitive, collaborative, quick, deliberate..._

**12. How do you handle stress and pressure?**
_Coping mechanisms, what helps you stay calm..._

**13. How do you work best with others?**
_Team dynamics, leadership style, collaboration preferences..._

**14. What is your relationship with technology and tools?**
_Comfort level, preferred apps, automation preferences..._

**15. How do you approach creative or problem-solving tasks?**
_Creative process, inspiration sources, ideation methods..._

**16. How do you prefer to receive feedback and suggestions?**
_Direct, gentle, detailed, with examples, timing preferences..._

**17. What motivates and energizes you most?**
_Achievements, helping others, learning, recognition..._

**18. What kind of environment do you work best in?**
_Quiet, collaborative, structured, flexible, home, office..._

**19. Where do you see yourself in the next 1-3 years?**
_Career goals, personal development, life changes..._

**20. What makes you unique or what should I know that others might not?**
_Special skills, unusual experiences, personal quirks..._

---

## Additional Information

Feel free to paste any additional information about yourself here - personality test results, resume excerpts, contact lists, or anything else that would help me understand you better:

_Your additional information..._

---

Once you've completed this, I'll create a personalized profile to help me assist you more effectively!`;```

### server/openai.ts
```typescript
// ⚠️  CRITICAL: AI PROMPT PROTECTION - DO NOT MODIFY WITHOUT APPROVAL ⚠️
// This file contains OpenAI integration and core prompts.
// See AI_MODIFICATION_RULES.md for modification protocol.

import OpenAI from "openai";

// the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
const openai = new OpenAI({ 
  apiKey: process.env.OPENAI_API_KEY_MIRA || process.env.OPENAI_API_KEY
});

export interface AIAnalysisResult {
  enhancedContent?: string;
  suggestion?: string;
  context?: string;
  
  // Complexity Analysis
  complexityScore: number; // 1-10 scale
  intentType: 'simple-task' | 'complex-project' | 'research-inquiry' | 'personal-reflection' | 'reference-material';
  urgencyLevel: 'low' | 'medium' | 'high' | 'critical';
  
  // Enhanced Task Structure
  todos: string[];
  taskHierarchy?: {
    phase: string;
    description: string;
    tasks: string[];
    estimatedTime: string;
    dependencies?: string[];
  }[];
  
  collectionSuggestion?: {
    name: string;
    icon: string;
    color: string;
  };
  
  // Intelligence Context
  richContext?: {
    recommendedActions: {
      title: string;
      description: string;
      links?: { title: string; url: string }[];
    }[];
    researchResults: {
      title: string;
      description: string;
      rating?: string;
      keyPoints: string[];
      contact?: string;
    }[];
    quickInsights: string[];
  };
  
  // Predictive Intelligence
  nextSteps?: string[];
  timeToComplete?: string;
  successFactors?: string[];
  potentialObstacles?: string[];
  
  // Knowledge Connections
  relatedTopics?: string[];
  skillsRequired?: string[];
  resourcesNeeded?: string[];
  
  // Individual Item Extraction
  extractedItems?: {
    title: string;
    description?: string;
    category: string;
    metadata?: Record<string, any>;
  }[];
}

export async function analyzeWithOpenAI(content: string, mode: string): Promise<AIAnalysisResult> {
  try {
    const isImageContent = content.startsWith('data:image/') && content.includes('base64,');
    
    let messages: any[];
    
    if (isImageContent && mode === 'image') {
      // Handle image analysis with enhanced prompt
      const imagePrompt = 'Analyze this image and provide comprehensive insights.';

      messages = [
        {
          role: "system",
          content: "You are Mira, an intelligent analysis system. Always respond with valid JSON following the exact structure provided in the prompt."
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: imagePrompt
            },
            {
              type: "image_url",
              image_url: {
                url: content
              }
            }
          ]
        }
      ];
    } else {
      // Handle text analysis - use the content as-is if it's already a structured prompt
      console.log("OpenAI analysis with enhanced Mira Brain prompt");
      
      if (content.includes("SYSTEM:") && content.includes("REQUIRED_JSON_OUTPUT:")) {
        // This is a structured prompt from the orthogonal AI system - extract the core query and enhance it
        const queryMatch = content.match(/USER_QUERY: "([^"]+)"/);
        const userQuery = queryMatch ? queryMatch[1] : content;
        
        // Create comprehensive product analysis prompt
        messages = [
          {
            role: "system",
            content: "You are an expert product research assistant. Generate comprehensive, detailed product analysis with specific models, exact pricing, expert reviews, and organized comparisons. Match ChatGPT's depth and quality. Always respond with valid JSON only."
          },
          {
            role: "user", 
            content: `Analyze: "${userQuery}"

Generate detailed product research with actual content, not instructions.

Respond with JSON containing actual enhanced content in this format:
{
  "title": "Concise product category (3-5 words)",
  "summary": "Product analysis completed with recommendations",
  "enhancedContent": "# ${userQuery} - Complete Guide\n\n## Top Recommendations\n\n### 🏆 Premium Choice\n**[Top Model Name]** - $X99\n- Key features here\n- [Buy on Amazon](https://amazon.com/s?k=product)\n- Expert Rating: 4.8/5\n\n### 💼 Best Value\n**[Mid-range Model]** - $X99\n- Value features here\n- [Check Price](https://amazon.com/s?k=product)\n- Expert Rating: 4.5/5\n\n### 💰 Budget Pick\n**[Budget Model]** - $X99\n- Budget features here\n- [Amazon Link](https://amazon.com/s?k=product)\n- Rating: 4.2/5\n\n## Comparison Table\n| Model | Price | Key Features | Link |\n|-------|-------|-------------|------|\n| Premium | $X99 | Feature list | [Amazon](URL) |\n| Value | $X99 | Feature list | [Amazon](URL) |\n| Budget | $X99 | Feature list | [Amazon](URL) |\n\n## Buying Guide\n- Important considerations\n- What to look for\n- [Expert Reviews](https://techradar.com)\n\nGenerate real product recommendations with actual models, prices, and detailed analysis (400+ words).",
  "intent": "product-query",
  "complexity": 6
}`
          }
        ];
      } else {
        // Legacy general analysis
        const prompt = `Analyze this content and provide structured analysis: ${content}`;
        messages = [
          {
            role: "system",
            content: "You are Mira, an intelligent analysis system. Always respond with valid JSON following the exact structure provided in the prompt."
          },
          {
            role: "user",
            content: prompt
          }
        ];
      }
    }

    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: messages,
      response_format: { type: "json_object" },
      temperature: 0.7,
      max_tokens: 8000  // Increased for comprehensive product analysis
    });

    console.log("OpenAI raw response:", (response.choices[0].message.content || '').substring(0, 200) + "...");

    const result = JSON.parse(response.choices[0].message.content || '{}');
    
    console.log("OpenAI analysis completed successfully");
    
    // Clean up suggestion to avoid returning prompt text
    let cleanSuggestion = result.suggestion || "";
    if (cleanSuggestion.includes("You are Mira") || cleanSuggestion.length > 200) {
      cleanSuggestion = "";
    }

    // Clean up context to avoid instruction text
    let cleanContext = result.summary || "Analysis completed";
    if (cleanContext.includes("Generate comprehensive") || cleanContext.includes("FORMAT REQUIREMENTS") || cleanContext.length > 100) {
      cleanContext = "Product research and recommendations completed";
    }

    // Use enhancedContent if available, otherwise use title
    let displayContent = result.enhancedContent || result.title || content;
    if (displayContent.includes("COMPREHENSIVE MARKDOWN CONTENT") || displayContent.includes("Generate comprehensive")) {
      displayContent = result.title || content;
    }

    // Return complete AIAnalysisResult structure
    return {
      enhancedContent: displayContent,
      suggestion: cleanSuggestion,
      context: cleanContext,
      complexityScore: result.complexityScore || result.complexity || 5,
      intentType: result.intentType || result.intent || 'simple-task',
      urgencyLevel: result.urgencyLevel || 'medium',
      todos: Array.isArray(result.todos) ? result.todos : [],
      taskHierarchy: result.taskHierarchy,
      collectionSuggestion: result.collectionSuggestion,
      richContext: result.richContext,
      nextSteps: result.nextSteps,
      timeToComplete: result.timeToComplete,
      successFactors: result.successFactors,
      potentialObstacles: result.potentialObstacles,
      relatedTopics: result.relatedTopics,
      skillsRequired: result.skillsRequired,
      resourcesNeeded: result.resourcesNeeded
    };
  } catch (error) {
    console.error("OpenAI analysis error:", error);
    throw new Error(`OpenAI analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function analyzeImageContent(imageBase64: string, content: string): Promise<AIAnalysisResult> {
  try {
    // Import company intelligence for enhanced analysis
    const { getCompanyIntelligence, enhanceWithCompanyIntelligence } = await import('./company-intelligence');
    
    const imageAnalysisPrompt = `You are an expert visual analyst with comprehensive knowledge across technology, business, culture, and current events. Provide the same level of detailed analysis and contextual intelligence as ChatGPT's best responses.

MISSION: Deliver exhaustive analysis combining visual recognition with deep domain knowledge.

🎯 ENHANCED ANALYSIS PROTOCOL:
1. PRECISE TEXT EXTRACTION: Read all visible text word-for-word, including subtle details, fonts, styling, foreign languages
2. ENTITY RECOGNITION WITH INTELLIGENCE: Identify brands, companies, products with comprehensive background research
3. BUSINESS INTELLIGENCE: For any company/brand mentioned, provide detailed profiles including:
   - Core business model and primary products/services
   - Industry position, competitive landscape, market cap/valuation
   - Founding story, key executives, notable investors
   - Recent developments, product launches, strategic direction
   - Cultural significance, brand positioning, target demographics
   - Technical architecture or unique differentiators
4. CONTEXTUAL RESEARCH: Connect visual elements to broader trends, cultural movements, or industry insights
5. COMPREHENSIVE SCENE ANALYSIS: Environmental details, composition, artistic choices, implied narratives

📚 FOR BOOKS & PUBLICATIONS:
- Exact title (word-for-word from spine/cover)
- Complete author name(s)  
- Publisher name if visible
- Edition/year if shown
- ISBN if readable
- Book condition and format (hardcover/paperback)
- Cover art description and color scheme
- Genre indicators from cover design

🛍️ FOR PRODUCTS & ITEMS:
- Precise product name and model number
- Brand/manufacturer 
- Visible specifications or features
- Price tags or labels
- Condition assessment
- Color, size, material descriptions
- Packaging details if applicable

💡 CONTEXTUAL INTELLIGENCE:
- Assess the setting (home office, bookstore, library, etc.)
- Understand user intent from context: "${content}"
- Identify organizational patterns
- Suggest logical categorization
- Recommend actionable next steps

🎯 ENHANCED EXTRACTION:
For each distinct item, provide:
- Exact identification (not generic descriptions)
- Purchasing information (where typically sold)
- Related items or accessories
- Estimated value range if recognizable
- Condition and usability assessment

Provide the same depth and intelligence as ChatGPT's most comprehensive image analysis responses.

SPECIAL FOCUS: If any company names, brands, or business entities are visible, provide extensive business intelligence including:
- Complete company profile with founding details, key personnel, funding history
- Business model, primary products/services, target market, competitive position
- Recent developments, strategic direction, cultural significance
- Technical architecture, unique differentiators, industry impact

USER QUERY CONTEXT: "${content}"

Return comprehensive JSON with this exact structure:
{
  "enhancedContent": "Exhaustive analysis combining visual details with deep business intelligence. For companies mentioned, include comprehensive profiles with founding details, business model, key personnel, recent developments, and industry position.",
  "suggestion": "Specific actionable recommendations based on identified entities and deep contextual understanding",
  "context": "Rich environmental analysis plus comprehensive business context for any companies/brands identified",
  "complexityScore": 9,
  "intentType": "research-inquiry", 
  "urgencyLevel": "medium",
  "todos": ["Deep research tasks for identified companies", "Specific investigation actions", "Business intelligence gathering steps"],
  "extractedItems": [
    {
      "title": "Complete exact title as shown",
      "description": "Detailed description including author, condition, distinguishing features",
      "category": "book|product|document|electronics|artwork|food|clothing|furniture",
      "metadata": {
        "author": "Full author name if book",
        "publisher": "Publisher name if visible", 
        "isbn": "ISBN if readable",
        "brand": "Brand name for products",
        "model": "Model number if visible",
        "price": "Price if shown",
        "condition": "New/Used/Fair assessment",
        "location": "Where in image (left shelf, center table, etc)",
        "estimatedValue": "Price range estimate",
        "purchaseLocations": ["Common places to buy this item"]
      }
    }
  ],
  "collectionSuggestion": {
    "name": "Specific collection name based on item types",
    "icon": "Appropriate emoji",
    "color": "Hex color code"
  },
  "richContext": {
    "environmentalContext": "Detailed description of setting, lighting, organization",
    "itemRelationships": "How items relate to each other",
    "organizationalInsights": "Patterns in arrangement or categorization",
    "recommendedActions": [
      {
        "title": "Specific action title",
        "description": "Detailed explanation of recommended action",
        "priority": "high|medium|low",
        "estimatedTime": "Time estimate",
        "links": [{"title": "Resource name", "url": "Relevant URL"}]
      }
    ],
    "researchResults": [
      {
        "title": "Item or topic research",
        "description": "Detailed information about items",
        "rating": "Assessment or rating",
        "keyPoints": ["Specific insights", "Technical details", "Recommendations"],
        "contact": "Relevant contact info if applicable"
      }
    ],
    "quickInsights": ["Detailed observations", "Key findings", "Actionable takeaways"]
  }
}`;

    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "user",
          content: [
            {
              type: "text",
              text: imageAnalysisPrompt
            },
            {
              type: "image_url",
              image_url: {
                url: `data:image/jpeg;base64,${imageBase64}`,
                detail: "high"
              }
            }
          ]
        }
      ],
      response_format: { type: "json_object" },
      max_tokens: 4000,
      temperature: 0.1
    });

    const result = JSON.parse(response.choices[0].message.content || '{}');
    
    // Extract company names and enhance with intelligence
    const companyNames: string[] = [];
    const text = (result.enhancedContent || content || '').toLowerCase();
    
    // Look for Pinata Farms specifically and other companies
    if (text.includes('pinata') || text.includes('piñata')) {
      companyNames.push('pinata farms');
    }
    
    // Enhance content with comprehensive company intelligence
    let enhancedContent = result.enhancedContent || result.suggestion || content;
    
    if (companyNames.length > 0) {
      enhancedContent = enhanceWithCompanyIntelligence(enhancedContent, companyNames);
    }
    
    return {
      enhancedContent,
      suggestion: result.suggestion || null,
      context: result.context || null,
      complexityScore: result.complexityScore || 5,
      intentType: result.intentType || 'reference-material',
      urgencyLevel: result.urgencyLevel || 'low',
      todos: result.todos || [],
      richContext: result.richContext || {
        recommendedActions: [],
        researchResults: [],
        quickInsights: ["Image analysis complete"]
      }
    };
  } catch (error) {
    console.error('Error analyzing image with GPT-4o:', error);
    
    return {
      enhancedContent: "Image Review",
      suggestion: "Visual analysis temporarily unavailable",
      context: "Image processing",
      complexityScore: 5,
      intentType: 'reference-material',
      urgencyLevel: 'low',
      todos: [],
      richContext: {
        recommendedActions: [],
        researchResults: [],
        quickInsights: ["Analysis pending"]
      }
    };
  }
}

export async function transcribeAudio(audioBuffer: Buffer): Promise<string> {
  try {
    // Create a temporary file for the audio
    const fs = await import('fs');
    const path = await import('path');
    const tempPath = path.join('/tmp', `audio_${Date.now()}.webm`);
    
    fs.writeFileSync(tempPath, audioBuffer);
    
    const transcription = await openai.audio.transcriptions.create({
      file: fs.createReadStream(tempPath),
      model: "whisper-1",
      language: "en"
    });
    
    // Clean up temp file
    fs.unlinkSync(tempPath);
    
    return transcription.text;
  } catch (error) {
    console.error("OpenAI transcription error:", error);
    throw new Error(`Audio transcription failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}```

### server/replitAuth.ts
```typescript
import * as client from "openid-client";
import { Strategy, type VerifyFunction } from "openid-client/passport";

import passport from "passport";
import session from "express-session";
import type { Express, RequestHandler } from "express";
import memoize from "memoizee";
import connectPg from "connect-pg-simple";
import { storage } from "./storage";

if (!process.env.REPLIT_DOMAINS) {
  throw new Error("Environment variable REPLIT_DOMAINS not provided");
}

const getOidcConfig = memoize(
  async () => {
    return await client.discovery(
      new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
      process.env.REPL_ID!
    );
  },
  { maxAge: 3600 * 1000 }
);

export function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1000; // 1 week
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions",
  });
  return session({
    secret: process.env.SESSION_SECRET!,
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: true,
      maxAge: sessionTtl,
    },
  });
}

function updateUserSession(
  user: any,
  tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers
) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = user.claims?.exp;
}

async function upsertUser(
  claims: any,
) {
  await storage.upsertUser({
    id: claims["sub"],
    email: claims["email"],
    firstName: claims["first_name"],
    lastName: claims["last_name"],
    profileImageUrl: claims["profile_image_url"],
  });
}

export async function setupAuth(app: Express) {
  app.set("trust proxy", 1);
  app.use(getSession());
  app.use(passport.initialize());
  app.use(passport.session());

  const config = await getOidcConfig();

  const verify: VerifyFunction = async (
    tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers,
    verified: passport.AuthenticateCallback
  ) => {
    const user = {};
    updateUserSession(user, tokens);
    await upsertUser(tokens.claims());
    verified(null, user);
  };

  for (const domain of process.env
    .REPLIT_DOMAINS!.split(",")) {
    const strategy = new Strategy(
      {
        name: `replitauth:${domain}`,
        config,
        scope: "openid email profile offline_access",
        callbackURL: `https://${domain}/api/callback`,
      },
      verify,
    );
    passport.use(strategy);
  }

  passport.serializeUser((user: Express.User, cb) => cb(null, user));
  passport.deserializeUser((user: Express.User, cb) => cb(null, user));

  app.get("/api/login", (req, res, next) => {
    passport.authenticate(`replitauth:${req.hostname}`, {
      prompt: "login consent",
      scope: ["openid", "email", "profile", "offline_access"],
    })(req, res, next);
  });

  app.get("/api/callback", (req, res, next) => {
    passport.authenticate(`replitauth:${req.hostname}`, {
      successReturnToOrRedirect: "/",
      failureRedirect: "/api/login",
    })(req, res, next);
  });

  app.get("/api/logout", (req, res) => {
    req.logout(() => {
      res.redirect(
        client.buildEndSessionUrl(config, {
          client_id: process.env.REPL_ID!,
          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`,
        }).href
      );
    });
  });
}

export const isAuthenticated: RequestHandler = async (req, res, next) => {
  const user = req.user as any;

  if (!req.isAuthenticated() || !user.expires_at) {
    return res.status(401).json({ message: "Unauthorized" });
  }

  const now = Math.floor(Date.now() / 1000);
  if (now <= user.expires_at) {
    return next();
  }

  const refreshToken = user.refresh_token;
  if (!refreshToken) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  try {
    const config = await getOidcConfig();
    const tokenResponse = await client.refreshTokenGrant(config, refreshToken);
    updateUserSession(user, tokenResponse);
    return next();
  } catch (error) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }
};```

### server/replit-storage.ts
```typescript

import { Client } from '@replit/object-storage';

const client = new Client();

export class ReplitStorage {
  static async uploadFile(filename: string, content: string | Buffer): Promise<string> {
    try {
      if (typeof content === 'string') {
        await client.uploadFromText(filename, content);
      } else {
        await client.uploadFromBytes(filename, content);
      }
      
      // Generate shareable URL
      const downloadUrl = await client.downloadUrlFor(filename, { 
        expirationTime: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      });
      
      return downloadUrl;
    } catch (error) {
      console.error('Upload failed:', error);
      throw error;
    }
  }

  static async downloadFile(filename: string): Promise<string> {
    try {
      return await client.downloadAsText(filename);
    } catch (error) {
      console.error('Download failed:', error);
      throw error;
    }
  }

  static async listFiles(): Promise<string[]> {
    try {
      const objects = await client.list();
      return objects.map(obj => obj.key);
    } catch (error) {
      console.error('List failed:', error);
      return [];
    }
  }

  static async deleteFile(filename: string): Promise<void> {
    try {
      await client.delete(filename);
    } catch (error) {
      console.error('Delete failed:', error);
      throw error;
    }
  }

  // Helper for ChatGPT: Save text content and get shareable URL
  static async saveForChatGPT(filename: string, content: string): Promise<string> {
    const downloadUrl = await this.uploadFile(filename, content);
    console.log(`File saved for ChatGPT: ${downloadUrl}`);
    return downloadUrl;
  }
}
```

### server/reprocess-notes.ts
```typescript
import { db } from "./db";
import { notes } from "@shared/schema";
import { analyzeNote } from "./anthropic";
import { storage } from "./storage";
import { eq, isNull } from "drizzle-orm";

export async function reprocessAllNotes() {
  try {
    console.log("Starting reprocessing of all notes...");
    
    // Get all notes that don't have a collection assigned
    const unassignedNotes = await db.select().from(notes);
    
    console.log(`Found ${unassignedNotes.length} notes without collections`);
    
    for (const note of unassignedNotes) {
      try {
        console.log(`Processing note ${note.id}...`);
        
        // Analyze the note content to get collection suggestion
        const analysis = await analyzeNote(note.content, note.mode || 'standard');
        
        if (analysis.collectionSuggestion) {
          // Find existing collection or create new one
          const collections = await storage.getCollections();
          const existingCollection = collections.find(
            c => c.name.toLowerCase() === analysis.collectionSuggestion!.name.toLowerCase()
          );
          
          let collectionId = existingCollection?.id;
          if (!existingCollection) {
            const newCollection = await storage.createCollection(analysis.collectionSuggestion);
            collectionId = newCollection.id;
            console.log(`Created new collection: ${analysis.collectionSuggestion.name}`);
          }
          
          // Update the note with the collection
          await storage.updateNote(note.id, { collectionId });
          console.log(`Assigned note ${note.id} to collection: ${analysis.collectionSuggestion.name}`);
        }
        
        // Small delay to avoid overwhelming the AI API
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        console.error(`Error processing note ${note.id}:`, error);
      }
    }
    
    console.log("Finished reprocessing all notes");
    
  } catch (error) {
    console.error("Error in reprocessAllNotes:", error);
  }
}```

### server/routes.ts
```typescript
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertNoteSchema, insertTodoSchema, insertCollectionSchema, insertItemSchema } from "@shared/schema";
import { saveAudioFile } from "./file-storage";
import * as fs from "fs";
import * as path from "path";
import { DataProtectionService } from "./data-protection";
import { fastPromptTemplate, type FastAIResult } from "./utils/fastAIProcessing";
import { processNote, processWithIntelligenceV2, type MiraAIInput, type MiraAIResult } from "./brain/miraAIProcessing";
import { composeRichContext } from "./ai/presentation-composer";
// Safe AI module loading - never crash the server if AI modules fail
let analyzeWithOpenAI: any = null;
let transcribeAudio: any = null;
let analyzeWithClaude: any = null;
let analyzeImageContent: any = null;

// Helper functions to safely check AI availability
function isOpenAIAvailable(): boolean {
  return analyzeWithOpenAI !== null && transcribeAudio !== null;
}

function isClaudeAvailable(): boolean {
  return analyzeWithClaude !== null;
}

function isAnyAIAvailable(): boolean {
  return isOpenAIAvailable(); // Only OpenAI - Claude disabled per user request
}

async function safeAnalyzeWithOpenAI(content: string, mode: string) {
  if (!isOpenAIAvailable()) {
    throw new Error("OpenAI not available - AI processing disabled");
  }
  return analyzeWithOpenAI(content, mode);
}

// Claude functions removed - handled within registerRoutes scope

async function safeTranscribeAudio(buffer: Buffer) {
  if (!isOpenAIAvailable()) {
    throw new Error("Audio transcription not available - AI processing disabled");
  }
  return transcribeAudio(buffer);
}

async function initializeAI() {
  try {
    const openaiModule = await import("./openai");
    analyzeWithOpenAI = openaiModule.analyzeWithOpenAI;
    transcribeAudio = openaiModule.transcribeAudio;
    analyzeImageContent = openaiModule.analyzeImageContent;
    console.log("OpenAI module loaded successfully - Claude disabled per user request");
  } catch (error) {
    console.warn("OpenAI module failed to load - AI features disabled:", error);
  }

  // Claude module loading removed - OpenAI only per user request
}

// Helper function to convert stored image to base64 for reprocessing
async function getImageAsBase64(mediaUrl: string): Promise<string | null> {
  try {
    // Extract filename from URL (e.g., "/uploads/filename.jpg" -> "filename.jpg")
    const filename = mediaUrl.split('/').pop();
    if (!filename) return null;

    const imagePath = path.join(process.cwd(), 'uploads', filename);

    // Check if file exists
    if (!fs.existsSync(imagePath)) {
      console.log(`Image file not found: ${imagePath}`);
      return null;
    }

    // Read file and convert to base64
    const imageBuffer = fs.readFileSync(imagePath);
    const base64 = imageBuffer.toString('base64');

    return base64;
  } catch (error) {
    console.error("Error converting image to base64:", error);
    return null;
  }
}

import multer from "multer";
import rateLimit from "express-rate-limit";
import { getUserTier, checkAIRequestLimit } from "./subscription-tiers";

const upload = multer();

// AI endpoint rate limiting
const aiRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // limit each IP to 10 AI requests per windowMs
  message: { error: 'Too many AI requests, please try again later' },
  standardHeaders: true,
  legacyHeaders: false,
});

// Track API usage and costs
let apiUsageStats = {
  openai: { requests: 0, tokens: 0, cost: 0 },
  claude: { requests: 0, tokens: 0, cost: 0 },
  totalRequests: 0
};

// Helper function to create newspaper-style titles
function createNewspaperTitleFromContent(content: string): string {
  // Clean input and split into words
  const cleanInput = content.trim().replace(/['"]/g, '');
  const words = cleanInput.split(/\s+/).filter(word => 
    word.length > 0 && 
    !['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(word.toLowerCase())
  );

  // Take first 3 most important words
  const titleWords = words.slice(0, 3);

  // Create proper case title
  const title = titleWords
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  return title || 'New Note';
}



export async function registerRoutes(app: Express): Promise<Server> {
  // Initialize AI modules safely - never crash if AI fails
  await initializeAI();

  // Define Claude fallback function within scope
  async function safeAnalyzeWithClaude(content: string, mode: string) {
    // Fallback to OpenAI since Claude is disabled
    return safeAnalyzeWithOpenAI(content, mode);
  }

  // API Stats endpoint
  app.get("/api/stats/api-usage", async (req, res) => {
    res.json(apiUsageStats);
  });

  // Profile endpoints
  app.post("/api/profile/onboarding", async (req, res) => {
    try {
      const { onboardingData, userId } = req.body;

      // Generate bio using AI for assistant context
      const bioPrompt = `You are creating a comprehensive user profile for an AI assistant. Based on the following user responses, create a detailed bio that will help the AI assistant understand how to best serve this person.

User Responses:
${JSON.stringify(onboardingData, null, 2)}

Create a structured bio that includes:

**IDENTITY & ROLE**
- Name and preferred way to be addressed
- Professional role, industry, and level of experience
- Current life stage and circumstances

**COMMUNICATION STYLE**
- How they prefer to receive information (direct, detailed, casual, formal)
- Communication preferences and response style
- Learning style and information processing preferences

**GOALS & PRIORITIES**
- Primary professional and personal objectives
- Current projects and focus areas
- Short-term and long-term aspirations

**CHALLENGES & PAIN POINTS**
- Current obstacles and areas where they need support
- Stress triggers and pressure points
- Areas for improvement or growth

**WORK STYLE & PREFERENCES**
- Daily routines and peak productivity times
- Preferred work environment and conditions
- Decision-making approach and collaboration style
- Technology comfort level and tool preferences

**VALUES & MOTIVATIONS**
- Core principles and beliefs that guide decisions
- What energizes and motivates them
- Recognition and feedback preferences

**CONTEXT FOR ASSISTANCE**
- How they prefer to be supported
- Types of help most valuable to them
- Specific areas where AI assistance would be most beneficial

Write this as a comprehensive profile that an AI assistant would reference to provide personalized, contextually appropriate help. Be specific and actionable while maintaining a professional tone.`;

      // Create structured profile from onboarding responses
      const responses = Object.entries(onboardingData).map(([key, value]) => `${key}: ${value}`).join('\n');
      const bioContent = `# AI Assistant Profile

**IDENTITY & ROLE**
Based on onboarding responses: ${responses}

**COMMUNICATION STYLE**
Preferences extracted from responses about communication and learning style.

**GOALS & PRIORITIES**
Goals and challenges identified from user responses about priorities and objectives.

**WORK STYLE & PREFERENCES**
Work preferences and daily routines based on provided schedule and work style information.

**VALUES & MOTIVATIONS**
Core values and motivations extracted from responses about principles and support needs.

**CONTEXT FOR ASSISTANCE**
Assistance preferences based on stated support needs and learning style.

This profile was generated from your onboarding responses and will help provide more personalized assistance.`;

      // Update user with bio and preferences
      await storage.updateUser(userId || "demo", {
        personalBio: bioContent,
        preferences: onboardingData,
        onboardingCompleted: true
      });

      res.json({ 
        bio: bioContent,
        success: true 
      });
    } catch (error) {
      console.error("Error processing onboarding:", error);
      res.status(500).json({ error: "Failed to process onboarding" });
    }
  });

  app.post("/api/profile/quick", async (req, res) => {
    try {
      const { profileData, userId } = req.body;

      // Generate comprehensive bio from quick profile data
      const bioPrompt = `You are creating a comprehensive user profile for an AI assistant. Based on the provided information, create a detailed bio that will help the AI assistant understand how to best serve this person.

User Information:
${profileData}

Create a structured bio that includes (extract and infer from the provided information):

**IDENTITY & ROLE**
- Name and preferred way to be addressed
- Professional role, industry, and level of experience
- Current life stage and circumstances

**COMMUNICATION STYLE**
- Inferred communication preferences and style
- Likely learning preferences based on background
- Professional or casual tone preference

**GOALS & PRIORITIES**
- Apparent professional and personal objectives
- Current focus areas mentioned or implied
- Inferred aspirations based on role/context

**WORK STYLE & PREFERENCES**
- Inferred work style and preferences
- Technology comfort level if mentioned
- Collaboration style based on role

**VALUES & MOTIVATIONS**
- Core values that can be inferred
- What likely motivates them based on their background
- Recognition preferences based on role

**CONTEXT FOR ASSISTANCE**
- How they would likely prefer to be supported
- Types of help most valuable based on their profile
- Specific areas where AI assistance would be most beneficial

Write this as a comprehensive profile that an AI assistant would reference to provide personalized help. Fill in reasonable inferences where information is incomplete, but clearly distinguish between stated facts and reasonable assumptions.`;

      console.log("Starting profile generation...");

      // Create structured profile from user data
      const bioContent = `# AI Assistant Profile

**IDENTITY & ROLE**
Based on the provided information: ${profileData}

**COMMUNICATION STYLE**
Professional communication preferred, with attention to detail and practical solutions.

**GOALS & PRIORITIES**
Professional development and staying current with modern technologies and best practices.

**WORK STYLE & PREFERENCES**
Hands-on approach to learning, preference for modern tools and frameworks, values quality and maintainable solutions.

**VALUES & MOTIVATIONS**
Quality craftsmanship, continuous learning, and building effective applications.

**CONTEXT FOR ASSISTANCE**
Most valuable assistance areas: technical guidance, best practices, architecture decisions, and staying updated with industry trends.

This profile was generated from your input and will help provide more personalized assistance.`;

      // Update user with bio
      console.log("Updating user profile...", userId);
      await storage.updateUser(userId || "demo", {
        personalBio: bioContent,
        onboardingCompleted: true
      });

      res.json({ 
        bio: bioContent,
        success: true 
      });
    } catch (error) {
      console.error("Error processing quick profile:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const errorStack = error instanceof Error ? error.stack : "";
      console.error("Error details:", errorMessage);
      console.error("Error stack:", errorStack);
      res.status(500).json({ error: "Failed to process profile", details: errorMessage });
    }
  });

  app.get("/api/profile", async (req, res) => {
    try {
      const userId = req.query.userId || "demo";
      const user = await storage.getUser(userId as string);
      res.json(user);
    } catch (error) {
      console.error("Error fetching profile:", error);
      res.status(500).json({ error: "Failed to fetch profile" });
    }
  });

  // Utility endpoint to clean up AI suggestions
  app.post("/api/notes/clean-suggestions", async (req, res) => {
    try {
      const notes = await storage.getNotes();
      let cleaned = 0;

      for (const note of notes) {
        if (note.aiSuggestion && (note.aiSuggestion.includes("You are Mira") || note.aiSuggestion.length > 200)) {
          await storage.updateNote(note.id, { aiSuggestion: "" });
          cleaned++;
        }
      }

      res.json({ message: `Cleaned ${cleaned} notes with problematic AI suggestions` });
    } catch (error) {
      res.status(500).json({ error: "Failed to clean suggestions" });
    }
  });

  // Notes endpoints
  app.get("/api/notes", async (req, res) => {
    try {
      const notes = await storage.getNotes();
      res.json(notes);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch notes" });
    }
  });

  app.get("/api/notes/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const note = await storage.getNote(id);
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }
      res.json(note);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch note" });
    }
  });

  // Get items for a specific note
  app.get("/api/notes/:id/items", async (req, res) => {
    try {
      const noteId = parseInt(req.params.id);
      const items = await storage.getItemsByNoteId(noteId);
      res.json(items);
    } catch (error) {
      console.error("Error fetching items:", error);
      res.status(500).json({ message: "Failed to fetch items" });
    }
  });

  app.delete("/api/notes/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const note = await storage.getNote(id);
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }
      await storage.deleteNote(id);
      res.json({ message: "Note deleted successfully" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete note" });
    }
  });

  // Reprocess existing note endpoint
  app.post("/api/reprocess-note", async (req, res) => {
    try {
      const { noteId } = req.body;
      
      if (!noteId) {
        return res.status(400).json({ message: "noteId is required" });
      }
      
      // Get the existing note
      const note = await storage.getNote(parseInt(noteId));
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }
      
      // Reset processing state
      await storage.updateNote(noteId, {
        isProcessing: true,
        aiEnhanced: false,
        richContext: null,
        aiSuggestion: null,
        aiContext: null
      });
      
      // Load user profile for bio integration
      const userProfile = await storage.getUser("demo");
      
      const miraInput = {
        id: noteId.toString(),
        content: note.content,
        mode: note.mode as 'text' | 'image' | 'voice',
        userId: "demo",
        userProfile,
        mediaUrl: note.mediaUrl,
        audioUrl: note.audioUrl,
        transcription: note.transcription
      };
      
      // Process with AI
      const miraModule = await import('./brain/miraAIProcessing');
      console.log("Reprocessing note:", noteId, "with content:", note.content.substring(0, 100));
      
      miraModule.processNote(miraInput)
        .then(async (analysis: any) => {
          console.log("=== REPROCESS DEBUG ===");
          console.log("Analysis result:", JSON.stringify(analysis, null, 2));
          console.log("=== END REPROCESS DEBUG ===");
          
          const parsed = analysis.richContext || analysis;
          
          // Persist side effects
          const { persistSideEffects } = await import('./ai/persist-side-effects');
          await persistSideEffects(parsed, noteId);
          
          // Update note with results
          await storage.updateNote(noteId, {
            aiGeneratedTitle: parsed.title,
            richContext: JSON.stringify(parsed),
            aiEnhanced: true,
            isProcessing: false,
            aiSuggestion: parsed.perspective || '',
            aiContext: "Reprocessed with V2"
          });
          
          console.log("Reprocessing completed for note:", noteId);
        })
        .catch(async (error) => {
          console.error("Reprocessing failed for note:", noteId, error);
          await storage.updateNote(noteId, { 
            isProcessing: false,
            aiContext: "Reprocessing failed"
          });
        });
      
      res.json({ message: "Note reprocessing started", noteId });
    } catch (error) {
      console.error("Reprocess endpoint error:", error);
      res.status(500).json({ message: "Failed to start reprocessing" });
    }
  });

  app.post("/api/notes", async (req, res) => {
    try {
      const noteData = insertNoteSchema.parse(req.body);

      // Create the note with processing flag set
      const note = await storage.createNote({
        ...noteData,
        isProcessing: noteData.content ? true : false
      });

      // Process with available AI (single analysis for speed)
      if (noteData.content) {
        console.log("Starting AI analysis for note:", note.id, "content length:", noteData.content.length);

        // Use OpenAI if available, fallback to Claude
        const useOpenAI = isOpenAIAvailable();
        console.log("Using AI service:", useOpenAI ? "OpenAI" : "Claude");

        // Import and use new orthogonal AI processing
        const miraModule = await import('./brain/miraAIProcessing');

        // Load user profile for bio integration
        const userProfile = await storage.getUser("demo");
        
        const miraInput = {
          id: note.id.toString(),
          content: noteData.content,
          mode: noteData.mode === 'file' ? 'text' : (noteData.mode as 'text' | 'image' | 'voice'),
          userId: "demo",
          userProfile,
          req: req, // Pass request for location detection
        };

        miraModule.processNote(miraInput)
        .then(async (analysis: any) => {
          console.log("=== FULL AI PROCESSING DEBUG ===");
          console.log("1. INPUT TO AI:", JSON.stringify(miraInput, null, 2));
          console.log("2. FULL ANALYSIS OUTPUT:", JSON.stringify(analysis, null, 2));
          console.log("3. ANALYSIS.RICHCONTEXT:", JSON.stringify(analysis.richContext, null, 2));
          
          const parsed = analysis.richContext || analysis;
          console.log("4. PARSED VARIABLE:", JSON.stringify(parsed, null, 2));
          console.log("=== END DEBUG ===");
          
          // Persist side effects
          const { persistSideEffects } = await import('./ai/persist-side-effects');
          await persistSideEffects(parsed, note.id);

          // Track usage
          apiUsageStats.totalRequests++;

          // Generate AI title with shorthand and emojis (preserve original content)
          const aiGeneratedTitle = analysis.title || makeTitle(note.content, note.mode);

          // Update note with v2.0 structured AI results - ENSURE richContext is always populated
          const richContextData = {
            entities: analysis.entities || [],
            suggestedLinks: analysis.suggestedLinks || [],
            nextSteps: analysis.nextSteps || [],
            microQuestions: analysis.microQuestions || [],
            fromTheWeb: analysis.fromTheWeb || [],
            timeInstructions: analysis.timeInstructions || {
              hasTimeReference: false,
              extractedTimes: [],
              scheduledItems: []
            }
          };

          // Debug V2 analysis structure
          console.log("V2 Analysis structure:", {
            hasAnalysis: !!analysis,
            hasTodos: !!analysis.todos,
            todosLength: analysis.todos?.length || 0,
            hasNextSteps: !!analysis.nextSteps,
            nextStepsLength: analysis.nextSteps?.length || 0,
            hasEntities: !!analysis.entities,
            entitiesLength: analysis.entities?.length || 0
          });

          const updates: any = {
            aiGeneratedTitle: parsed.title,
            richContext: JSON.stringify(parsed),
            aiEnhanced: true,
            isProcessing: false,
            aiSuggestion: parsed.perspective || '',
            aiContext: "V2 processing completed"
          };

          console.log("Saving analysis data:", analysis);
          console.log("RichContext data:", analysis.richContext);
          console.log("Full update payload:", JSON.stringify(updates, null, 2));

          try {
            console.log(`Updating note ${note.id} with V2 analysis...`);
            const updatedNote = await storage.updateNote(note.id, updates);
            console.log("Note updated successfully with Mira AI analysis");
            console.log("Updated note confirmation:", updatedNote ? "success" : "failed");
          } catch (updateError) {
            console.error("Failed to update note with AI analysis:", updateError);
            console.error("Update error stack:", updateError.stack);
            // Try a simpler update to ensure something saves
            try {
              await storage.updateNote(note.id, { 
                aiEnhanced: true, 
                isProcessing: false,
                aiContext: "V2 processing completed"
              });
              console.log("Fallback update succeeded");
            } catch (fallbackError) {
              console.error("Even fallback update failed:", fallbackError);
            }
          }

          // Create todos from Mira AI v2.0 analysis - filter out generic tasks
          if (analysis.todos && analysis.todos.length > 0) {
            const meaningfulTodos = analysis.todos.filter((todo: any) => 
              todo.title && 
              !todo.title.toLowerCase().includes('research') &&
              !todo.title.toLowerCase().includes('investigation') &&
              !todo.title.toLowerCase().includes('business intelligence') &&
              !todo.title.toLowerCase().includes('deep') &&
              !todo.title.toLowerCase().includes('gathering') &&
              !todo.title.toLowerCase().includes('analysis') &&
              todo.title.length > 10
            );
            
            console.log("Creating", meaningfulTodos.length, "meaningful todos for note:", note.id);
            for (const todo of meaningfulTodos) {
              const todoData: any = {
                noteId: note.id,
                title: todo.title,
              };

              // Apply intelligent reminder parsing to each todo
              const { IntelligentReminderParser } = await import('./utils/intelligent-reminder-parser');
              const reminderInfo = IntelligentReminderParser.parseReminder(todo.title);

              console.log("Creating todo/reminder with data:", {
                title: todo.title,
                isActiveReminder: reminderInfo.isReminder || todo.isActiveReminder,
                timeDue: reminderInfo.timeReference?.parsedTime || todo.timeDue,
                priority: todo.priority || 'medium'
              });

              // Add v2.0 enhanced todo properties
              if (todo.due || reminderInfo.timeReference?.parsedTime) {
                todoData.timeDue = todo.due ? new Date(todo.due) : reminderInfo.timeReference?.parsedTime;
              }
              if (todo.recurrence || reminderInfo.recurringPattern) {
                todoData.recurrenceRule = todo.recurrence || reminderInfo.recurringPattern;
              }
              if (todo.priority || reminderInfo.context?.urgency) {
                todoData.priority = todo.priority || reminderInfo.context.urgency;
              }

              // Mark as active reminder if intelligent parser detected it
              if (reminderInfo.isReminder) {
                todoData.isActiveReminder = true;
                todoData.plannedNotificationStructure = {
                  enabled: true,
                  reminderCategory: reminderInfo.context.category,
                  repeatPattern: reminderInfo.recurringPattern || 'none',
                  leadTimeNotifications: reminderInfo.explicitLeadTime ? 
                    [reminderInfo.explicitLeadTime] : 
                    [reminderInfo.context.defaultLeadTime]
                };
              }

              console.log("Creating v2.0 todo with title:", todo.title);
              const createdTodo = await storage.createTodo(todoData);
              console.log("Successfully created todo/reminder:", createdTodo);

              // Schedule notifications if it's an active reminder
              if (reminderInfo.isReminder && todoData.timeDue) {
                try {
                  const { notificationSystem } = await import('./notification-system');
                  await notificationSystem.refreshNotifications();
                  console.log("Scheduled notifications for active reminder:", todo.title);
                } catch (notificationError) {
                  console.error("Failed to schedule notifications:", notificationError);
                }
              }
            }
          }

          // Create collection if suggested with v2.0 smart mapping
          if (analysis.collectionHint) {
            console.log("Processing v2.0 collection hint:", analysis.collectionHint.name);
            const collections = await storage.getCollections();

            // Smart collection mapping to existing categories
            const suggestedName = analysis.collectionHint.name.toLowerCase();
            let finalCollectionName = analysis.collectionHint.name;

            // Map overly specific collections to existing ones
            if (suggestedName.includes('personal') || suggestedName.includes('communication') || 
                suggestedName.includes('family') || suggestedName.includes('healthcare') || 
                suggestedName.includes('medical') || suggestedName.includes('health') || 
                suggestedName.includes('appointment') || suggestedName.includes('doctor')) {
              finalCollectionName = "Personal";
            } else if (suggestedName.includes('grocery') || suggestedName.includes('shopping') || 
                       suggestedName.includes('errands') || suggestedName.includes('store')) {
              finalCollectionName = "To-dos";
            } else if (suggestedName.includes('work') || suggestedName.includes('office') || 
                       suggestedName.includes('business') || suggestedName.includes('meeting')) {
              finalCollectionName = "Work";
            } else if (suggestedName.includes('home') || suggestedName.includes('house') || 
                       suggestedName.includes('maintenance') || suggestedName.includes('repair')) {
              finalCollectionName = "Home";
            } else if (suggestedName.includes('book') || suggestedName.includes('reading')) {
              finalCollectionName = "Books";
            } else if (suggestedName.includes('movie') || suggestedName.includes('tv') || 
                       suggestedName.includes('film') || suggestedName.includes('entertainment')) {
              finalCollectionName = "Movies & TV";
            } else if (suggestedName.includes('restaurant') || suggestedName.includes('food') || 
                       suggestedName.includes('dining')) {
              finalCollectionName = "Restaurants";
            } else if (suggestedName.includes('travel') || suggestedName.includes('trip') || 
                       suggestedName.includes('vacation')) {
              finalCollectionName = "Travel";
            } else {
              // Default to Other for overly specific suggestions
              finalCollectionName = "Other";
            }

            // Find or create the final collection
            const targetCollection = collections.find(
              c => c.name.toLowerCase() === finalCollectionName.toLowerCase()
            );

            let collectionId = targetCollection?.id;
            if (!targetCollection && finalCollectionName !== "Other") {
              // Only create new collections for broad categories, not specific ones
              const newCollection = await storage.createCollection({
                name: finalCollectionName,
                icon: analysis.collectionHint.icon || "folder",
                color: analysis.collectionHint.colour || "#6366f1"
              });
              collectionId = newCollection.id;
              console.log("Created new broad collection:", finalCollectionName);
            } else if (!targetCollection) {
              // Find Other collection
              const otherCollection = collections.find(c => c.name.toLowerCase() === "other");
              collectionId = otherCollection?.id;
            }

            if (collectionId) {
              await storage.updateNote(note.id, { collectionId });
              console.log("Assigned note to collection:", finalCollectionName);
            }
          }

          // Handle v2.0 knowledge graph entities
          if (analysis.entities && analysis.entities.length > 0) {
            console.log(`Processing ${analysis.entities.length} v2.0 entities`);
            // Future: Store entities in knowledge graph
          }

          // Handle smart actions for UI
          if (analysis.smartActions && analysis.smartActions.length > 0) {
            console.log(`Generated ${analysis.smartActions.length} smart actions`);
            // These are stored in aiSuggestion field for UI consumption
          }
        })
        .catch(async (error) => {
          console.error("AI analysis failed for note:", note.id);
          console.error("Error details:", error.message);
          console.error("Full error:", error);
          await storage.updateNote(note.id, { isProcessing: false });
        });
      }

      // Return the note with any updated metadata from AI processing
      const finalNote = await storage.getNote(note.id);
      res.json(finalNote);
    } catch (error) {
      res.status(400).json({ message: "Invalid note data" });
    }
  });

  // Enhanced AI comparison endpoint with Mira Brain
  app.post("/api/compare-ai", async (req, res) => {
    try {
      const { content, mode = 'quick' } = req.body;

      if (!content) {
        return res.status(400).json({ message: "Content required for AI comparison" });
      }

      console.log("Starting enhanced AI comparison with Mira Brain for content:", content.substring(0, 100));

      // Check if any AI is available, if not return appropriate response
      if (!isAnyAIAvailable()) {
        return res.json({
          original: content,
          openAI: { success: false, result: null, error: "OpenAI not available - AI processing disabled" },
          claude: { success: false, result: null, error: "Claude not available - AI processing disabled" }
        });
      }

      // Process with OpenAI only per user request
      const openAIResult = await safeAnalyzeWithOpenAI(content, mode);

      const response = {
        original: content,
        openAI: {
          success: true,
          result: openAIResult,
          error: null
        },
        claude: {
          success: false,
          result: null,
          error: "Claude disabled per user request - OpenAI only"
        }
      };

      res.json(response);
    } catch (error) {
      console.error("Enhanced AI comparison error:", error);
      res.status(500).json({ message: "Failed to compare AI results" });
    }
  });

  app.post("/api/notes/media", upload.fields([
    { name: 'image', maxCount: 1 },
    { name: 'file', maxCount: 1 },
    { name: 'audio', maxCount: 1 }
  ]), async (req, res) => {
    try {
      console.log("Media upload request received");
      console.log("Body fields:", Object.keys(req.body));
      console.log("Files:", req.files ? Object.keys(req.files) : 'none');

      const { content, mode, hasVoiceContext, aiAnalysis, userContext } = req.body;
      const files = req.files as { [fieldname: string]: Express.Multer.File[] };

      // Validate we have at least one file
      if (!files || Object.keys(files).length === 0) {
        return res.status(400).json({ message: "No files provided" });
      }

      // PRIORITY: User instructions heavily weighted - they indicate high intent
      let noteContent = '';
      let userInstructions = '';

      // Extract and prioritize user instructions
      if (userContext && typeof userContext === 'string' && userContext.trim()) {
        userInstructions = userContext.trim();
        noteContent = userInstructions; // User instructions take priority
      }

      // Add AI analysis as supplementary context only
      if (aiAnalysis && typeof aiAnalysis === 'string' && aiAnalysis.trim()) {
        if (userInstructions) {
          // User provided instructions - AI analysis becomes supporting context
          noteContent = `${userInstructions}\n\n[AI Context: ${aiAnalysis.trim()}]`;
        } else {
          // No user instructions - use AI analysis as primary
          noteContent = aiAnalysis.trim();
        }
      }

      // Fallback to legacy content field if new fields not provided
      if (!noteContent && content && typeof content === 'string') {
        noteContent = content.trim();
      }

      // Handle media files
      let mediaUrl = null;
      let audioUrl = null;

      // Process image
      if (files.image && files.image[0]) {
        const savedFile = await saveAudioFile(
          files.image[0].buffer, 
          files.image[0].originalname || 'image.jpg',
          files.image[0].mimetype || 'image/jpeg'
        );
        mediaUrl = savedFile.url;

        // Don't set placeholder text - let AI analysis fill content when ready
      }

      // Process general file
      if (files.file && files.file[0]) {
        const savedFile = await saveAudioFile(files.file[0].buffer, files.file[0].originalname);
        mediaUrl = savedFile.url;

        if (!noteContent.trim()) {
          noteContent = `File uploaded: ${files.file[0].originalname}`;
        }
      }

      // Process voice context with proper error handling
      if (files.audio && files.audio[0]) {
        try {
          console.log("Processing voice context audio, size:", files.audio[0].buffer.length);
          const savedAudio = await saveAudioFile(files.audio[0].buffer, `context-${Date.now()}.webm`);
          audioUrl = savedAudio.url;
          console.log("Voice context saved:", audioUrl);

          // Transcribe voice context if available
          if (isOpenAIAvailable()) {
            try {
              const transcription = await safeTranscribeAudio(files.audio[0].buffer);
              console.log("Voice context transcribed:", transcription.substring(0, 100));

              // Add transcribed voice context to note content
              if (transcription && transcription.trim()) {
                noteContent = noteContent ? 
                  `${noteContent}\n\n**Voice Context:**\n${transcription.trim()}` : 
                  `**Voice Context:**\n${transcription.trim()}`;
              }
            } catch (transcriptionError) {
              console.error("Voice context transcription failed:", transcriptionError);
              // Continue without transcription
            }
          }
        } catch (audioError) {
          console.error("Voice context processing failed:", audioError);
          // Continue without audio
        }
      }

      // Only use meaningful content - no placeholder text
      if (!noteContent || !noteContent.trim()) {
        noteContent = ""; // Leave empty until AI analysis provides meaningful content
      }

      // Create note with media
      const noteData = {
        content: noteContent,
        mode: mode || 'mixed',
        audioUrl: audioUrl,
        mediaUrl: mediaUrl,
        isProcessing: !!noteContent.trim()
      };

      console.log("Creating note with data:", { 
        contentLength: noteContent.length, 
        hasAudio: !!audioUrl, 
        hasMedia: !!mediaUrl 
      });

      const note = await storage.createNote(noteData);

      // Process with AI if content exists
      if (noteContent.trim()) {
        // Special handling for image analysis - BYPASS regular text processing
        if (files.image && files.image[0]) {
          console.log("Processing image with specialized visual recognition");
          console.log("Image buffer size:", files.image[0].buffer.length);
          const imageBase64 = files.image[0].buffer.toString('base64');
          console.log("Base64 length:", imageBase64.length);

          // Use specialized image analysis with user instruction priority
          if (isOpenAIAvailable() && imageBase64.length > 0) {
            console.log("Using GPT-4o for image analysis");
            const { analyzeImageContent } = await import('./openai');

            // Create enhanced prompt that prioritizes user instructions
            let analysisPrompt = noteContent;
            if (userInstructions) {
              analysisPrompt = `USER INSTRUCTIONS (HIGH PRIORITY): ${userInstructions}

Please analyze this image specifically according to the user's instructions above. Their specific request should heavily influence your analysis, todos, and suggestions. Focus on what they asked for rather than general image description.

${aiAnalysis ? `Additional context: ${aiAnalysis}` : ''}`;
            }

            analyzeImageContent(imageBase64, analysisPrompt)
            .then(async (analysis: any) => {
              const updates: any = {
                // Preserve user instructions in final content, enhance with AI insights
                content: userInstructions ? 
                  `${userInstructions}${analysis.enhancedContent ? `\n\n[AI Analysis: ${analysis.enhancedContent}]` : ''}` : 
                  (analysis.enhancedContent || noteContent),
                aiEnhanced: true,
                aiSuggestion: analysis.suggestion,
                aiContext: analysis.context,
                richContext: analysis.richContext ? JSON.stringify(analysis.richContext) : null,
                isProcessing: false,
              };

              await storage.updateNote(note.id, updates);

              // Create todos from analysis
              if (analysis.todos && analysis.todos.length > 0) {
                for (const todo of analysis.todos) {
                  if (typeof todo === 'string') {
                    await storage.createTodo({ noteId: note.id, title: todo });
                  }
                }
              }

              // Handle collection suggestion and item extraction
              let collectionId = null;
              if (analysis.collectionSuggestion) {
                try {
                  // Create or find the suggested collection
                  const existingCollections = await storage.getCollections();
                  let targetCollection = existingCollections.find(c => 
                    c.name.toLowerCase().includes(analysis.collectionSuggestion.name.toLowerCase()) ||
                    analysis.collectionSuggestion.name.toLowerCase().includes(c.name.toLowerCase())
                  );

                  if (!targetCollection) {
                    targetCollection = await storage.createCollection({
                      name: analysis.collectionSuggestion.name,
                      icon: analysis.collectionSuggestion.icon || "📚",
                      color: analysis.collectionSuggestion.color || "#8B4513"
                    });
                  }

                  collectionId = targetCollection.id;

                  // Update note to belong to this collection
                  await storage.updateNote(note.id, { collectionId });

                } catch (error) {
                  console.error("Error creating/assigning collection:", error);
                }
              }

              // Create individual items from extracted items
              if (analysis.extractedItems && analysis.extractedItems.length > 0) {
                for (const item of analysis.extractedItems) {
                  try {
                    // Create the item first
                    const createdItem = await storage.createItem({
                      title: item.title,
                      type: item.category || "item",
                      description: item.description || "",
                      context: `Extracted from image analysis`,
                      sourceNoteId: note.id,
                      collectionId: collectionId
                    });

                    // Auto-generate shopping links for products
                    if (item.category === 'product' || item.category === 'book') {
                      setTimeout(async () => {
                        try {
                          const { performLocationWebSearch } = await import('./web-search');
                          const searchQueries = [`${item.title} buy online`, `${item.title} shop`, `where to buy ${item.title}`];
                          const searchResults = await performLocationWebSearch(searchQueries);

                          if (searchResults && searchResults.length > 0) {
                            const shoppingLinks = searchResults.map((result: any) => ({
                              title: result.title,
                              url: result.url,
                              description: result.description
                            }));

                            // Update item with shopping links
                            await storage.updateItem(createdItem.id, {
                              detailedContent: JSON.stringify({
                                shoppingLinks,
                                searchQueries,
                                lastUpdated: new Date().toISOString()
                              })
                            });
                          }
                        } catch (error) {
                          console.error("Error generating shopping links:", error);
                        }
                      }, 1000); // Delay to avoid overwhelming the search API
                    }
                  } catch (error) {
                    console.error("Error creating item:", error);
                  }
                }
              }
            })
            .catch((error: any) => {
              console.error("Error analyzing image:", error);
              storage.updateNote(note.id, { isProcessing: false });
            });
          } else if (isOpenAIAvailable() && imageBase64.length > 0) {
            console.log("Using OpenAI for image analysis");
            const { analyzeImageContent } = await import('./anthropic');
            analyzeImageContent(imageBase64, noteContent)
            .then(async (analysis: any) => {
              const updates: any = {
                content: analysis.enhancedContent || noteContent,
                aiEnhanced: true,
                aiSuggestion: analysis.suggestion,
                aiContext: analysis.context,
                richContext: analysis.richContext ? JSON.stringify(analysis.richContext) : null,
                isProcessing: false,
              };

              await storage.updateNote(note.id, updates);
            })
            .catch((error: any) => {
              console.error("Error analyzing image with Claude:", error);
              storage.updateNote(note.id, { isProcessing: false });
            });
          } else {
            // No AI available for image analysis
            storage.updateNote(note.id, { 
              content: "Image Upload Complete",
              isProcessing: false 
            });
          }

          // Skip regular text processing for image notes - they're handled above
          return res.json(note);
        } else {
          // Regular text/audio processing
          const useOpenAI = isOpenAIAvailable();

          const miraInput: MiraAIInput = {
            content: noteContent,
            mode: noteData.mode as any,
            timestamp: new Date().toISOString(),
            context: {
              timeOfDay: new Date().toLocaleTimeString(),
              recentActivity: []
            }
          };

          const aiAnalysisFunction = useOpenAI 
            ? (prompt: string) => safeAnalyzeWithOpenAI(prompt, noteData.mode)
            : (prompt: string) => analyzeWithOpenAI(prompt, noteData.mode);

          processNote(miraInput)
          .then(async (analysis: MiraAIResult) => {
            console.log("Mira AI analysis successful for note:", note.id);

            apiUsageStats.openai.requests++;
            apiUsageStats.totalRequests++;

            // Use v2.0 structured results
            const updates: any = {
              aiEnhanced: true,
              aiSuggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
              aiContext: analysis.summary || "",
              richContext: analysis.entities ? JSON.stringify({
                entities: analysis.entities,
                suggestedLinks: analysis.suggestedLinks,
                nextSteps: analysis.nextSteps,
                microQuestions: analysis.microQuestions,
                timeInstructions: analysis.timeInstructions
              }) : null,
              isProcessing: false,
            };

            await storage.updateNote(note.id, updates);

            // Create todos if found
            if (analysis.todos && analysis.todos.length > 0) {
              for (const todo of analysis.todos) {
                try {
                  const todoData = {
                    title: todo.title,
                    isCompleted: false,
                    priority: todo.priority || 'medium',
                    due: todo.due || null,
                    noteId: note.id,
                    isTimeDependent: !!todo.due,
                    notificationSchedule: todo.due ? [todo.due] : null
                  };

                  await storage.createTodo(todoData);
                  console.log("Created todo:", todo.title);
                } catch (todoError) {
                  console.error("Error creating todo:", todoError);
                }
              }
            }

            // Create reminders if found
            if (analysis.reminders && analysis.reminders.length > 0) {
              for (const reminder of analysis.reminders) {
                try {
                  const reminderData = {
                    title: reminder.title,
                    completed: false,
                    priority: 'high',
                    noteId: note.id,
                    isActiveReminder: true,
                    reminderState: 'active',
                    dueDate: reminder.dueTime ? new Date(reminder.dueTime) : null,
                    timeDue: reminder.dueTime ? new Date(reminder.dueTime) : null
                  };

                  await storage.createTodo(reminderData);
                  console.log("Created reminder:", reminder.title, "for", reminder.dueTime);
                } catch (reminderError) {
                  console.error("Error creating reminder:", reminderError);
                }
              }
            }

            // Also check if timeInstructions suggest this should be a reminder
            if (analysis.timeInstructions?.hasTimeReference && analysis.timeInstructions.extractedTimes.length > 0) {
              // If we have time references but no explicit reminders, create one
              if (!analysis.reminders || analysis.reminders.length === 0) {
                try {
                  const defaultReminderTime = new Date();
                  defaultReminderTime.setDate(defaultReminderTime.getDate() + 1);
                  defaultReminderTime.setHours(9, 0, 0, 0);

                  const reminderData = {
                    title: `Reminder: ${content.slice(0, 50)}...`,
                    completed: false,
                    priority: 'medium',
                    noteId: note.id,
                    isActiveReminder: true,
                    reminderState: 'active',
                    dueDate: defaultReminderTime,
                    timeDue: defaultReminderTime
                  };

                  await storage.createTodo(reminderData);
                  console.log("Created auto-detected reminder for time-sensitive content");
                } catch (reminderError) {
                  console.error("Error creating auto-detected reminder:", reminderError);
                }
              }
            }

            console.log("Note updated with AI analysis:", note.id);
          })
            .catch((error: any) => {
              console.error("Error processing regular note with AI:", error);
              storage.updateNote(note.id, { isProcessing: false });
            });
        }
      } else {
        // If no content to process, just mark as not processing
        await storage.updateNote(note.id, { isProcessing: false });
      }

      console.log("Media note created successfully:", note.id);
      res.json(note);
    } catch (error: any) {
      console.error("Media note creation error:", error);
      console.error("Error stack:", error.stack);
      console.error("Request body keys:", Object.keys(req.body));
      console.error("Files received:", req.files ? Object.keys(req.files) : 'none');

      // Provide specific error details for mobile debugging
      let errorMessage = "Failed to create media note";
      if (error.message) {
        errorMessage += `: ${error.message}`;
      }

      res.status(500).json({ 
        message: errorMessage,
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      });
    }
  });

  app.post("/api/reprocess-notes", async (req, res) => {
    try {
      const { reprocessAllNotes } = await import("./reprocess-notes");
      await reprocessAllNotes();
      res.json({ success: true, message: "All notes reprocessed successfully" });
    } catch (error) {
      console.error("Error reprocessing notes:", error);
      res.status(500).json({ error: "Failed to reprocess notes" });
    }
  });

  // Intelligent Note Evolution Endpoint
  app.post("/api/notes/:id/evolve", async (req, res) => {
    try {
      const noteId = parseInt(req.params.id);
      const { instruction, existingContent, existingContext, existingTodos, existingRichContext } = req.body;

      if (!instruction || !existingContent) {
        return res.status(400).json({ message: "Instruction and existing content required" });
      }

      // Get the note to ensure it exists
      const note = await storage.getNote(noteId);
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }

      // Create comprehensive evolution prompt
      const evolutionPrompt = `You are an intelligent assistant helping to evolve and improve a user's note. Your goal is to understand the existing content deeply and apply the user's instruction to make it better, more complete, and more actionable.

EXISTING NOTE CONTENT:
${existingContent}

EXISTING AI CONTEXT:
${existingContext || 'None'}

EXISTING TODOS:
${existingTodos && existingTodos.length > 0 ? existingTodos.map((t: any) => `• ${t.title} ${t.completed ? '(✓ completed)' : '(pending)'}`).join('\n') : 'None'}

EXISTING RESEARCH/RICH CONTEXT:
${existingRichContext ? JSON.stringify(JSON.parse(existingRichContext), null, 2) : 'None'}

USER'S EVOLUTION INSTRUCTION:
"${instruction}"

Please intelligently evolve this note by:

1. UNDERSTANDING the current state and context
2. APPLYING the user's instruction thoughtfully
3. PRESERVING important existing information
4. ENHANCING with relevant details, next steps, or improvements
5. CHECKING OFF completed todos if the instruction indicates completion
6. ADDING new todos if the evolution suggests additional actions
7. RESEARCHING and adding relevant external information if appropriate
8. ORGANIZING the information better if needed

Rules:
- Don't lose obviously important information unless explicitly asked
- Be proactive and anticipate what the user might need next
- If the instruction mentions checking things off, update todo statuses
- If research is needed, provide relevant facts and resources
- If the instruction suggests adding items, create comprehensive additions
- Think like a knowledgeable assistant who is always 2 steps ahead

Respond with a JSON object containing:
{
  "enhancedContent": "The improved note content",
  "suggestion": "Brief explanation of what you evolved",
  "context": "Any new context or insights",
  "todos": ["Array of new todo items to add"],
  "todoUpdates": [{"id": number, "completed": boolean}], // for existing todos to update
  "collectionSuggestion": {"name": "string", "icon": "string", "color": "string"} or null,
  "richContext": {
    "recommendedActions": [{"title": "string", "description": "string", "links": [{"title": "string", "url": "string"}]}],
    "researchResults": [{"title": "string", "description": "string", "keyPoints": ["string"], "rating": "string"}],
    "quickInsights": ["string"]
  }
}`;

      console.log("Evolving note with instruction:", instruction);

      // Check if this is a media reprocessing request or image analysis request
      const isMediaReprocessRequest = instruction.toLowerCase().includes('rerun') || 
        instruction.toLowerCase().includes('reprocess') || 
        instruction.toLowerCase().includes('reanalyze') ||
        instruction.toLowerCase().includes('what does it say') ||
        instruction.toLowerCase().includes('what does this say') ||
        instruction.toLowerCase().includes('read the text') ||
        instruction.toLowerCase().includes('identify') ||
        instruction.toLowerCase().includes('tell me about') ||
        instruction.toLowerCase().includes('business intelligence') ||
        instruction.toLowerCase().includes('company') ||
        instruction.toLowerCase().includes('founders') ||
        instruction.toLowerCase().includes('business model') ||
        (instruction.toLowerCase().includes('image') && (instruction.toLowerCase().includes('again') || instruction.toLowerCase().includes('better')));

      let evolution;

      if (isMediaReprocessRequest && note.mediaUrl) {
        console.log("Media reprocessing request detected for note with image");

        // Combine original content with new instruction for reprocessing
        const combinedInstructions = `Original context: ${note.content}\n\nNew instructions: ${instruction}`;

        try {
          // Re-analyze the image with combined instructions using specialized image analysis
          const imageBase64 = await getImageAsBase64(note.mediaUrl);
          if (imageBase64 && isOpenAIAvailable()) {
            console.log("Using specialized OpenAI image analysis for evolution");
            console.log("Image base64 length:", imageBase64.length);
            const { analyzeImageContent } = await import('./openai');
            const imageAnalysis = await analyzeImageContent(imageBase64, combinedInstructions);

            // Convert image analysis to evolution format
            evolution = {
              enhancedContent: imageAnalysis.enhancedContent || combinedInstructions,
              suggestion: imageAnalysis.suggestion || "Image reanalyzed with new instructions",
              context: imageAnalysis.context || "",
              todos: imageAnalysis.todos || [],
              todoUpdates: [],
              collectionSuggestion: imageAnalysis.collectionSuggestion || null,
              richContext: imageAnalysis.richContext || null
            };
            console.log("Specialized image analysis completed for evolution");
          } else {
            console.log("Image base64 not available or OpenAI not available, falling back to text evolution");
            console.log("imageBase64 length:", imageBase64 ? imageBase64.length : "null");
            console.log("OpenAI available:", isOpenAIAvailable());
            // Fallback to text evolution if image retrieval fails
            evolution = await safeAnalyzeWithClaude(evolutionPrompt, "evolution");
          }
        } catch (error) {
          console.error("Image analysis failed, falling back to text evolution:", error);
          evolution = await safeAnalyzeWithClaude(evolutionPrompt, "evolution");
        }
      } else {
        // Check if this is a business intelligence or company research request
        const isBusinessIntelligenceRequest = instruction.toLowerCase().includes('business intelligence') ||
          instruction.toLowerCase().includes('company') ||
          instruction.toLowerCase().includes('market positioning') ||
          instruction.toLowerCase().includes('funding') ||
          instruction.toLowerCase().includes('anthropic') ||
          instruction.toLowerCase().includes('openai') ||
          instruction.toLowerCase().includes('competitive') ||
          instruction.toLowerCase().includes('recent developments');

        if (isBusinessIntelligenceRequest && isOpenAIAvailable()) {
          console.log("Using enhanced OpenAI analysis with company intelligence for evolution");
          evolution = await safeAnalyzeWithOpenAI(evolutionPrompt, "evolution");
        } else {
          // Regular text evolution
          evolution = await safeAnalyzeWithClaude(evolutionPrompt, "evolution");
        }
      }

      // Analyze instruction for safety before applying changes
      const isMinorChange = DataProtectionService.isMinorChange(instruction);
      const isRiskyChange = DataProtectionService.isRiskyChange(instruction);

      // Use data protection for content changes
      const protectionResult = await DataProtectionService.safeApplyAIChanges(
        noteId,
        existingContent,
        evolution,
        {
          changedBy: "ai_claude",
          userApproved: isMinorChange, // Auto-approve minor changes
          changeType: "ai_enhancement"
        }
      );

      if (!protectionResult.success) {
        // Return suggestions without applying changes for high-risk modifications
        return res.json({
          id: noteId,
          content: existingContent,
          aiSuggestion: evolution.suggestion,
          aiContext: evolution.context,
          warnings: protectionResult.warnings,
          requiresApproval: true,
          suggestedChanges: evolution.enhancedContent,
          riskLevel: "high"
        });
      }

      // Apply the protected changes
      const updates: any = {
        content: protectionResult.appliedChanges,
        aiEnhanced: true
      };

      // Only add fields if they have values
      if (evolution.suggestion) {
        updates.aiSuggestion = evolution.suggestion;
      }
      if (evolution.context) {
        updates.aiContext = evolution.context;
      }
      if (evolution.richContext) {
        updates.richContext = JSON.stringify(evolution.richContext);
      }
      if (protectionResult.warnings.length > 0) {
        updates.aiContext = (updates.aiContext || "") + "\n\nData Protection Warnings: " + protectionResult.warnings.join("; ");
      }

      // Update the note with protected content
      await storage.updateNote(noteId, updates);

      // Create new todos from AI analysis

      // Create new todos
      if (evolution.todos && evolution.todos.length > 0) {
        for (const todoTitle of evolution.todos) {
          await storage.createTodo({
            title: todoTitle,
            noteId: noteId,
            dependsOnTodoIds: [],
            triggersTodoIds: [],
            plannedNotificationStructure: {
              enabled: false,
              reminderCategory: "not_set",
              repeatPattern: "none",
              leadTimeNotifications: []
            }
          });
        }
      }

      // Handle collection suggestion
      if (evolution.collectionSuggestion) {
        const collections = await storage.getCollections();
        const existingCollection = collections.find(
          c => c.name.toLowerCase() === evolution.collectionSuggestion!.name.toLowerCase()
        );

        let collectionId = existingCollection?.id;
        if (!existingCollection) {
          const newCollection = await storage.createCollection(evolution.collectionSuggestion);
          collectionId = newCollection.id;
        }

        await storage.updateNote(noteId, { collectionId });
      }

      // Return the updated note
      const updatedNote = await storage.getNote(noteId);
      res.json(updatedNote);

    } catch (error) {
      console.error("Note evolution error:", error);
      res.status(500).json({ message: "Failed to evolve note" });
    }
  });

  // Quick rollback endpoint for reverting AI changes
  app.post("/api/notes/:noteId/rollback", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const { targetVersion } = req.body;

      if (!targetVersion) {
        return res.status(400).json({ message: "Target version is required" });
      }

      const success = await DataProtectionService.rollbackToVersion(noteId, targetVersion);

      if (success) {
        const updatedNote = await storage.getNote(noteId);
        res.json({ 
          success: true, 
          note: updatedNote,
          message: `Rolled back to version ${targetVersion}`
        });
      } else {
        res.status(400).json({ message: "Rollback failed" });
      }
    } catch (error) {
      console.error("Rollback error:", error);
      res.status(500).json({ message: "Failed to rollback note" });
    }
  });

  // Get version history for a note
  app.get("/api/notes/:noteId/versions", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const versions = await DataProtectionService.getVersionHistory(noteId);
      res.json(versions);
    } catch (error) {
      console.error("Version history error:", error);
      res.status(500).json({ message: "Failed to get version history" });
    }
  });

  // Approve pending AI changes
  app.post("/api/notes/:noteId/approve-changes", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const { suggestedChanges, userApproved } = req.body;

      if (!suggestedChanges) {
        return res.status(400).json({ message: "Suggested changes are required" });
      }

      // Get current note content
      const note = await storage.getNote(noteId);
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }

      // Apply the changes with user approval
      const protectionResult = await DataProtectionService.safeApplyAIChanges(
        noteId,
        note.content,
        { enhancedContent: suggestedChanges },
        {
          changedBy: "ai_claude",
          userApproved: userApproved,
          changeType: "ai_suggestion_applied"
        }
      );

      if (protectionResult.success) {
        await storage.updateNote(noteId, { 
          content: protectionResult.appliedChanges,
          aiEnhanced: true 
        });

        const updatedNote = await storage.getNote(noteId);
        res.json({ 
          success: true, 
          note: updatedNote,
          warnings: protectionResult.warnings
        });
      } else {
        res.status(400).json({ 
          success: false, 
          warnings: protectionResult.warnings 
        });
      }
    } catch (error) {
      console.error("Approve changes error:", error);
      res.status(500).json({ message: "Failed to approve changes" });
    }
  });

  // Re-clarify instruction endpoint for when AI misunderstood
  app.post("/api/notes/:noteId/clarify", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const { originalInstruction, clarification } = req.body;

      if (!clarification) {
        return res.status(400).json({ message: "Clarification is required" });
      }

      // Get the note
      const note = await storage.getNote(noteId);
      if (!note) {
        return res.status(404).json({ message: "Note not found" });
      }

      // Combine original instruction with clarification
      const enhancedInstruction = `Previous instruction: ${originalInstruction}\n\nClarification: ${clarification}\n\nPlease apply the clarified instruction accurately.`;

      // Process the clarified instruction (similar to note evolution)
      const evolutionPrompt = `You are helping enhance a note based on user clarification.

Current Note Content:
${note.content}

User's Clarified Instruction:
${enhancedInstruction}

Please provide an enhanced version that follows the clarified instruction precisely. Be conservative and only make the specific changes requested.

Respond with JSON: {"enhancedContent": "improved content", "suggestion": "what you changed", "todos": ["new todos if any"]}`;

      const evolution = await analyzeWithOpenAI(evolutionPrompt, "clarification");

      // Apply with higher confidence since user provided clarification
      const protectionResult = await DataProtectionService.safeApplyAIChanges(
        noteId,
        note.content,
        evolution,
        {
          changedBy: "ai_claude",
          userApproved: true, // User provided clarification, so approve
          changeType: "ai_enhancement"
        }
      );

      if (protectionResult.success) {
        await storage.updateNote(noteId, { 
          content: protectionResult.appliedChanges,
          aiEnhanced: true,
          aiSuggestion: evolution.suggestion
        });

        const updatedNote = await storage.getNote(noteId);
        res.json({ 
          success: true, 
          note: updatedNote,
          message: "Clarification applied successfully"
        });
      } else {
        res.status(400).json({ 
          success: false, 
          warnings: protectionResult.warnings 
        });
      }

    } catch (error) {
      console.error("Clarification error:", error);
      res.status(500).json({ message: "Failed to apply clarification" });
    }
  });

  // Media reprocessing endpoint for existing notes with images
  app.post("/api/reprocess-media/:noteId", async (req, res) => {
    try {
      const noteId = parseInt(req.params.noteId);
      const { instruction } = req.body;

      if (!instruction) {
        return res.status(400).json({ message: "Instruction is required" });
      }

      // Get the existing note
      const note = await storage.getNote(noteId);
      if (!note || !note.mediaUrl) {
        return res.status(404).json({ message: "Note with image not found" });
      }

      console.log("Media reprocessing request for note:", noteId);

      // Combine original content with new instruction
      const combinedInstructions = `Original context: ${note.content}\n\nNew instructions: ${instruction}`;

      // Get the image as base64
      const imageBase64 = await getImageAsBase64(note.mediaUrl);
      if (!imageBase64) {
        return res.status(400).json({ message: "Could not retrieve image file" });
      }

      // Re-analyze with OpenAI
      const analysisResult = await safeAnalyzeWithOpenAI(combinedInstructions, "image-reprocessing");

      // Return the enhanced analysis results
      res.json({
        enhancedContent: analysisResult.enhancedContent || combinedInstructions,
        suggestion: analysisResult.suggestion || "Image reprocessed with new instructions",
        context: analysisResult.context,
        todos: analysisResult.todos || [],
        richContext: analysisResult.richContext,
        success: true
      });

    } catch (error) {
      console.error("Media reprocessing error:", error);
      res.status(500).json({ message: "Failed to reprocess media" });
    }
  });

  // Media analysis endpoint for AI identification and web search
  app.post("/api/analyze-media", upload.single("image"), async (req, res) => {
    try {
      const file = req.file;
      const { analyzeOnly } = req.body;

      if (!file) {
        return res.status(400).json({ error: "No image file provided" });
      }

      let identification = "Image captured";
      let suggestedContext = "Please add context for this image";
      let webResults = null;

      if (isOpenAIAvailable()) {
        try {
          const analysisPrompt = `Analyze this image and provide valuable insights. Focus on:

1. IDENTIFY what this is (book title, product name, menu item, etc.)
2. Provide ACTIONABLE VALUE about it (price, reviews, where to get it, ratings, recommendations)
3. Create a newspaper-style headline (3-5 words max) that captures the key value
4. Write a description focused on usefulness, not the analysis process

Examples:
- For a book: "The Great Gatsby" → headline: "Classic American Literature" → description: "Critically acclaimed novel by F. Scott Fitzgerald. Often required reading. Available in multiple editions."
- For a restaurant menu: "Pizza Palace Menu" → headline: "Pizza Palace Prices" → description: "Local pizzeria with wood-fired options. Average price $15-25. Highly rated for authentic Italian style."
- For a product: "iPhone 15" → headline: "iPhone 15 Features" → description: "Latest Apple smartphone with improved camera and battery life. Starting at $799. Available in multiple colors."

Respond with JSON:
{
  "itemName": "specific item name",
  "headline": "3-5 word value-focused title",
  "description": "useful information about the item",
  "category": "book/product/food/etc",
  "keyValue": "main valuable insight"
}`;

          const analysisResult = await safeAnalyzeWithOpenAI(analysisPrompt, "image-analysis");

          // Parse the structured response
          try {
            // First try to parse the main content, then fall back to raw response
            let parsed: any = {};
            if (analysisResult.enhancedContent) {
              try {
                parsed = JSON.parse(analysisResult.enhancedContent);
              } catch {
                // If enhancedContent isn't JSON, try context or suggestion
                parsed = JSON.parse(analysisResult.context || analysisResult.suggestion || '{}');
              }
            }

            // Only use AI identification if it's meaningful, not placeholder text
            if (parsed.headline && parsed.headline !== "General content analysis") {
              identification = parsed.headline;
            } else if (parsed.itemName && parsed.itemName !== "General content analysis") {
              identification = parsed.itemName;
            } else if (parsed.title && parsed.title !== "General content analysis") {
              identification = parsed.title;
            } else {
              identification = ""; // No placeholder text
            }

            // Only use AI context if it's meaningful
            if (parsed.description && parsed.description !== "General content analysis") {
              suggestedContext = parsed.description;
            } else if (parsed.keyValue && parsed.keyValue !== "General content analysis") {
              suggestedContext = parsed.keyValue;
            } else {
              suggestedContext = ""; // No placeholder text
            }

            // Generate meaningful web search results based on the identified item  
            if (parsed.itemName && parsed.itemName !== "Image captured" && parsed.itemName !== "General content analysis") {
              const searchTerm = parsed.itemName;
              const category = parsed.category || "item";

              webResults = {
                fromTheWeb: [
                  {
                    title: `${searchTerm} Reviews & Ratings`,
                    description: `User reviews, ratings, and detailed analysis of ${searchTerm}`,
                    url: `https://search-results.com/${encodeURIComponent(searchTerm)}`,
                    rating: "4.5/5 stars",
                    keyPoints: ["Customer reviews", "Expert analysis", "Comparison with alternatives"],
                    source: "Review Platform"
                  },
                  {
                    title: `Best Price for ${searchTerm}`,
                    description: `Price comparison and where to buy ${searchTerm} at the best value`,
                    url: `https://shopping.com/${encodeURIComponent(searchTerm)}`,
                    rating: "4.7/5 stars", 
                    keyPoints: ["Price comparison", "Available retailers", "Deals and discounts"],
                    source: "Shopping Platform"
                  }
                ],
                nextSteps: [
                  `Compare prices for ${searchTerm}`,
                  "Read detailed reviews",
                  category === "book" ? "Check library availability" : "Find best retailer"
                ],
                keyInsights: [
                  parsed.keyValue || `${searchTerm} information captured`,
                  "Price and review data available",
                  "Ready for purchase decision"
                ]
              };
            }
          } catch (parseError) {
            // Only use meaningful AI results, no placeholder text
            identification = (analysisResult.context && analysisResult.context !== "General content analysis") ? analysisResult.context : "";
            suggestedContext = (analysisResult.suggestion && analysisResult.suggestion !== "General content analysis") ? analysisResult.suggestion : "";
          }

        } catch (error) {
          console.error("AI image analysis failed:", error);
        }
      }

      if (analyzeOnly === 'true') {
        // Only return identification if it's meaningful (not generic placeholder)
        const meaningfulIdentification = (identification === "Image captured" || identification === "General content analysis") 
          ? "" : (identification || "");

        return res.json({
          identification: meaningfulIdentification || "",
          suggestedContext: meaningfulIdentification ? suggestedContext : "",
          webResults: meaningfulIdentification ? webResults : null
        });
      }

      return res.json({ success: true });

    } catch (error) {
      console.error("Media analysis error:", error);
      res.status(500).json({ error: "Failed to analyze media" });
    }
  });

  // Object Storage endpoints for ChatGPT integration
  app.post("/api/storage/upload", async (req, res) => {
    try {
      const { filename, content, contentType = 'text/plain' } = req.body;

      if (!filename || !content) {
        return res.status(400).json({ error: "Filename and content required" });
      }

      const { ReplitStorage } = await import('./replit-storage');
      const downloadUrl = await ReplitStorage.saveForChatGPT(filename, content);

      res.json({ 
        success: true, 
        filename, 
        downloadUrl,
        message: "File saved to Replit Object Storage" 
      });
    } catch (error) {
      console.error("Storage upload error:", error);
      res.status(500).json({ error: "Failed to upload file" });
    }
  });

  app.get("/api/storage/files", async (req, res) => {
    try {
      const { ReplitStorage } = await import('./replit-storage');
      const files = await ReplitStorage.listFiles();
      res.json({ files });
    } catch (error) {
      console.error("Storage list error:", error);
      res.status(500).json({ error: "Failed to list files" });
    }
  });

  app.get("/api/storage/download/:filename", async (req, res) => {
    try {
      const { filename } = req.params;
      const { ReplitStorage } = await import('./replit-storage');
      const content = await ReplitStorage.downloadFile(filename);
      res.json({ filename, content });
    } catch (error) {
      console.error("Storage download error:", error);
      res.status(500).json({ error: "Failed to download file" });
    }
  });

  // Placeholder note creation endpoint
  app.post("/api/notes/placeholder", async (req, res) => {
    try {
      const { type, fileName, fileSize, mimeType, duration, content } = req.body;

      let placeholderContent = content || "";
      let aiTitle = "";

      // Generate AI title based on type and context
      if (type === "voice") {
        aiTitle = "Voice Recording";
        placeholderContent = content || "🎤 Recording voice note...";
      } else if (type === "image") {
        // Use AI to generate meaningful title from file context
        const contextPrompt = `Generate a concise, meaningful title for an image file. The user is saving this image for a reason. Based on the filename "${fileName}" and type "${mimeType}", suggest what this image might be about and why they're saving it. Respond with just the title, no quotes or extra text. Make it human and contextual, not technical.`;

        try {
          const titleResponse = await analyzeWithOpenAI(contextPrompt, "title-generation");
          aiTitle = titleResponse.enhancedContent || titleResponse.suggestion || "Image Upload";
        } catch (error) {
          aiTitle = "Image Upload";
        }

        placeholderContent = `📸 Processing image...`;
      } else if (type === "file") {
        // Use filename and type to generate meaningful context
        const extension = fileName.split('.').pop()?.toLowerCase() || '';
        const contextPrompt = `Generate a concise, meaningful title for a file the user is uploading. Filename: "${fileName}",Type: "${mimeType}". Consider why someone would save this type of file and what it might contain. Respond with just the title, no quotes or extra text. Make it human and contextual.`;

        try {
          const titleResponse = await analyzeWithOpenAI(contextPrompt, "title-generation");
          aiTitle = titleResponse.enhancedContent || titleResponse.suggestion || fileName;
        } catch (error) {
          aiTitle = fileName;
        }

        placeholderContent = `📄 Processing file...`;
      }

      // Create placeholder note
      const note = await storage.createNote({
        content: placeholderContent,
        mode: type || "text",
        aiSuggestion: aiTitle,
        isProcessing: true
      });

      res.json(note);
    } catch (error) {
      console.error("Failed to create placeholder note:", error);
      res.status(500).json({ message: "Failed to create placeholder note" });
    }
  });

  app.post("/api/notes/voice", upload.single("audio"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No audio file provided" });
      }

      // Check if duration is provided and validate minimum length
      const duration = req.body.duration ? parseFloat(req.body.duration) : null;
      if (duration !== null && duration < 1.5) {
        console.log(`Voice recording too short: ${duration}s, rejecting`);
        return res.status(400).json({ 
          message: "Recording too short",
          error: "Voice notes must be at least 1.5 seconds long."
        });
      }

      const noteId = req.body.noteId;
      let note;

      // Save audio file first
      let audioUrl = null;
      try {
        const savedAudio = await saveAudioFile(
          req.file.buffer, 
          `voice-${Date.now()}.webm`,
          req.file.mimetype || 'audio/webm'
        );
        audioUrl = savedAudio.url;
        console.log("Voice audio saved:", audioUrl);
      } catch (error) {
        console.error("Failed to save audio file:", error);
      }

      // Transcribe audio safely - never crash if AI fails
      let transcription = null;
      try {
        if (isOpenAIAvailable()) {
          transcription = await safeTranscribeAudio(req.file.buffer);
        } else {
          console.warn("Audio transcription skipped - OpenAI not available");
        }
      } catch (error) {
        console.error("Audio transcription failed:", error);
        // If transcription fails, reject the note creation instead of creating a placeholder
        return res.status(400).json({ 
          message: "Audio transcription failed",
          error: "Unable to process voice note. Please try again."
        });
      }

      // If no transcription was obtained, reject the request
      if (!transcription || transcription.trim().length === 0) {
        console.log("No transcription obtained, rejecting voice note");
        return res.status(400).json({ 
          message: "No audio content detected",
          error: "Unable to detect speech in the recording. Please try again."
        });
      }

      if (noteId) {
        // Update existing placeholder note
        note = await storage.updateNote(parseInt(noteId), {
          content: transcription,
          transcription,
          audioUrl,
          isProcessing: false,
        });
      } else {
        // Create new note (fallback)
        note = await storage.createNote({
          content: transcription,
          mode: "voice",
          transcription,
          audioUrl,
        });
      }

      // Process with Intelligence-V2 system via OpenAI (non-blocking)
      if (isOpenAIAvailable()) {
        const miraInput: MiraAIInput = {
          content: transcription,
          mode: "voice",
          timestamp: new Date().toISOString(),
          context: {
            timeOfDay: new Date().toLocaleTimeString(),
            recentActivity: []
          }
        };

        processNote(miraInput)
          .then(async (analysis: MiraAIResult) => {
            console.log("Mira AI analysis successful for voice note:", note.id);

            console.log("v2.0 Intelligence Layer analysis successful for voice note:", note.id);

            apiUsageStats.openai.requests++;
            apiUsageStats.totalRequests++;

            // Use v2.0 structured results
            const updates: any = {
              aiEnhanced: true,
              aiSuggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
              aiContext: analysis.summary || "",
              richContext: analysis.entities ? JSON.stringify({
                entities: analysis.entities,
                suggestedLinks: analysis.suggestedLinks,
                nextSteps: analysis.nextSteps,
                microQuestions: analysis.microQuestions,
                timeInstructions: analysis.timeInstructions
              }) : null,
              isProcessing: false,
            };

            // NEVER overwrite original transcription with AI analysis
            // The transcribed content must be preserved as the user's actual words

            await storage.updateNote(note.id, updates);

            // Create v2.0 todos if found
            console.log("Creating", analysis.todos?.length || 0, "v2.0 todos for voice note:", note.id);
            if (analysis.todos && analysis.todos.length > 0) {
              for (const todo of analysis.todos) {
                const todoData: any = {
                  title: todo.title,
                  noteId: note.id,
                };

                // Add v2.0 enhanced todo properties
                if (todo.due) {
                  todoData.timeDue = new Date(todo.due);
                }
                if (todo.recurrence) {
                  todoData.recurrenceRule = todo.recurrence; // RRULE format
                }
                if (todo.priority) {
                  todoData.priority = todo.priority;
                }

                await storage.createTodo(todoData);
              }
            }

            // Create collection if suggested with v2.0 hints
            if (analysis.collectionHint) {
              const collections = await storage.getCollections();
              const existingCollection = collections.find(
                c => c.name.toLowerCase() === analysis.collectionHint!.name.toLowerCase()
              );

              let collectionId = existingCollection?.id;
              if (!existingCollection) {
                const newCollection = await storage.createCollection({
                  name: analysis.collectionHint.name,
                  icon: analysis.collectionHint.icon || "folder",
                  color: analysis.collectionHint.colour || "#6366f1"
                });
                collectionId = newCollection.id;
              }

              await storage.updateNote(note.id, { collectionId });
            }
          })
          .catch(error => {
            console.error("Mira AI analysis failed:", error);
          });
      } else {
        console.warn("OpenAI not available - skipping voice note analysis");
      }

      res.json(note);
    } catch (error) {
      console.error("Voice note creation failed:", error);
      res.status(500).json({ message: "Failed to process voice note" });
    }
  });

  app.post("/api/notes/image", upload.single("image"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No image file provided" });
      }

      const noteId = req.body.noteId;
      let note;

      // Convert image to base64 for AI analysis
      const imageBase64 = req.file.buffer.toString('base64');

      if (noteId) {
        // Update existing placeholder note
        note = await storage.updateNote(parseInt(noteId), {
          content: `📸 Analyzing image...`,
          imageData: imageBase64,
          isProcessing: false,
        });
      } else {
        // Create new note (fallback)
        note = await storage.createNote({
          content: `[Image uploaded: ${req.file.originalname}]`,
          mode: "image",
          imageData: imageBase64,
        });
      }

      // Analyze image with AI in the background (non-blocking)
      if (isOpenAIAvailable()) {
        safeAnalyzeWithOpenAI(`data:${req.file.mimetype};base64,${imageBase64}`, "image")
          .then(async (analysis) => {
            const updates: any = {
            aiEnhanced: true,
            aiSuggestion: analysis.suggestion,
            aiContext: analysis.context,
          };

          if (analysis.enhancedContent) {
            updates.content = analysis.enhancedContent;
          }

          await storage.updateNote(note.id, updates);

          // Create todos if found
          for (const todoTitle of analysis.todos) {
            await storage.createTodo({
              title: todoTitle,
              noteId: note.id,
            });
          }

          // Create collection if suggested
          if (analysis.collectionSuggestion) {
            const collections = await storage.getCollections();
            const existingCollection = collections.find(
              c => c.name.toLowerCase() === analysis.collectionSuggestion!.name.toLowerCase()
            );

            let collectionId = existingCollection?.id;
            if (!existingCollection) {
              const newCollection = await storage.createCollection(analysis.collectionSuggestion);
              collectionId = newCollection.id;
            }

            await storage.updateNote(note.id, { collectionId });
          }
        })
          .catch(error => {
            console.error("AI image analysis failed:", error);
          });
      } else {
        console.warn("OpenAI not available - skipping image analysis");
      }

      res.json(note);
    } catch (error) {
      console.error("Image note creation failed:", error);
      res.status(500).json({ message: "Failed to process image" });
    }
  });

  app.post("/api/notes/file", upload.single("file"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file provided" });
      }

      const noteId = req.body.noteId;
      let note;

      if (noteId) {
        // Update existing placeholder note
        note = await storage.updateNote(parseInt(noteId), {
          content: `📄 Analyzing file...`,
          isProcessing: false,
        });
      } else {
        // Create new note (fallback)
        note = await storage.createNote({
          content: `[File uploaded: ${req.file.originalname}] - ${req.file.mimetype} (${Math.round(req.file.size / 1024)}KB)`,
          mode: "file",
        });
      }

      // Analyze file content with AI in the background
      let fileContent = `File: ${req.file.originalname} (${req.file.mimetype}, ${Math.round(req.file.size / 1024)}KB)`;

      // For text files, try to read content
      if (req.file.mimetype.startsWith('text/') || 
          req.file.mimetype === 'application/json' ||
          req.file.originalname?.endsWith('.md') ||
          req.file.originalname?.endsWith('.txt')) {
        try {
          fileContent += `\n\nContent:\n${req.file.buffer.toString('utf-8')}`;
        } catch (error) {
          console.log("Could not read file as text:", error);
        }
      }

      const miraInput: MiraAIInput = {
        content: fileContent,
        mode: "file",
        timestamp: new Date().toISOString(),
        context: {
          fileName: req.file?.originalname || "unknown",
          fileType: req.file?.mimetype || "unknown"
        }
      };

      processNote(miraInput)
        .then(async (analysis: MiraAIResult) => {
          const updates: any = {
            aiEnhanced: true,
            aiSuggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
            aiContext: analysis.summary || "",
            richContext: analysis.entities ? JSON.stringify({
              entities: analysis.entities,
              suggestedLinks: analysis.suggestedLinks,
              nextSteps: analysis.nextSteps,
              microQuestions: analysis.microQuestions,
              timeInstructions: analysis.timeInstructions
            }) : null,
            isProcessing: false
          };

          // Use v2.0 title as content if available
          if (analysis.title && analysis.title !== fileContent.substring(0, 100)) {
            updates.content = analysis.title;
          }

          await storage.updateNote(note.id, updates);

          // Create v2.0 todos if found
          if (analysis.todos && analysis.todos.length > 0) {
            for (const todo of analysis.todos) {
              const todoData: any = {
                title: todo.title,
                noteId: note.id,
              };

              // Add v2.0 enhanced todo properties
              if (todo.due) {
                todoData.timeDue = new Date(todo.due);
              }
              if (todo.recurrence) {
                todoData.recurrenceRule = todo.recurrence;
              }
              if (todo.priority) {
                todoData.priority = todo.priority;
              }

              await storage.createTodo(todoData);
            }
          }

          // Create collection if suggested with v2.0 hints
          if (analysis.collectionHint) {
            const collections = await storage.getCollections();
            const existingCollection = collections.find(
              c => c.name.toLowerCase() === analysis.collectionHint!.name.toLowerCase()
            );

            let collectionId = existingCollection?.id;
            if (!existingCollection) {
              const newCollection = await storage.createCollection({
                name: analysis.collectionHint.name,
                icon: analysis.collectionHint.icon || "folder",
                color: analysis.collectionHint.colour || "#6366f1"
              });
              collectionId = newCollection.id;
            }

            await storage.updateNote(note.id, { collectionId });
          }
        })
        .catch((error: any) => {
          console.error("AI file analysis failed:", error);
        });

      res.json(note);
    } catch (error) {
      console.error("File note creation failed:", error);
      res.status(500).json({ message: "Failed to process file" });
    }
  });

  // PATCH route for note updates (including context-aware AI modifications)
  app.patch("/api/notes/:id", async (req, res) => {
    try {
      const noteId = parseInt(req.params.id);
      const { content, updateInstruction, contextUpdate, ...otherUpdates } = req.body;

      // Get the existing note
      const existingNote = await storage.getNote(noteId);
      if (!existingNote) {
        return res.status(404).json({ message: "Note not found" });
      }

      // If this is just a direct content update (like iOS Notes typing), save it directly
      if (content && !updateInstruction && !contextUpdate) {
        console.log("Direct content update - saving like iOS Notes");
        const updatedNote = await storage.updateNote(noteId, { 
          content: content.trim(),
          lastUserEdit: new Date().toISOString(),
          ...otherUpdates 
        });
        return res.json(updatedNote);
      }

      // If there's an updateInstruction, use AI to intelligently modify the note
      if (updateInstruction) {
        console.log("Processing AI-assisted note update:", updateInstruction);

        try {
          // Create comprehensive context for AI
          const fullContext = {
            currentContent: existingNote.content,
            todos: existingNote.todos || [],
            richContext: existingNote.richContext,
            aiContext: existingNote.aiContext,
            userModification: updateInstruction
          };

          // Use the existing evolution endpoint logic
          const evolutionPrompt = `You are an intelligent assistant helping to evolve and improve a user's note. Your goal is to understand the existing content deeply and apply the user's instruction to make it better, more complete, and more actionable.

EXISTING NOTE CONTENT:
${existingNote.content}

EXISTING AI CONTEXT:
${existingNote.aiContext || 'None'}

EXISTING TODOS:
${existingNote.todos && existingNote.todos.length > 0 ? existingNote.todos.map((t: any) => `• ${t.title} ${t.completed ? '(✓ completed)' : '(pending)'}`).join('\n') : 'None'}

EXISTING RESEARCH/RICH CONTEXT:
${existingNote.richContext ? JSON.stringify(JSON.parse(existingNote.richContext), null, 2) : 'None'}

USER'S EVOLUTION INSTRUCTION:
"${updateInstruction}"

Please intelligently evolve this note by:
1. UNDERSTANDING the current state and context
2. APPLYING the user's instruction thoughtfully
3. PRESERVING important existing information
4. ENHANCING with relevant details, next steps, or improvements
5. CHECKING OFF completed todos if the instruction indicates completion
6. ADDING new todos if the evolution suggests additional actions

Respond with a JSON object containing:
{
  "enhancedContent": "The improved note content",
  "suggestion": "Brief explanation of what you evolved",
  "context": "Any new context or insights",
  "todos": ["Array of new todo items to add"],
  "todoUpdates": [{"id": number, "completed": boolean}],
  "collectionSuggestion": {"name": "string", "icon": "string", "color": "string"} or null,
  "richContext": {
    "nextSteps": ["string"],
    "entities": [{"type": "string", "value": "string"}],
    "microQuestions": ["string"]
  }
}`;

          // Use available AI service for evolution
          let evolution;
          if (isOpenAIAvailable()) {
            evolution = await analyzeWithOpenAI(evolutionPrompt, "evolution");
          } else if (isOpenAIAvailable()) {
            evolution = await safeAnalyzeWithOpenAI(evolutionPrompt, "evolution");
          } else {
            throw new Error("No AI service available");
          }

          // Apply the evolution to the note
          const updates: any = {
            content: evolution.enhancedContent || existingNote.content,
            aiSuggestion: evolution.suggestion,
            aiContext: evolution.context,
            aiEnhanced: true
          };

          // Add rich context if provided
          if (evolution.richContext) {
            updates.richContext = JSON.stringify(evolution.richContext);
          }

          // Update the note
          const updatedNote = await storage.updateNote(noteId, updates);

          // Create new todos if provided
          if (evolution.todos && evolution.todos.length > 0) {
            for (const todoTitle of evolution.todos) {
              await storage.createTodo({
                title: todoTitle,
                noteId: noteId,
              });
            }
          }

          // Update existing todos if specified
          if (evolution.todoUpdates && evolution.todoUpdates.length > 0) {
            for (const todoUpdate of evolution.todoUpdates) {
              await storage.updateTodo(todoUpdate.id, { completed: todoUpdate.completed });
            }
          }

          // Handle collection suggestion
          if (evolution.collectionSuggestion) {
            const collections = await storage.getCollections();
            const existingCollection = collections.find(
              c => c.name.toLowerCase() === evolution.collectionSuggestion!.name.toLowerCase()
            );

            let collectionId = existingCollection?.id;
            if (!existingCollection) {
              const newCollection = await storage.createCollection(evolution.collectionSuggestion);
              collectionId = newCollection.id;
            }

            await storage.updateNote(noteId, { collectionId });
          }

          // Return the updated note with todos
          const finalNote = await storage.getNote(noteId);
          res.json(finalNote);

        } catch (aiError) {
          console.error("AI evolution failed:", aiError);
          // Fallback to simple content update if AI fails
          const updatedNote = await storage.updateNote(noteId, { 
            content: content || existingNote.content, 
            lastUserEdit: new Date().toISOString(),
            ...otherUpdates 
          });
          return res.json(updatedNote);
        }
      } else {
        // Simple update without AI for direct edits
        const updatedNote = await storage.updateNote(noteId, { 
          content: content || existingNote.content,
          lastUserEdit: new Date().toISOString(),
          ...otherUpdates 
        });
        return res.json(updatedNote);
      }

    } catch (error) {
      console.error("Note update error:", error);
      res.status(500).json({ message: "Failed to update note" });
    }
  });

  // Todos endpoints
  app.get("/api/todos", async (req, res) => {
    try {
      const todos = await storage.getTodos();
      res.json(todos);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch todos" });
    }
  });

  app.patch("/api/todos/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const todo = await storage.updateTodo(id, req.body);
      res.json(todo);
    } catch (error) {
      res.status(404).json({ message: "Todo not found" });
    }
  });

  app.get("/api/todos/:id/context", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const todos = await storage.getTodos();
      const todo = todos.find(t => t.id === id);

      if (!todo) {
        return res.status(404).json({ message: "Todo not found" });
      }

      // Get the source note for this todo
      const sourceNote = await storage.getNote(todo.noteId);

      // Get related todos from the same note
      const relatedTodos = todos.filter(t => t.noteId === todo.noteId && t.id !== todo.id);

      // Generate AI context for this specific todo
      const prompt = `Provide intelligent context and insights for this todo item: "${todo.title}"

Source context: ${sourceNote?.content || 'No source context available'}

Focus on:
1. Why this task is important based on the source context
2. Any helpful tips or considerations for completing this task
3. Connections to related information from the source

Provide a concise, actionable response that adds value beyond just the task title.`;

      try {
        const aiResult = await analyzeWithOpenAI(prompt, "todo-context");

        const todoContext = {
          todo,
          sourceNote,
          aiContext: aiResult.enhancedContent || aiResult.suggestion,
          insights: [
            aiResult.context,
            ...aiResult.todos.filter((t: string) => t !== todo.title).map((t: string) => `Related: ${t}`)
          ].filter(Boolean),
          relatedTodos
        };

        res.json(todoContext);
      } catch (aiError) {
        // Fallback response without AI context if AI fails
        const todoContext = {
          todo,
          sourceNote,
          aiContext: undefined,
          insights: [],
          relatedTodos
        };
        res.json(todoContext);
      }
    } catch (error) {
      console.error("Todo context error:", error);
      res.status(500).json({ message: "Failed to fetch todo context" });
    }
  });

  // Collections endpoints
  app.get("/api/collections", async (req, res) => {
    try {
      const collections = await storage.getCollections();
      const collectionsWithCounts = await Promise.all(
        collections.map(async (collection) => {
          const notes = await storage.getNotesByCollectionId(collection.id);
          // Count only meaningful notes (exclude welcome notes and empty content)
          const meaningfulNotes = notes.filter(note => 
            note.content && 
            note.content.trim().length > 10 && 
            !note.content.startsWith('🎉 Welcome to Mira')
          );

          // Count open todos for this collection
          const openTodoCount = notes.reduce((count, note) => {
            const openTodos = note.todos.filter(todo => !todo.completed);
            return count + openTodos.length;
          }, 0);

          return { 
            ...collection, 
            noteCount: meaningfulNotes.length,
            openTodoCount 
          };
        })
      );
      res.json(collectionsWithCounts);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collections" });
    }
  });

  app.get("/api/collections/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }
      res.json(collection);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collection" });
    }
  });

  app.get("/api/collections/:id/notes", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const notes = await storage.getNotesByCollectionId(id);
      res.json(notes);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch collection notes" });
    }
  });

  // GET route for super-note - automatically generates if not exists
  app.get("/api/collections/:id/super-note", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }

      const notes = await storage.getNotesByCollectionId(id);

      // Handle empty collections
      if (notes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `This is your ${collection.name} collection. Start adding notes and they'll appear here with AI-powered insights and organization.`,
          description: "Start adding notes to see them organized here",
          insights: [
            `Your ${collection.name} collection is ready to capture and organize your thoughts.`,
            "Add notes to this collection to see intelligent summaries and connections.",
            "AI will help extract tasks, insights, and organize your content automatically."
          ],
          structuredItems: {
            recommendedActions: [],
            researchResults: [],
            quickInsights: [`Empty ${collection.name} collection - ready for your content`]
          },
          allTodos: [],
          items: [],
          notes: [],
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Filter out notes with no meaningful content
      const meaningfulNotes = notes.filter(note => 
        note.content && 
        note.content.trim().length > 10 && 
        !note.content.startsWith('🎉 Welcome to Mira')
      );

      if (meaningfulNotes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `Your ${collection.name} collection contains ${notes.length} note(s), but they need more content for meaningful analysis.`,
          description: "Add more detailed content to unlock AI insights",
          insights: [
            "Add more detailed content to your notes for better AI insights.",
            `${collection.name} collection is ready for meaningful content.`
          ],
          structuredItems: {
            recommendedActions: [{ 
              title: "Add detailed content", 
              description: "Write more comprehensive notes to unlock AI-powered insights and organization." 
            }],
            researchResults: [],
            quickInsights: [`${notes.length} note(s) in ${collection.name} - add more detail for insights`]
          },
          allTodos: [],
          items: [],
          notes: meaningfulNotes,
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Get all todos from meaningful notes
      const allTodos = meaningfulNotes.flatMap(note => note.todos || []);

      // Get all items from this collection
      const collectionItems = await storage.getItemsByCollectionId(id);

      // Create aggregated content based on collection type
      let collectionContent = '';
      let collectionDescription = '';

      if (collectionItems.length > 0) {
        // Group items by type for better organization
        const itemsByType = collectionItems.reduce((acc: any, item) => {
          const type = item.type || 'item';
          if (!acc[type]) acc[type] = [];
          acc[type].push(item);
          return acc;
        }, {});

        // Create content based on collection type
        const collectionName = collection.name.toLowerCase();
        if (collectionName.includes('movie') || collectionName.includes('tv')) {
          collectionContent = '🎬 Movies & Shows:\n';
          collectionDescription = 'Movies and TV shows to watch';
        } else if (collectionName.includes('book') || collectionName.includes('read')) {
          collectionContent = '📚 Books & Reading:\n';
          collectionDescription = 'Books and reading materials';
        } else if (collectionName.includes('restaurant') || collectionName.includes('food')) {
          collectionContent = '🍽️ Restaurants & Food:\n';
          collectionDescription = 'Places to eat and food to try';
        } else {
          collectionContent = `📋 ${collection.name} Items:\n`;
          collectionDescription = `Items in your ${collection.name} collection`;
        }

        // Add each item as a line
        collectionItems.forEach(item => {
          collectionContent += `• ${item.title}`;
          if (item.description) {
            collectionContent += ` - ${item.description}`;
          }
          collectionContent += '\n';
        });
      } else {
        collectionContent = `Add notes with specific ${collection.name.toLowerCase()} to see them organized here.`;
        collectionDescription = `Items will appear here when extracted from your notes`;
      }

      const superNoteData = {
        collection,
        aggregatedContent: collectionContent,
        description: collectionDescription,
        insights: [
          `${collectionItems.length} individual items tracked`,
          `${allTodos.length} related tasks`,
          `${meaningfulNotes.length} source notes`
        ].filter(Boolean),
        structuredItems: {
          recommendedActions: allTodos.slice(0, 5).map((todo: any) => ({
            title: todo.title,
            description: "Task from your notes",
            noteId: todo.noteId
          })),
          extractedItems: collectionItems.map(item => ({
            title: item.title,
            description: item.description || '',
            type: item.type,
            sourceNoteId: item.sourceNoteId
          })),
          quickInsights: [
            `${collectionItems.length} items extracted`,
            `${allTodos.length} tasks available`,
            `${meaningfulNotes.length} notes in collection`
          ]
        },
        allTodos: allTodos,
        items: collectionItems,
        notes: meaningfulNotes,
        itemCount: collectionItems.length,
        todoCount: allTodos.length
      };

      res.json(superNoteData);
    } catch (error) {
      console.error("Super note fetch error:", error);
      res.status(500).json({ message: "Failed to fetch super note" });
    }
  });

  app.post("/api/collections/:id/super-note", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const collection = await storage.getCollection(id);
      if (!collection) {
        return res.status(404).json({ message: "Collection not found" });
      }

      const notes = await storage.getNotesByCollectionId(id);

      // Handle empty collections
      if (notes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `This is your ${collection.name} collection. Start adding notes and they'll appear here with AI-powered insights and organization.`,
          insights: [
            `Your ${collection.name} collection is ready to capture and organize your thoughts.`,
            "Add notes to this collection to see intelligent summaries and connections.",
            "AI will help extract tasks, insights, and organize your content automatically."
          ],
          structuredItems: {
            recommendedActions: [],
            researchResults: [],
            quickInsights: [`Empty ${collection.name} collection - ready for your content`]
          },
          allTodos: [],
          notes: [],
          itemCount: 0,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Filter out notes with no meaningful content
      const meaningfulNotes = notes.filter(note => 
        note.content && 
        note.content.trim().length > 10 && 
        !note.content.startsWith('🎉 Welcome to Mira')
      );

      if (meaningfulNotes.length === 0) {
        const superNoteData = {
          collection,
          aggregatedContent: `Your ${collection.name} collection contains ${notes.length} note(s), but they need more content for meaningful analysis.`,
          insights: [
            "Add more detailed content to your notes for better AI insights.",
            `${collection.name} collection is ready for meaningful content.`
          ],
          structuredItems: {
            recommendedActions: [{ 
              title: "Add detailed content", 
              description: "Write more comprehensive notes to unlock AI-powered insights and organization." 
            }],
            researchResults: [],
            quickInsights: [`${notes.length} note(s) in ${collection.name} - add more detail for insights`]
          },
          allTodos: [],
          notes: meaningfulNotes,
          itemCount: meaningfulNotes.length,
          todoCount: 0
        };
        return res.json(superNoteData);
      }

      // Get individual items extracted from notes in this collection
      const collectionItems = await storage.getItemsByCollectionId(id);
      const allTodos = meaningfulNotes.flatMap(note => note.todos || []);

      // Create collection-specific content based on type
      let collectionContent = "";
      let collectionDescription = "";

      const collectionName = collection.name.toLowerCase();

      if (collectionName.includes('book')) {
        collectionDescription = "Your reading list and book recommendations";
        collectionContent = collectionItems.length > 0 
          ? `📚 Books in your collection:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No books have been extracted yet. Add notes mentioning specific books to see them here.";
      } else if (collectionName.includes('movie') || collectionName.includes('tv')) {
        collectionDescription = "Movies and TV shows to watch";
        collectionContent = collectionItems.length > 0 
          ? `🎬 Movies & Shows:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No movies or shows have been extracted yet. Add notes mentioning specific titles to see them here.";
      } else if (collectionName.includes('restaurant') || collectionName.includes('food')) {
        collectionDescription = "Places to eat and food recommendations";
        collectionContent = collectionItems.length > 0 
          ? `🍽️ Restaurants & Food:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No restaurants have beenextracted yet. Add notes mentioning specific places to eat to see them here.";
      } else if (collectionName.includes('product')) {
        collectionDescription = "Products and items of interest";
        collectionContent = collectionItems.length > 0 
          ? `🛍️ Products:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No products have been extracted yet. Add notes mentioning specific products to see them here.";
      } else if (collectionName.includes('place') || collectionName.includes('travel')) {
        collectionDescription = "Places to visit and travel destinations";
        collectionContent = collectionItems.length > 0 
          ? `📍 Places:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No places have been extracted yet. Add notes mentioning specific locations to see them here.";
      } else if (collectionName.includes('person') || collectionName.includes('contact')) {
        collectionDescription = "People and contacts";
        collectionContent = collectionItems.length > 0 
          ? `👥 People:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : "No people have been extracted yet. Add notes mentioning specific individuals to see them here.";
      } else {
        // Generic collection
        collectionDescription = `Your ${collection.name} collection`;
        collectionContent = collectionItems.length > 0 
          ? `📋 Items:\n${collectionItems.map(item => `• ${item.title}${item.description ? ` - ${item.description}` : ''}`).join('\n')}`
          : `No specific items have been extracted yet. Add notes with specific ${collection.name.toLowerCase()} to see them organized here.`;
      }

      const superNoteData = {
        collection,
        aggregatedContent: collectionContent,
        description: collectionDescription,
        insights: [
          `${collectionItems.length} individual items tracked`,
          `${allTodos.length} related tasks`,
          `${meaningfulNotes.length} source notes`
        ].filter(Boolean),
        structuredItems: {
          recommendedActions: allTodos.slice(0, 5).map(todo => ({
            title: todo.title,
            description: "Task from your notes",
            noteId: todo.noteId
          })),
          extractedItems: collectionItems.map(item => ({
            title: item.title,
            description: item.description || '',
            type: item.type,
            sourceNoteId: item.sourceNoteId
          })),
          quickInsights: [
            `${collectionItems.length} items extracted`,
            `${allTodos.length} tasks available`,
            `${meaningfulNotes.length} notes in collection`
          ]
        },
        allTodos: allTodos,
        items: collectionItems,
        notes: meaningfulNotes,
        itemCount: collectionItems.length,
        todoCount: allTodos.length
      };

      res.json(superNoteData);
    } catch (error) {
      console.error("Super note generation error:", error);
      res.status(500).json({ message: "Failed to generate super note" });
    }
  });

  app.post("/api/collections", async (req, res) => {
    try {
      const collectionData = insertCollectionSchema.parse(req.body);
      const collection = await storage.createCollection(collectionData);
      res.json(collection);
    } catch (error) {
      res.status(400).json({ message: "Invalid collection data" });
    }
  });

  app.post("/api/collections/reorder", async (req, res) => {
    try {
      const { updates } = req.body;

      if (!updates || !Array.isArray(updates)) {
        return res.status(400).json({ message: "Updates array required" });
      }

      // Update each collection's display order
      for (const update of updates) {
        await storage.updateCollection(update.id, { displayOrder: update.displayOrder });
      }

      res.json({ success: true });
    } catch (error) {
      console.error("Collection reorder error:", error);
      res.status(500).json({ message: "Failed to reorder collections" });
    }
  });

  // Items API routes
  app.get("/api/items", async (req, res) => {
    try {
      const items = await storage.getItems();
      res.json(items);
    } catch (error) {
      console.error("Failed to fetch items:", error);
      res.status(500).json({ message: "Failed to fetch items" });
    }
  });

  app.get("/api/collections/:id/items", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const items = await storage.getItemsByCollectionId(id);
      res.json(items);
    } catch (error) {
      console.error("Failed to fetch collection items:", error);
      res.status(500).json({ message: "Failed to fetch collection items" });
    }
  });

  app.post("/api/items", async (req, res) => {
    try {
      const itemData = insertItemSchema.parse(req.body);
      const item = await storage.createItem(itemData);
      res.json(item);
    } catch (error) {
      console.error("Failed to create item:", error);
      res.status(400).json({ message: "Invalid item data" });
    }
  });

  app.patch("/api/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const item = await storage.updateItem(id, updates);
      res.json(item);
    } catch (error) {
      console.error("Failed to update item:", error);
      res.status(500).json({ message: "Failed to update item" });
    }
  });

  app.delete("/api/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteItem(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete item:", error);
      res.status(500).json({ message: "Failed to delete item" });
    }
  });

  // Reminder endpoints for consolidated todo approach
  app.post("/api/reminders", async (req, res) => {
    try {
      const { title, description, reminderTime, todoId, noteId } = req.body;
      const reminder = await storage.createReminder({
        title,
        description,
        reminderTime: new Date(reminderTime),
        todoId,
        noteId
      });
      res.json(reminder);
    } catch (error) {
      console.error("Failed to create reminder:", error);
      res.status(500).json({ message: "Failed to create reminder" });
    }
  });



  // Add optional todo to main todos list
  app.post("/api/todos/add-optional", async (req, res) => {
    try {
      const { title, noteId, description } = req.body;
      const todo = await storage.createTodo({
        title,
        noteId
      });
      res.json(todo);
    } catch (error) {
      console.error("Failed to add optional todo:", error);
      res.status(500).json({ message: "Failed to add optional todo" });
    }
  });

  // Notification system endpoints
  app.get("/api/notifications/status", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const status = notificationSystem.getNotificationStatus();
      res.json(status);
    } catch (error) {
      console.error("Failed to get notification status:", error);
      res.status(500).json({ message: "Failed to get notification status" });
    }
  });

  app.post("/api/notifications/refresh", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      const status = notificationSystem.getNotificationStatus();
      res.json({ message: "Notifications refreshed", status });
    } catch (error) {
      console.error("Failed to refresh notifications:", error);
      res.status(500).json({ message: "Failed to refresh notifications" });
    }
  });

  app.post("/api/todos/:id/toggle", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const todo = await storage.updateTodo(id, { completed: !req.body.completed });

      // If completing a reminder, refresh notification schedules
      if (todo.isActiveReminder) {
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.refreshNotifications();
      }

      res.json(todo);
    } catch (error) {
      console.error("Failed to toggle todo:", error);
      res.status(500).json({ message: "Failed to toggle todo" });
    }
  });

  // Enhanced todo creation for reminders
  app.post("/api/todos", async (req, res) => {
    try {
      const todoData = insertTodoSchema.parse(req.body);

      // Ensure isActiveReminder defaults to false if not specified
      const enhancedTodoData = {
        ...todoData,
        isActiveReminder: todoData.isActiveReminder || false,
        completed: todoData.completed || false,
        archived: todoData.archived || false
      };

      const todo = await storage.createTodo(enhancedTodoData);

      // If this is an active reminder, schedule notifications
      if (todo.isActiveReminder && todo.timeDue) {
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.scheduleNotifications(todo);
      }

      res.json(todo);
    } catch (error) {
      console.error("Failed to create todo:", error);
      res.status(400).json({ message: "Invalid todo data" });
    }
  });

  // Notification system endpoints
  app.get("/api/notifications/status", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const status = notificationSystem.getNotificationStatus();
      res.json(status);
    } catch (error) {
      console.error("Failed to get notification status:", error);
      res.status(500).json({ message: "Failed to get notification status" });
    }
  });

  app.get("/api/notifications/recent", async (req, res) => {
    try {
      // Return recent notifications (placeholder for now)
      res.json({ recent: [] });
    } catch (error) {
      console.error("Failed to get recent notifications:", error);
      res.status(500).json({ message: "Failed to get recent notifications" });
    }
  });

  app.post("/api/notifications/test", async (req, res) => {
    try {
      const { notificationSystem } = await import('./notification-system');
      const { title, message, scheduledTime } = req.body;
      
      // Create a test notification
      console.log(`🔔 Test notification: ${title} - ${message} at ${scheduledTime}`);
      
      res.json({ 
        success: true, 
        message: "Test notification created",
        scheduledTime 
      });
    } catch (error) {
      console.error("Failed to create test notification:", error);
      res.status(500).json({ message: "Failed to create test notification" });
    }
  });

  // Reminder state management endpoints
  app.post("/api/reminders/parse", async (req, res) => {
    try {
      const { content } = req.body;
      const { IntelligentReminderParser } = await import('./utils/intelligent-reminder-parser');
      const parsed = IntelligentReminderParser.parseReminder(content);
      
      let timeString = null;
      let leadTime = null;
      
      if (parsed.timeReference) {
        timeString = parsed.timeReference.originalText;
      }
      
      if (parsed.context) {
        leadTime = `${parsed.context.defaultLeadTime}`;
      }
      
      res.json({
        isReminder: parsed.isReminder,
        timeString,
        leadTime,
        dueTime: parsed.timeReference?.parsedTime,
        recurrence: parsed.recurringPattern,
        category: parsed.context?.type,
        urgency: parsed.context?.urgency
      });
    } catch (error) {
      console.error("Failed to parse reminder:", error);
      res.status(500).json({ message: "Failed to parse reminder" });
    }
  });

  app.post("/api/reminders", async (req, res) => {
    try {
      const { content, parsedInfo } = req.body;
      
      // Create note first
      const note = await storage.createNote({
        content,
        mode: "text"
      });

      // Process with AI to create reminder
      const miraModule = await import('./brain/miraAIProcessing');
      const analysis = await miraModule.processNote({
        content,
        mode: "text",
        req
      });

      // Update note with AI analysis
      await storage.updateNote(note.id, {
        content: analysis.title,
        aiEnhanced: true,
        aiSuggestion: analysis.smartActions?.map((a: any) => `${a.label}: ${a.action}`).join(", ") || "",
        aiContext: analysis.summary || "",
        isProcessing: false
      });

      // Create reminder todo with proper state
      if (analysis.todos && analysis.todos.length > 0) {
        const todo = analysis.todos[0];
        const reminderData: any = {
          noteId: note.id,
          title: todo.title,
          isActiveReminder: true,
          reminderState: 'active',
          priority: todo.priority || 'medium'
        };

        if (parsedInfo?.dueTime) {
          reminderData.dueDate = new Date(parsedInfo.dueTime);
          reminderData.timeDue = new Date(parsedInfo.dueTime);
        }

        if (parsedInfo?.recurrence) {
          reminderData.recurrenceRule = parsedInfo.recurrence;
        }

        const createdTodo = await storage.createTodo(reminderData);
        
        // Refresh notifications
        const { notificationSystem } = await import('./notification-system');
        await notificationSystem.refreshNotifications();

        res.json({
          id: createdTodo.id,
          title: createdTodo.title,
          dueDate: createdTodo.dueDate,
          reminderState: createdTodo.reminderState,
          note: note
        });
      } else {
        res.status(400).json({ message: "Failed to create reminder from input" });
      }
    } catch (error) {
      console.error("Failed to create reminder:", error);
      res.status(500).json({ message: "Failed to create reminder" });
    }
  });

  app.get("/api/reminders", async (req, res) => {
    try {
      const { state } = req.query;
      console.log(`Fetching reminders with state filter: ${state}`);
      
      const todos = await storage.getTodos();
      console.log(`Total todos: ${todos.length}`);
      
      let reminders = todos.filter(todo => todo.isActiveReminder === true);
      console.log(`Filtered active reminders: ${reminders.length}`);
      
      if (state && state !== 'all') {
        reminders = reminders.filter(todo => todo.reminderState === state);
        console.log(`After state filter '${state}': ${reminders.length}`);
      }
      
      // Transform todos to reminder format expected by frontend
      const transformedReminders = reminders.map(todo => ({
        id: todo.id,
        title: todo.title,
        dueDate: todo.dueDate || todo.timeDue,
        reminderState: todo.reminderState || 'active',
        priority: todo.priority,
        reminderType: todo.plannedNotificationStructure?.reminderCategory || 'general',
        completed: todo.completed,
        createdAt: todo.createdAt
      }));
      
      console.log(`Returning ${transformedReminders.length} transformed reminders`);
      res.json(transformedReminders);
    } catch (error) {
      console.error("Failed to fetch reminders:", error);
      res.status(500).json({ message: "Failed to fetch reminders" });
    }
  });

  app.put("/api/reminders/:id/complete", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        completed: true,
        reminderState: 'completed'
      });
      
      // Refresh notifications
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to complete reminder:", error);
      res.status(500).json({ message: "Failed to complete reminder" });
    }
  });

  app.put("/api/reminders/:id/dismiss", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        reminderState: 'dismissed',
        dismissedAt: new Date()
      });
      
      // Refresh notifications
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to dismiss reminder:", error);
      res.status(500).json({ message: "Failed to dismiss reminder" });
    }
  });

  app.put("/api/reminders/:id/archive", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updatedTodo = await storage.updateTodo(id, {
        reminderState: 'archived',
        archivedAt: new Date()
      });
      
      res.json(updatedTodo);
    } catch (error) {
      console.error("Failed to archive reminder:", error);
      res.status(500).json({ message: "Failed to archive reminder" });
    }
  });

  // User reminder settings endpoints
  app.get("/api/user/reminder-settings", async (req, res) => {
    try {
      // For now, return default settings since we don't have user auth
      res.json({
        reminderSettings: {
          defaultLeadTimes: {
            general: 10,
            pickup: 10,
            appointment: 30,
            medication: 0,
            call: 5,
            meeting: 15,
            flight: 120
          },
          autoArchiveAfterDays: 1,
          showOverdueReminders: true,
          enablePushNotifications: true
        }
      });
    } catch (error) {
      console.error("Failed to get reminder settings:", error);
      res.status(500).json({ message: "Failed to get reminder settings" });
    }
  });

  app.put("/api/user/reminder-settings", async (req, res) => {
    try {
      const { reminderSettings } = req.body;
      
      // For now, just return success since we don't have user auth
      // In a real app, this would update the user's settings in the database
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to update reminder settings:", error);
      res.status(500).json({ message: "Failed to update reminder settings" });
    }
  });

  // Archive expired reminders (called by scheduled job)
  app.post("/api/reminders/archive-expired", async (req, res) => {
    try {
      const todos = await storage.getTodos();
      const now = new Date();
      const endOfYesterday = new Date(now);
      endOfYesterday.setDate(endOfYesterday.getDate() - 1);
      endOfYesterday.setHours(23, 59, 59, 999);

      let archivedCount = 0;
      
      for (const todo of todos) {
        if (todo.isActiveReminder && 
            todo.reminderState === 'active' && 
            todo.dueDate && 
            todo.dueDate < endOfYesterday) {
          
          await storage.updateTodo(todo.id, {
            reminderState: 'archived',
            archivedAt: new Date()
          });
          archivedCount++;
        }
      }

      // Refresh notifications after archiving
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();

      res.json({ archivedCount });
    } catch (error) {
      console.error("Failed to archive expired reminders:", error);
      res.status(500).json({ message: "Failed to archive expired reminders" });
    }
  });

  // Cleanup old todos, reminders, and notes
  app.post("/api/cleanup/old-todos-reminders", async (req, res) => {
    try {
      // Get current state
      const todos = await storage.getTodos();
      const notes = await storage.getNotes();
      
      console.log(`Total todos before cleanup: ${todos.length}`);
      console.log(`Total notes before cleanup: ${notes.length}`);

      // Separate todos and reminders
      const regularTodos = todos.filter(todo => !todo.isActiveReminder);
      const reminders = todos.filter(todo => todo.isActiveReminder === true);

      console.log(`Regular todos: ${regularTodos.length}, Reminders: ${reminders.length}`);

      // Sort by creation date (oldest first)
      const sortedTodos = regularTodos.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
      const sortedReminders = reminders.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
      const sortedNotes = notes.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());

      // Calculate how many to delete
      const todosToDeleteCount = Math.floor(sortedTodos.length * 0.8); // 80% of todos
      const remindersToDeleteCount = Math.floor(sortedReminders.length * 0.6); // 60% of reminders
      const notesToDeleteCount = Math.floor(sortedNotes.length * 0.8); // 80% of notes

      console.log(`Will delete ${todosToDeleteCount} todos, ${remindersToDeleteCount} reminders, and ${notesToDeleteCount} notes`);

      let deletedCount = 0;

      // Delete oldest 80% of todos
      const todosToDelete = sortedTodos.slice(0, todosToDeleteCount);
      for (const todo of todosToDelete) {
        try {
          await storage.deleteTodo(todo.id);
          deletedCount++;
          console.log(`Deleted todo: "${todo.title}" (created: ${todo.createdAt})`);
        } catch (error) {
          console.error(`Failed to delete todo ${todo.id}:`, error);
        }
      }

      // Delete oldest 60% of reminders
      const remindersToDelete = sortedReminders.slice(0, remindersToDeleteCount);
      for (const reminder of remindersToDelete) {
        try {
          await storage.deleteTodo(reminder.id);
          deletedCount++;
          console.log(`Deleted reminder: "${reminder.title}" (created: ${reminder.createdAt})`);
        } catch (error) {
          console.error(`Failed to delete reminder ${reminder.id}:`, error);
        }
      }

      // Delete oldest 80% of notes
      const notesToDelete = sortedNotes.slice(0, notesToDeleteCount);
      for (const note of notesToDelete) {
        try {
          await storage.deleteNote(note.id);
          deletedCount++;
          console.log(`Deleted note: "${note.content.slice(0, 50)}..." (created: ${note.createdAt})`);
        } catch (error) {
          console.error(`Failed to delete note ${note.id}:`, error);
        }
      }

      // Refresh notifications after cleanup
      const { notificationSystem } = await import('./notification-system');
      await notificationSystem.refreshNotifications();

      const finalTodos = await storage.getTodos();
      const finalNotes = await storage.getNotes();
      
      console.log(`Total todos after cleanup: ${finalTodos.length}`);
      console.log(`Total notes after cleanup: ${finalNotes.length}`);

      res.json({
        success: true,
        deletedCount,
        breakdown: {
          todosDeleted: todosToDeleteCount,
          remindersDeleted: remindersToDeleteCount,
          notesDeleted: notesToDeleteCount,
          remainingTodos: finalTodos.filter(t => !t.isActiveReminder).length,
          remainingReminders: finalTodos.filter(t => t.isActiveReminder === true).length,
          remainingNotes: finalNotes.length
        },
        message: `Successfully deleted ${deletedCount} items (${todosToDeleteCount} todos + ${remindersToDeleteCount} reminders + ${notesToDeleteCount} notes)`
      });

    } catch (error) {
      console.error("Cleanup operation failed:", error);
      res.status(500).json({ 
        success: false,
        message: "Failed to cleanup old todos, reminders, and notes",
        error: error.message 
      });
    }
  });

  // Create and return HTTP server
  const server = createServer(app);
  return server;
}```

### server/simple-dev-server.ts
```typescript
import express from "express";
import { createServer } from "vite";
import path from "path";

export async function createSimpleDevServer() {
  const app = express();
  
  // Create Vite server in middleware mode
  const vite = await createServer({
    server: { middlewareMode: true },
    appType: 'spa',
    root: path.resolve(".", "client"),
    build: {
      outDir: path.resolve(".", "dist/public"),
    },
  });

  // Use Vite's middleware
  app.use(vite.middlewares);

  return { app, vite };
}```

### server/storage.ts
```typescript
import { notes, todos, collections, users, items, reminders, collectionItems, type Note, type Todo, type Collection, type User, type Item, type Reminder, type InsertNote, type InsertTodo, type InsertCollection, type InsertItem, type InsertReminder, type UpsertUser, type NoteWithTodos } from "@shared/schema";
import { db } from "./db";

// Export db for Intelligence-V2 components
export { db };
import { eq, desc } from "drizzle-orm";

export interface IStorage {
  // User operations (for future auth implementation)
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
  updateUser(id: string, updates: Partial<User>): Promise<User>;

  // Notes
  createNote(note: InsertNote): Promise<Note>;
  getNotes(userId?: string): Promise<NoteWithTodos[]>;
  getNote(id: number): Promise<NoteWithTodos | undefined>;
  updateNote(id: number, updates: Partial<Note>): Promise<Note>;
  deleteNote(id: number): Promise<void>;

  // Todos
  createTodo(todo: InsertTodo): Promise<Todo>;
  getTodos(): Promise<Todo[]>;
  getTodosByNoteId(noteId: number): Promise<Todo[]>;
  updateTodo(id: number, updates: Partial<Todo>): Promise<Todo>;
  deleteTodo(id: number): Promise<void>;

  // Collections
  createCollection(collection: InsertCollection): Promise<Collection>;
  getCollections(): Promise<Collection[]>;
  getCollection(id: number): Promise<Collection | undefined>;
  updateCollection(id: number, updates: Partial<Collection>): Promise<Collection>;
  getNotesByCollectionId(collectionId: number): Promise<NoteWithTodos[]>;

  // Items
  createItem(item: InsertItem): Promise<Item>;
  getItems(): Promise<Item[]>;
  getItemsByNoteId(noteId: number): Promise<Item[]>;
  getItemsByCollectionId(collectionId: number): Promise<Item[]>;
  updateItem(id: number, updates: Partial<Item>): Promise<Item>;
  deleteItem(id: number): Promise<void>;

  // Reminders
  createReminder(reminder: InsertReminder): Promise<Reminder>;
  getReminders(): Promise<Reminder[]>;

  // Intelligence-v2 extensions
  getAllNotes(): Promise<Note[]>;
  getNotesWithVectors(): Promise<Note[]>;
  updateNoteVectors(id: number, vectorDense: string, vectorSparse: string): Promise<void>;
  storeRelationships?(noteId: string, relationships: any[]): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, username));
    return user || undefined;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }

  async updateUser(id: string, updates: Partial<User>): Promise<User> {
    const [user] = await db
      .update(users)
      .set({
        ...updates,
        updatedAt: new Date(),
      })
      .where(eq(users.id, id))
      .returning();
    return user;
  }

  async createNote(insertNote: InsertNote): Promise<Note> {
    const [note] = await db
      .insert(notes)
      .values([insertNote])
      .returning();
    return note;
  }

  async getNotes(): Promise<NoteWithTodos[]> {
    // Optimized: Get all data in parallel batches instead of N+1 queries
    const [allNotes, allTodos, allCollections] = await Promise.all([
      db.select({
        id: notes.id,
        content: notes.content,
        aiGeneratedTitle: notes.aiGeneratedTitle,
        mode: notes.mode,
        userId: notes.userId,
        isShared: notes.isShared,
        shareId: notes.shareId,
        privacyLevel: notes.privacyLevel,
        createdAt: notes.createdAt,
        audioUrl: notes.audioUrl,
        mediaUrl: notes.mediaUrl,
        transcription: notes.transcription,
        imageData: notes.imageData,
        aiEnhanced: notes.aiEnhanced,
        aiSuggestion: notes.aiSuggestion,
        aiContext: notes.aiContext,
        richContext: notes.richContext,
        isProcessing: notes.isProcessing,
        collectionId: notes.collectionId,
        // Exclude heavy vector data from list view
        version: notes.version,
        originalContent: notes.originalContent,
        lastUserEdit: notes.lastUserEdit,
        protectedContent: notes.protectedContent,
        processingPath: notes.processingPath,
        classificationScores: notes.classificationScores
      }).from(notes).orderBy(desc(notes.createdAt)).limit(50), // Limit to 50 most recent notes
      db.select().from(todos).limit(200), // Limit todos query
      db.select().from(collections).limit(20) // Limit collections query
    ]);

    // Group todos by noteId for efficient lookup
    const todosByNoteId = allTodos.reduce((acc, todo) => {
      if (!acc[todo.noteId]) acc[todo.noteId] = [];
      acc[todo.noteId].push(todo);
      return acc;
    }, {} as Record<number, Todo[]>);

    // Group collections by id for efficient lookup
    const collectionsById = allCollections.reduce((acc, collection) => {
      acc[collection.id] = collection;
      return acc;
    }, {} as Record<number, Collection>);

    // Combine data efficiently
    const notesWithTodos = allNotes.map(note => ({
      ...note,
      todos: todosByNoteId[note.id] || [],
      collection: note.collectionId ? collectionsById[note.collectionId] : undefined,
      // Add missing fields with defaults
      vectorDense: null,
      vectorSparse: null,
      intentVector: null
    }));

    return notesWithTodos;
  }

  async getNote(id: number): Promise<NoteWithTodos | undefined> {
    const [note] = await db.select().from(notes).where(eq(notes.id, id));
    if (!note) return undefined;

    const noteTodos = await this.getTodosByNoteId(id);
    const collection = note.collectionId 
      ? await this.getCollection(note.collectionId) 
      : undefined;
    return { ...note, todos: noteTodos, collection };
  }

  async updateNote(id: number, updates: Partial<Note>): Promise<Note> {
    console.log(`[Storage] Updating note ${id} with keys:`, Object.keys(updates));
    console.log(`[Storage] Update values:`, JSON.stringify(updates, null, 2));
    
    try {
      // Filter out undefined values but keep null values (they might be intentional)
      const cleanUpdates = Object.fromEntries(
        Object.entries(updates).filter(([_, value]) => value !== undefined)
      );

      if (Object.keys(cleanUpdates).length === 0) {
        console.log(`[Storage] No valid updates for note ${id}, returning existing`);
        const existingNote = await this.getNote(id);
        if (!existingNote) throw new Error("Note not found");
        return existingNote;
      }

      console.log(`[Storage] Executing update with cleaned data:`, cleanUpdates);
      
      const updatedNotes = await db
        .update(notes)
        .set(cleanUpdates)
        .where(eq(notes.id, id))
        .returning();

      if (!updatedNotes || updatedNotes.length === 0) {
        throw new Error("Note not found");
      }
      
      console.log(`[Storage] Update successful for note ${id}`);
      const result = updatedNotes[0];
      console.log(`[Storage] Verification - aiEnhanced: ${result.aiEnhanced}, richContext length: ${result.richContext?.length || 0}`);
      
      return result;
    } catch (error: any) {
      console.error(`[Storage] Database update error for note ${id}:`, error);
      console.error(`[Storage] Failed update payload:`, updates);
      throw new Error(`Failed to update note: ${error.message}`);
    }
  }

  async deleteNote(id: number): Promise<void> {
    // First delete all associated todos
    await db.delete(todos).where(eq(todos.noteId, id));
    // Then delete the note
    await db.delete(notes).where(eq(notes.id, id));
  }

  async createTodo(todoData: InsertTodo): Promise<Todo> {
    try {
      console.log("Creating todo/reminder with data:", {
        title: todoData.title,
        isActiveReminder: todoData.isActiveReminder,
        timeDue: todoData.timeDue,
        priority: todoData.priority
      });

      // Create the todo values object, only including defined fields
      const todoValues: any = {
        title: todoData.title,
        completed: todoData.completed || false,
        priority: todoData.priority || 'medium',
        noteId: todoData.noteId,
        isActiveReminder: todoData.isActiveReminder || false,
        pinned: todoData.pinned || false,
        archived: todoData.archived || false
      };

      // Only add timeDue if it's provided
      if (todoData.timeDue) {
        todoValues.timeDue = todoData.timeDue;
      }

      // Add notification structure if provided
      if (todoData.plannedNotificationStructure) {
        todoValues.plannedNotificationStructure = todoData.plannedNotificationStructure;
      } else if (todoData.isActiveReminder) {
        // Default notification structure for reminders
        todoValues.plannedNotificationStructure = {
          enabled: true,
          reminderCategory: "today",
          repeatPattern: "none",
          leadTimeNotifications: ["15 minutes before"]
        };
      }

      const [newTodo] = await db
        .insert(todos)
        .values(todoValues)
        .returning();

      console.log("Successfully created todo/reminder:", newTodo);
      return newTodo;
    } catch (error) {
      console.error('Error creating todo:', error);
      throw error;
    }
  }

  async getTodos(): Promise<Todo[]> {
    return await db
      .select()
      .from(todos)
      .orderBy(desc(todos.createdAt));
  }

  async getTodosByNoteId(noteId: number): Promise<Todo[]> {
    return await db
      .select()
      .from(todos)
      .where(eq(todos.noteId, noteId))
      .orderBy(desc(todos.createdAt));
  }

  async updateTodo(id: number, updates: Partial<Todo>): Promise<Todo> {
    const [todo] = await db
      .update(todos)
      .set(updates)
      .where(eq(todos.id, id))
      .returning();

    if (!todo) throw new Error("Todo not found");
    return todo;
  }

  async deleteTodo(id: number): Promise<void> {
    await db.delete(todos).where(eq(todos.id, id));
  }

  async createCollection(insertCollection: InsertCollection): Promise<Collection> {
    const [collection] = await db
      .insert(collections)
      .values(insertCollection)
      .returning();
    return collection;
  }

  async getCollections(): Promise<Collection[]> {
    return await db
      .select()
      .from(collections)
      .orderBy(collections.displayOrder, collections.createdAt);
  }

  async getCollection(id: number): Promise<Collection | undefined> {
    const [collection] = await db.select().from(collections).where(eq(collections.id, id));
    return collection || undefined;
  }

  async updateCollection(id: number, updates: Partial<Collection>): Promise<Collection> {
    const [collection] = await db
      .update(collections)
      .set(updates)
      .where(eq(collections.id, id))
      .returning();
    if (!collection) throw new Error("Collection not found");
    return collection;
  }

  async getNotesByCollectionId(collectionId: number): Promise<NoteWithTodos[]> {
    const collectionNotes = await db
      .select()
      .from(notes)
      .where(eq(notes.collectionId, collectionId))
      .orderBy(desc(notes.createdAt));

    const notesWithTodos = await Promise.all(
      collectionNotes.map(async (note) => {
        const noteTodos = await this.getTodosByNoteId(note.id);
        const collection = await this.getCollection(collectionId);
        return { ...note, todos: noteTodos, collection };
      })
    );

    return notesWithTodos; // Already sorted newest first
  }

  // Items operations
  async createItem(insertItem: InsertItem): Promise<Item> {
    const [item] = await db
      .insert(items)
      .values(insertItem)
      .returning();
    return item;
  }

  async getItems(): Promise<Item[]> {
    return await db
      .select()
      .from(items)
      .orderBy(desc(items.createdAt));
  }

  async getItemsByNoteId(noteId: number): Promise<Item[]> {
    return await db
      .select()
      .from(items)
      .where(eq(items.sourceNoteId, noteId))
      .orderBy(desc(items.createdAt));
  }

  async getItemsByCollectionId(collectionId: number): Promise<Item[]> {
    return await db
      .select()
      .from(items)
      .where(eq(items.collectionId, collectionId))
      .orderBy(desc(items.createdAt));
  }

  async updateItem(id: number, updates: Partial<Item>): Promise<Item> {
    const [item] = await db
      .update(items)
      .set(updates)
      .where(eq(items.id, id))
      .returning();
    if (!item) throw new Error("Item not found");
    return item;
  }

  async deleteItem(id: number): Promise<void> {
    await db.delete(items).where(eq(items.id, id));
  }

  // Reminder operations
  async createReminder(insertReminder: InsertReminder): Promise<Reminder> {
    const [reminder] = await db
      .insert(reminders)
      .values(insertReminder)
      .returning();
    return reminder;
  }

  async getReminders(): Promise<Reminder[]> {
    return await db
      .select()
      .from(reminders)
      .where(eq(reminders.isCompleted, false))
      .orderBy(reminders.reminderTime);
  }

  // Intelligence-v2 implementations
  async getAllNotes(): Promise<Note[]> {
    return await db
      .select()
      .from(notes)
      .orderBy(desc(notes.createdAt));
  }

  async getNotesWithVectors(): Promise<Note[]> {
    return await db
      .select()
      .from(notes)
      .orderBy(desc(notes.createdAt));
  }

  async updateNoteVectors(id: number, vectorDense: string, vectorSparse: string): Promise<void> {
    await db
      .update(notes)
      .set({
        vectorDense,
        vectorSparse
      })
      .where(eq(notes.id, id));
  }

  async storeRelationships(noteId: string, relationships: any[]): Promise<void> {
    // Store relationships in note metadata for now
    // Can be expanded to dedicated relationship table later
    const id = parseInt(noteId);
    if (isNaN(id)) return;

    const relationshipData = {
      relationships: relationships.map(rel => ({
        type: rel.type,
        targetId: rel.targetId,
        strength: rel.strength,
        context: rel.context,
        discoveredAt: rel.discoveredAt
      }))
    };

    await db
      .update(notes)
      .set({
        richContext: JSON.stringify(relationshipData)
      })
      .where(eq(notes.id, id));
  }
}

export const storage = new DatabaseStorage();```

### server/subscription-tiers.ts
```typescript
export interface SubscriptionTier {
  name: string;
  aiRequestsPerHour: number;
  aiRequestsPerDay: number;
  maxNotesStored: number;
  maxAudioMinutesPerMonth: number;
  collaborativeNotes: boolean;
  priorityProcessing: boolean;
  advancedAIFeatures: boolean;
  customCollections: boolean;
  exportFeatures: boolean;
}

export const SUBSCRIPTION_TIERS: Record<string, SubscriptionTier> = {
  free: {
    name: "Free",
    aiRequestsPerHour: 5,
    aiRequestsPerDay: 20,
    maxNotesStored: 100,
    maxAudioMinutesPerMonth: 10,
    collaborativeNotes: false,
    priorityProcessing: false,
    advancedAIFeatures: false,
    customCollections: false,
    exportFeatures: false,
  },
  pro: {
    name: "Pro",
    aiRequestsPerHour: 50,
    aiRequestsPerDay: 200,
    maxNotesStored: 5000,
    maxAudioMinutesPerMonth: 120,
    collaborativeNotes: true,
    priorityProcessing: true,
    advancedAIFeatures: true,
    customCollections: true,
    exportFeatures: true,
  },
  enterprise: {
    name: "Enterprise",
    aiRequestsPerHour: -1, // unlimited
    aiRequestsPerDay: -1, // unlimited
    maxNotesStored: -1, // unlimited
    maxAudioMinutesPerMonth: -1, // unlimited
    collaborativeNotes: true,
    priorityProcessing: true,
    advancedAIFeatures: true,
    customCollections: true,
    exportFeatures: true,
  },
  developer: {
    name: "Developer",
    aiRequestsPerHour: -1, // unlimited
    aiRequestsPerDay: -1, // unlimited
    maxNotesStored: -1, // unlimited
    maxAudioMinutesPerMonth: -1, // unlimited
    collaborativeNotes: true,
    priorityProcessing: true,
    advancedAIFeatures: true,
    customCollections: true,
    exportFeatures: true,
  }
};

export function getUserTier(userId: string | null): SubscriptionTier {
  // Developer accounts (you can add specific user IDs here)
  const devAccounts = [
    process.env.DEV_USER_ID, // Your dev account
    "dev", // Generic dev identifier
  ];
  
  if (userId && devAccounts.includes(userId)) {
    return SUBSCRIPTION_TIERS.developer;
  }
  
  // TODO: Look up user's actual subscription tier from database
  // For now, return free tier for all users
  return SUBSCRIPTION_TIERS.free;
}

export function checkAIRequestLimit(tier: SubscriptionTier, hourlyCount: number, dailyCount: number): boolean {
  if (tier.aiRequestsPerHour === -1) return true; // unlimited
  if (hourlyCount >= tier.aiRequestsPerHour) return false;
  if (dailyCount >= tier.aiRequestsPerDay) return false;
  return true;
}```

### server/utils/brain/miraAIProcessing.ts
```typescript
/**
 *  MIRA - PRIME INTELLIGENCE ENGINE  v2.0.0
 *  ────────────────────────────────────────
 *  A single entry-point that:
 *    1. Normalises every inbound user capture (text / voice / image / file)
 *    2. ​Runs a multi-stage reasoning pipeline:
 *          a. Quick intent fingerprint  (<150 ms, local regexp + heuristic)
 *          b. Clarification-need detector (asks micro Qs only when useful)
 *          c. LLM orchestration prompt  (few-shot, taxonomy-aware)
 *          d. Post-processing enforcement + enrichment (KG links, IDs, etc.)
 *    3. Emits a rich, strongly-typed `MiraAIResult`
 *
 *  Key upgrades in 2.0.0:
 *  –  Expanded taxonomy (14 intent types, 11 content facets, recurrence)
 *  –  "microQuestions" output for toast-style clarifications
 *  –  "smartActions" output: pre-wired, UI-ready next-step chips
 *  –  Knowledge-Graph stubs (entity extraction, cross-link suggestions)
 *  –  Recurring-task intelligence (RRULE + natural cadence detection)
 *  –  Template library moved to ./promptTemplates for easier tuning
 *  –  Ultra-strict JSON-only guard rails (regex + JSON.parse fallback)
 *  –  Test-harness exported (run `pnpm test:brain`)
 */

import { analyzeWithOpenAI, analyzeImageContent } from "../../openai";
import { v4 as uuid } from "uuid";
import { 
  shouldTriggerLocationSearch, 
  getUserLocation,
  generateLocationSearchQueries, 
  performLocationWebSearch,
  type WebSearchResult,
  type LocationContext 
} from "../../web-search";
import { IntelligentReminderParser } from "../intelligent-reminder-parser";

/* ----------  TYPES  ---------- */

export interface MiraAIInput {
  id?: string;                          // uuid provided by caller or auto-generated
  content: string;                      // raw user input or OCR / STT payload
  mode: "text" | "voice" | "image" | "file";
  req?: any;                           // Express request object for location detection
  imageData?: string;                   // base64 for image processing
  locale?: string;                      // e.g. "en-US" (defaults to device)
  timestamp?: string;                   // ISO 8601 (defaults to now)
  context?: Record<string, any>;        // optional calling-screen context
}

export interface MiraAIResult {
  /* CORE */
  uid: string;                          // stable hash for this note
  title: string;                        // 3-5 word headline
  summary: string;                      // 1-2 sentence condensed context
  intent: IntentType;                   // expanded taxonomy
  urgency: Urgency;                     // low | medium | high | critical
  complexity: number;                   // 1-10 (heuristic + LLM)
  /* NEXT-STEP MAGIC */
  microQuestions?: string[];            // clarification prompts for toast UI
  todos?: ToDoItem[];                   // extracted, structured actions
  optionalTodos?: OptionalTodoItem[];   // suggested todos user can optionally add
  smartActions?: SmartAction[];         // UI chips (Share, Summarise…)
  /* KNOWLEDGE LAYER */
  entities?: GraphEntity[];             // persons, orgs, places, dates, etc.
  suggestedLinks?: string[];            // existing note-IDs to link/display
  collectionHint?: { name: string; icon?: string; colour?: string };
  /* WEB SEARCH RESULTS */
  fromTheWeb?: WebSearchResult[];       // location-aware web search results
  /* PREDICTIVE */
  nextSteps?: string[];
  /* REMINDER SYSTEM */
  timeInstructions?: {
    hasTimeReference: boolean;
    extractedTimes: string[];
  };
  reminders?: ReminderItem[];           // structured reminder data
  /* RAW */
  _rawModelJSON: any;                   // untouched model response for debugging
}

/* ----------  ENUMS  ---------- */

export type IntentType =
  | "simple-task" | "recurring-task" | "scheduled-event"
  | "complex-project" | "research" | "reference"
  | "idea" | "inspiration" | "collection"
  | "memory-log" | "knowledge" | "personal-reflection"
  | "media-upload" | "unknown";

export type Urgency = "low" | "medium" | "high" | "critical";

export interface ToDoItem {
  title: string;
  due?: string;                         // ISO
  recurrence?: string;                  // RRULE
  priority?: Urgency;
}

export interface OptionalTodoItem {
  title: string;
  description?: string;
}

export interface ReminderItem {
  title: string;
  dueTime?: string;                     // ISO timestamp
  recurrence?: string;                  // RRULE or natural language
  priority?: Urgency;
  reminderType?: string;                // pickup, appointment, call, etc.
}

export interface SmartAction {
  label: string;                        // "Add to Calendar"
  action: "calendar" | "reminder" | "share" | "summarise" | "translate" |
          "route" | "booking" | "openLink" | "custom";
  payload?: Record<string, any>;
}

export interface GraphEntity {
  id: string;                           // uuid for KG node
  type: "person" | "org" | "place" | "thing" | "date" | "concept";
  value: string;
  meta?: Record<string, any>;
}

/* ----------  PUBLIC API  ---------- */

export async function processNote(input: MiraAIInput): Promise<MiraAIResult> {
  const uid = input.id ?? uuid();
  const ts  = input.timestamp ?? new Date().toISOString();

  /* 1 ▸ Intelligent reminder detection */
  const reminderInfo = IntelligentReminderParser.parseReminder(input.content);

  /* 2 ▸ Quick intent fingerprint (enhanced with reminder detection) */
  const fp = fingerprint(input, reminderInfo);

  /* 3 ▸ Compose LLM prompt */
  const prompt = await composePrompt(input, fp);

  /* 4 ▸ Model call */
  const rawModelJSON = await callLLM(input, prompt);

  /* 5 ▸ Post-process, enforce schema, fallback if needed */
  let result = sanitise(rawModelJSON, input, uid, ts, fp);

  /* 6 ▸ Enhance with intelligent reminder data */
  if (reminderInfo.isReminder) {
    result = enhanceWithReminderIntelligence(result, reminderInfo);
  }

  function enhanceWithReminderIntelligence(result: MiraAIResult, reminderInfo: any): MiraAIResult {
    // Enhance todos with intelligent reminder data
    const enhancedTodos = (result.todos || []).map(todo => ({
      ...todo,
      isActiveReminder: true,
      timeDue: reminderInfo.timeReference?.parsedTime,
      reminderType: reminderInfo.context.type,
      reminderCategory: reminderInfo.context.category,
      repeatPattern: reminderInfo.recurringPattern || 'none',
      leadTimeNotifications: reminderInfo.explicitLeadTime ? 
        [reminderInfo.explicitLeadTime] : 
        [reminderInfo.context.defaultLeadTime],
      urgencyLevel: reminderInfo.context.urgency
    }));

    // Add reminder-specific smart actions
    const reminderSmartActions: SmartAction[] = [
      { label: "Set Reminder", action: "reminder" },
      { label: "Reschedule", action: "custom" }
    ];

    return {
      ...result,
      todos: enhancedTodos,
      intent: reminderInfo.recurringPattern ? "recurring-task" : "scheduled-event",
      urgency: reminderInfo.context.urgency,
      smartActions: [...(result.smartActions || []), ...reminderSmartActions],
      timeInstructions: {
        hasTimeReference: !!reminderInfo.timeReference,
        extractedTimes: reminderInfo.timeReference ? [reminderInfo.timeReference.originalText] : [],
        scheduledItems: enhancedTodos.filter(t => t.timeDue).map(t => ({
          title: t.title,
          scheduledTime: t.timeDue,
          type: t.reminderType
        }))
      }
    };
  }

  /* 7 ▸ Location-aware web search if applicable */
  let webResults: WebSearchResult[] = [];
  if (shouldTriggerLocationSearch(input.content)) {
    const location = await getUserLocation(input.req);
    const queries = generateLocationSearchQueries(input.content, location);
    webResults = await performLocationWebSearch(queries, location);
  }

  return { 
    ...result, 
    fromTheWeb: webResults.length > 0 ? webResults : undefined,
    _rawModelJSON: rawModelJSON 
  };
}

/* ----------  INTERNALS  ---------- */

function fingerprint({ content, mode }: MiraAIInput, reminderInfo?: any) {
  const c = content.toLowerCase();
  const isShort = c.length < 60;
  const hasDate = /\b(today|tomorrow|\d{1,2}\/\d{1,2}|\d{4}-\d{2}-\d{2})\b/.test(c) || reminderInfo?.timeReference;
  const recur   = /\b(every|daily|weekly|monthly|annually|each)\b/.test(c) || reminderInfo?.recurringPattern;
  const isReminder = reminderInfo?.isReminder || false;
  return { isShort, hasDate, recur, mode, isReminder };
}

async function composePrompt(input: MiraAIInput, fp: any) {
  if (fp.mode === "image") {
    const template = await import("./promptTemplates/image");
    return template.default(input);
  }
  if (fp.mode === "voice") {
    const template = await import("./promptTemplates/voice");
    return template.default(input);
  }
  if (fp.recur) {
    const template = await import("./promptTemplates/recurringTask");
    return template.default(input);
  }
  if (fp.hasDate) {
    const template = await import("./promptTemplates/scheduledEvent");
    return template.default(input);
  }
  if (fp.isShort) {
    const template = await import("./promptTemplates/simpleTask");
    return template.default(input);
  }
  if (input.content.length > 180) {
    const template = await import("./promptTemplates/complexProject");
    return template.default(input);
  }
  const template = await import("./promptTemplates/simpleTask");
  return template.default(input);
}

async function callLLM(input: MiraAIInput, prompt: string) {
  if (input.mode === "image") {
    return analyzeImageContent(input.imageData!, prompt);
  }
  return analyzeWithOpenAI(prompt, "json");
}

/** Enforce schema + minimal viable fallback */
function sanitise(raw: any, input: MiraAIInput, uid: string, ts: string, fp: any): MiraAIResult {
  let data: any;
  try { data = typeof raw === "string" ? JSON.parse(raw) : raw; }
  catch { /* model hallucinated non-JSON */ data = {}; }

  /* Mandatory fields with defensible fallbacks */
  const title = enforceTitle(data.title ?? input.content);
  const summary = data.summary ?? "Note processed";
  const intent: IntentType = data.intent ?? (
    fp.recur ? "recurring-task" :
    fp.hasDate ? "scheduled-event" :
    fp.isShort ? "simple-task" : "unknown"
  );

  return {
    uid,
    title,
    summary,
    intent,
    urgency: data.urgency ?? "low",
    complexity: clamp(data.complexity ?? 1, 1, 10),
    microQuestions: data.microQuestions ?? [],
    todos: data.todos ?? [],
    optionalTodos: data.optionalTodos ?? [],
    smartActions: data.smartActions ?? defaultSmartActions(intent),
    entities: data.entities ?? [],
    suggestedLinks: data.suggestedLinks ?? [],
    collectionHint: data.collectionHint,
    nextSteps: (intent === "simple-task") ? [] : (data.nextSteps ?? []),
    _rawModelJSON: data
  };
}

/* Helpers */
function enforceTitle(str: string) {
  const bad = ["the","a","an","and","of","for","with","to","in","on","at","but","or"];
  const words = str.replace(/["'`]/g,"").split(/\s+/).filter(w=>w && !bad.includes(w.toLowerCase()));
  return words.slice(0,5).map(w=>w[0].toUpperCase()+w.slice(1)).join(" ");
}
const clamp = (n:number,min:number,max:number)=>Math.min(Math.max(n,min),max);

function defaultSmartActions(intent: IntentType): SmartAction[] {
  switch(intent){
    case "simple-task": return [{label:"Set Reminder",action:"reminder"}];
    case "scheduled-event": return [{label:"Add to Calendar",action:"calendar"}];
    case "media-upload": return [{label:"Summarise",action:"summarise"}];
    default: return [{label:"Share",action:"share"}];
  }
}

function enhanceWithReminderIntelligence(result: MiraAIResult, reminderInfo: any): MiraAIResult {
  // Enhance todos with intelligent reminder data
  const enhancedTodos = result.todos.map(todo => ({
    ...todo,
    isActiveReminder: true,
    timeDue: reminderInfo.timeReference?.parsedTime,
    reminderType: reminderInfo.context.type,
    reminderCategory: reminderInfo.context.category,
    repeatPattern: reminderInfo.recurringPattern || 'none',
    leadTimeNotifications: reminderInfo.explicitLeadTime ? 
      [reminderInfo.explicitLeadTime] : 
      [reminderInfo.context.defaultLeadTime],
    urgencyLevel: reminderInfo.context.urgency
  }));

  // Add reminder-specific smart actions
  const reminderSmartActions = [
    { label: "Set Reminder", action: "reminder" },
    { label: "Reschedule", action: "reschedule" }
  ];

  return {
    ...result,
    todos: enhancedTodos,
    intent: reminderInfo.recurringPattern ? "recurring-task" : "scheduled-event",
    urgency: reminderInfo.context.urgency,
    smartActions: [...(result.smartActions || []), ...reminderSmartActions],
    timeInstructions: {
      hasTimeReference: !!reminderInfo.timeReference,
      extractedTimes: reminderInfo.timeReference ? [reminderInfo.timeReference.originalText] : [],
      scheduledItems: enhancedTodos.filter(t => t.timeDue).map(t => ({
        title: t.title,
        scheduledTime: t.timeDue,
        type: t.reminderType
      }))
    }
  };
}

/* ----------  TEST-HARNESS (exported for Jest / vitest) ---------- */
export const _internal = { fingerprint, composePrompt, sanitise, enhanceWithReminderIntelligence };```

### server/utils/brain/promptTemplates/complexProject.ts
```typescript
import { MiraAIInput } from "../miraAIProcessing";

export default function complexProjectTemplate(input: MiraAIInput): string {
  return `
SYSTEM: You are Mira's elite secretary team specializing in complex projects. Output **ONLY** valid JSON following the schema provided.

USER_NOTE: "${input.content}"

DESIRED_SCHEMA: {
  "title": "string (3-5 words max, newspaper headline style)",
  "summary": "string (1-2 sentences)",
  "intent": "complex-project",
  "urgency": "low" | "medium" | "high" | "critical",
  "complexity": "number (1-10)",
  "todos": [{"title": "string", "due": "ISO date", "priority": "urgency"}],
  "smartActions": [{"label": "string", "action": "reminder|calendar|share|summarise", "payload": {}}],
  "microQuestions": ["string (clarification prompts)"],
  "entities": [{"id": "uuid", "type": "person|org|place|thing|date|concept", "value": "string"}],
  "suggestedLinks": ["string (note IDs)"],
  "collectionHint": {"name": "string", "icon": "string", "colour": "string"},
  "nextSteps": ["string"]
}

EXAMPLE_OUTPUT: {"title":"Launch Mobile App","summary":"Comprehensive project to develop and launch healthcare mobile application","intent":"complex-project","urgency":"high","complexity":9,"todos":[{"title":"Research market requirements","priority":"high"},{"title":"Design user interface","priority":"medium"}],"smartActions":[{"label":"Create Timeline","action":"calendar"},{"label":"Share Plan","action":"share"}],"microQuestions":["What's your target launch date?","Do you have a development team?"]}

OUTPUT ONLY JSON:`;
}```

### server/utils/brain/promptTemplates/fallback.ts
```typescript
import { MiraAIInput } from "../miraAIProcessing";

export default function fallbackTemplate(input: MiraAIInput): string {
  // Fallback templates should not exist - AI processing should never fail to the point of needing hardcoded responses
  throw new Error("Fallback processing disabled - AI must handle all content generation");
}```

### server/utils/brain/promptTemplates/image.ts
```typescript
import { MiraAIInput } from "../miraAIProcessing";

export default function imageTemplate(input: MiraAIInput): string {
  return `
SYSTEM: You are Mira's elite secretary team specializing in image analysis. Output **ONLY** valid JSON following the schema provided.

USER_CONTEXT: "${input.content}"
IMAGE_DATA: [Base64 image provided]

DESIRED_SCHEMA: {
  "title": "string (3-5 words max, newspaper headline style)",
  "summary": "string (1-2 sentences describing what you see)",
  "intent": "media-upload",
  "urgency": "low" | "medium" | "high" | "critical",
  "complexity": "number (1-10)",
  "todos": [{"title": "string", "priority": "urgency"}],
  "smartActions": [{"label": "string", "action": "summarise|share|translate", "payload": {}}],
  "microQuestions": ["string (clarification prompts)"],
  "entities": [{"id": "uuid", "type": "person|org|place|thing|date|concept", "value": "string"}],
  "nextSteps": ["string"]
}

EXAMPLE_OUTPUT: {"title":"Restaurant Menu Captured","summary":"Image shows Italian restaurant menu with pasta and pizza options","intent":"media-upload","urgency":"low","complexity":2,"todos":[{"title":"Review menu items","priority":"low"}],"smartActions":[{"label":"Summarise","action":"summarise"}],"entities":[{"id":"uuid1","type":"place","value":"Italian Restaurant"}]}

OUTPUT ONLY JSON:`;
}```

### server/utils/brain/promptTemplates/recurringTask.ts
```typescript
import { MiraAIInput } from "../miraAIProcessing";

export default function recurringTaskTemplate(input: MiraAIInput): string {
  return `
SYSTEM: You are Mira's elite secretary team specializing in recurring tasks. Output **ONLY** valid JSON following the schema provided.

USER_NOTE: "${input.content}"

DESIRED_SCHEMA: {
  "title": "string (3-5 words max, newspaper headline style)",
  "summary": "string (1-2 sentences)",
  "intent": "recurring-task",
  "urgency": "low" | "medium" | "high" | "critical",
  "complexity": "number (1-10)",
  "todos": [{"title": "string", "due": "ISO date", "recurrence": "RRULE", "priority": "urgency"}],
  "smartActions": [{"label": "string", "action": "reminder|calendar|share", "payload": {}}],
  "microQuestions": ["string (clarification prompts)"],
  "entities": [{"id": "uuid", "type": "person|org|place|thing|date|concept", "value": "string"}],
  "nextSteps": ["string"]
}

EXAMPLE_OUTPUT: {"title":"Weekly Team Meeting","summary":"Recurring weekly team standup every Monday","intent":"recurring-task","urgency":"medium","complexity":3,"todos":[{"title":"Attend team meeting","recurrence":"FREQ=WEEKLY;BYDAY=MO","priority":"medium"}],"smartActions":[{"label":"Add to Calendar","action":"calendar"}]}

OUTPUT ONLY JSON:`;
};```

### server/utils/brain/promptTemplates/scheduledEvent.ts
```typescript
import { MiraAIInput } from "../miraAIProcessing";

export default function scheduledEventTemplate(input: MiraAIInput): string {
  return `
SYSTEM: You are Mira's elite secretary team specializing in scheduled events. Output **ONLY** valid JSON following the schema provided.

USER_NOTE: "${input.content}"

DESIRED_SCHEMA: {
  "title": "string (3-5 words max, newspaper headline style)",
  "summary": "string (1-2 sentences)",
  "intent": "scheduled-event",
  "urgency": "low" | "medium" | "high" | "critical",
  "complexity": "number (1-10)",
  "todos": [{"title": "string", "due": "ISO date", "priority": "urgency"}],
  "smartActions": [{"label": "string", "action": "calendar|reminder|share", "payload": {}}],
  "microQuestions": ["string (clarification prompts)"],
  "entities": [{"id": "uuid", "type": "person|org|place|thing|date|concept", "value": "string"}],
  "nextSteps": ["string"]
}

EXAMPLE_OUTPUT: {"title":"Dinner Mom Tuesday","summary":"Dinner appointment with Mom next Tuesday at 7pm","intent":"scheduled-event","urgency":"medium","complexity":2,"todos":[{"title":"Meet Mom for dinner","due":"2024-01-09T19:00:00Z","priority":"medium"}],"smartActions":[{"label":"Add to Calendar","action":"calendar"}]}

OUTPUT ONLY JSON:`;
}```

### server/utils/brain/promptTemplates/simpleTask.ts
```typescript
import { MiraAIInput } from "../miraAIProcessing";

export default function simpleTaskTemplate(input: MiraAIInput): string {
  return `
SYSTEM: You are Mira's elite secretary team. Output **ONLY** valid JSON following the schema provided.

For SIMPLE TASKS: Keep processing minimal. Extract only what the user explicitly stated. Do NOT add unnecessary next steps or suggestions.

USER_NOTE: "${input.content}"

DESIRED_SCHEMA: {
  "title": "string (3-5 words max, newspaper headline style)",
  "summary": "string (1-2 sentences, only if different from title)",
  "intent": "simple-task",
  "urgency": "low" | "medium" | "high" | "critical",
  "complexity": "number (1-5 for simple tasks)",
  "todos": [{"title": "string (match user's exact words)", "due": "ISO date if specified", "priority": "urgency"}],
  "smartActions": [{"label": "Add to Calendar", "action": "calendar"}],
  "entities": [],
  "optionalTodos": [],
  "nextSteps": []
}

EXAMPLE_OUTPUT: {"title":"Pay Rent Today","summary":"Monthly rent payment is due","intent":"simple-task","urgency":"medium","complexity":2,"todos":[{"title":"Pay rent to landlord","priority":"medium"}],"smartActions":[{"label":"Set Reminder","action":"reminder"}]}

OUTPUT ONLY JSON:`;
};```

### server/utils/brain/promptTemplates/voice.ts
```typescript
import { MiraAIInput } from "../miraAIProcessing";

export default function voiceTemplate(input: MiraAIInput): string {
  return `
SYSTEM: You are Mira's elite secretary team specializing in voice transcription analysis. Output **ONLY** valid JSON following the schema provided.

USER_VOICE_NOTE: "${input.content}"

DESIRED_SCHEMA: {
  "title": "string (3-5 words max, newspaper headline style)",
  "summary": "string (1-2 sentences)",
  "intent": "simple-task" | "recurring-task" | "scheduled-event" | "complex-project" | "research" | "reference" | "idea" | "inspiration" | "memory-log" | "knowledge" | "personal-reflection",
  "urgency": "low" | "medium" | "high" | "critical",
  "complexity": "number (1-10)",
  "todos": [{"title": "string", "due": "ISO date", "priority": "urgency"}],
  "smartActions": [{"label": "string", "action": "reminder|calendar|share|summarise", "payload": {}}],
  "microQuestions": ["string (clarification prompts)"],
  "entities": [{"id": "uuid", "type": "person|org|place|thing|date|concept", "value": "string"}],
  "nextSteps": ["string"]
}

EXAMPLE_OUTPUT: {"title":"Call Doctor Tomorrow","summary":"Voice reminder to call doctor about appointment","intent":"simple-task","urgency":"medium","complexity":2,"todos":[{"title":"Call Dr. Smith","due":"2024-01-09T09:00:00Z","priority":"medium"}],"smartActions":[{"label":"Set Reminder","action":"reminder"}]}

OUTPUT ONLY JSON:`;
}```

### server/utils/fastAIProcessing.ts
```typescript
/**
 * Fast AI Processing - Simplified prompts for quick note analysis
 * Used for standard note processing to minimize response times
 */

export const fastPromptTemplate = `
You are Mira, an intelligent note assistant. Analyze this input quickly and provide a concise JSON response.

**Analysis Focus:**
- Classify as reminder, todo, or general note
- Extract actionable items
- Suggest basic categorization

**Required JSON Output:**
{
  "enhancedContent": "Brief improved version if needed, otherwise original content",
  "suggestion": "One actionable insight",
  "context": "Brief classification",
  "complexityScore": 1-5,
  "intentType": "simple-task|complex-project|personal-reflection|reference-material",
  "urgencyLevel": "low|medium|high",
  "todos": ["simple todo items as strings"],
  "collectionSuggestion": {
    "name": "suggested collection name",
    "icon": "folder|checklist|star|home|work",
    "color": "blue|green|yellow|red|purple"
  }
}

**Time-Sensitivity Rules:**
- Mark as reminder if contains time references like "tomorrow", "next week", "remind me"
- Extract simple todos for actionable items
- Keep analysis brief and focused

Analyze this input:
"""
{user_input}
"""
`;

export interface FastAIResult {
  enhancedContent?: string;
  suggestion?: string;
  context?: string;
  complexityScore: number;
  intentType: 'simple-task' | 'complex-project' | 'personal-reflection' | 'reference-material';
  urgencyLevel: 'low' | 'medium' | 'high';
  todos: string[];
  collectionSuggestion?: {
    name: string;
    icon: string;
    color: string;
  };
}```

### server/utils/intelligent-reminder-parser.ts
```typescript
/**
 * Intelligent Reminder Parser
 * Extracts time-sensitive reminders from natural language input
 */

interface TimeReference {
  originalText: string;
  parsedTime: Date;
  timeType: 'absolute' | 'relative' | 'recurring';
  confidence: number;
}

interface ReminderContext {
  type: 'pickup' | 'appointment' | 'call' | 'meeting' | 'medication' | 'task' | 'general';
  urgency: 'low' | 'medium' | 'high' | 'critical';
  defaultLeadTime: string;
  category: string;
}

interface ParsedReminder {
  isReminder: boolean;
  timeReference?: TimeReference;
  context: ReminderContext;
  action: string;
  subject?: string;
  location?: string;
  recurringPattern?: string;
  explicitLeadTime?: string;
}

export class IntelligentReminderParser {
  private static timePatterns = [
    // Absolute times
    { pattern: /(?:at |@)(\d{1,2}(?::\d{2})?(?:\s*(?:am|pm|AM|PM))?)/, type: 'absolute' },
    { pattern: /(today|tomorrow|yesterday)(?:\s+at\s+(\d{1,2}(?::\d{2})?(?:\s*(?:am|pm|AM|PM))?))?/i, type: 'absolute' },
    { pattern: /(monday|tuesday|wednesday|thursday|friday|saturday|sunday)(?:\s+at\s+(\d{1,2}(?::\d{2})?(?:\s*(?:am|pm|AM|PM))?))?/i, type: 'absolute' },
    { pattern: /(next\s+(?:week|month|year))/i, type: 'absolute' },
    
    // Relative times
    { pattern: /in\s+(\d+)\s+(minutes?|hours?|days?|weeks?|months?)/i, type: 'relative' },
    { pattern: /(\d+)\s+(minutes?|hours?|days?|weeks?|months?)\s+from\s+now/i, type: 'relative' },
    
    // Recurring patterns
    { pattern: /(daily|every\s+day)/i, type: 'recurring' },
    { pattern: /(weekly|every\s+week)/i, type: 'recurring' },
    { pattern: /(monthly|every\s+month)/i, type: 'recurring' },
    { pattern: /every\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i, type: 'recurring' },
    { pattern: /every\s+(\d+(?:st|nd|rd|th)?)\s+of\s+(?:the\s+)?month/i, type: 'recurring' }
  ];

  private static contextPatterns = [
    { pattern: /pick\s*up|collect|get|fetch/i, type: 'pickup', urgency: 'medium', leadTime: '10 minutes' },
    { pattern: /appointment|doctor|dentist|meeting/i, type: 'appointment', urgency: 'high', leadTime: '30 minutes' },
    { pattern: /call|phone|ring|contact/i, type: 'call', urgency: 'medium', leadTime: '5 minutes' },
    { pattern: /meeting|conference|session/i, type: 'meeting', urgency: 'high', leadTime: '15 minutes' },
    { pattern: /medication|medicine|pills?|take|dose/i, type: 'medication', urgency: 'critical', leadTime: 'immediate' },
    { pattern: /flight|travel|departure|airport/i, type: 'task', urgency: 'critical', leadTime: '2 hours' },
    { pattern: /workout|gym|exercise/i, type: 'task', urgency: 'medium', leadTime: '15 minutes' },
    { pattern: /pay|payment|bill|rent/i, type: 'task', urgency: 'high', leadTime: '1 day' }
  ];

  private static explicitReminderPatterns = [
    /remind\s+me\s+(\d+)\s+(minutes?|hours?|days?)\s+before/i,
    /(?:alert|notify)\s+me\s+(\d+)\s+(minutes?|hours?|days?)\s+(?:before|early)/i,
    /set\s+(?:a\s+)?reminder\s+for\s+(\d+)\s+(minutes?|hours?|days?)\s+before/i
  ];

  public static parseReminder(content: string): ParsedReminder {
    const normalizedContent = content.toLowerCase().trim();
    
    // Check if this looks like a reminder
    const reminderIndicators = [
      /(?:remind|alert|notify)/i,
      /(?:at|@)\s*\d+/,
      /(?:today|tomorrow|next)/i,
      /(?:pick\s*up|appointment|call|meeting)/i,
      /in\s+\d+\s+(?:minutes?|hours?|days?)/i,
      /(?:daily|weekly|monthly|every)/i
    ];

    const isReminder = reminderIndicators.some(pattern => pattern.test(content));
    
    if (!isReminder) {
      return {
        isReminder: false,
        context: { type: 'general', urgency: 'low', defaultLeadTime: '10 minutes', category: 'general' },
        action: content
      };
    }

    // Parse time references
    const timeReference = this.extractTimeReference(content);
    
    // Determine context and urgency
    const context = this.determineContext(content);
    
    // Check for explicit lead time instructions
    const explicitLeadTime = this.extractExplicitLeadTime(content);
    
    // Extract action and subject
    const action = this.extractAction(content);
    const subject = this.extractSubject(content);
    const location = this.extractLocation(content);
    const recurringPattern = this.extractRecurringPattern(content);

    return {
      isReminder: true,
      timeReference,
      context,
      action,
      subject,
      location,
      recurringPattern,
      explicitLeadTime
    };
  }

  private static extractTimeReference(content: string): TimeReference | undefined {
    for (const timePattern of this.timePatterns) {
      const match = content.match(timePattern.pattern);
      if (match) {
        const originalText = match[0];
        const parsedTime = this.parseTimeToDate(originalText, timePattern.type);
        
        if (parsedTime) {
          return {
            originalText,
            parsedTime,
            timeType: timePattern.type as 'absolute' | 'relative' | 'recurring',
            confidence: 0.8
          };
        }
      }
    }
    return undefined;
  }

  private static parseTimeToDate(timeText: string, timeType: string): Date | null {
    const now = new Date();
    
    try {
      if (timeType === 'relative') {
        const relativeMatch = timeText.match(/(\d+)\s+(minutes?|hours?|days?|weeks?|months?)/i);
        if (relativeMatch) {
          const amount = parseInt(relativeMatch[1]);
          const unit = relativeMatch[2].toLowerCase();
          
          const futureTime = new Date(now);
          
          switch (unit.charAt(0)) {
            case 'm': // minutes
              futureTime.setMinutes(futureTime.getMinutes() + amount);
              break;
            case 'h': // hours
              futureTime.setHours(futureTime.getHours() + amount);
              break;
            case 'd': // days
              futureTime.setDate(futureTime.getDate() + amount);
              break;
            case 'w': // weeks
              futureTime.setDate(futureTime.getDate() + (amount * 7));
              break;
            case 'M': // months (capital M to distinguish from minutes)
              futureTime.setMonth(futureTime.getMonth() + amount);
              break;
          }
          
          return futureTime;
        }
      } else if (timeType === 'absolute') {
        // Handle today/tomorrow with time
        if (timeText.includes('today')) {
          const timeMatch = timeText.match(/(\d{1,2}(?::\d{2})?(?:\s*(?:am|pm|AM|PM))?)/);
          if (timeMatch) {
            const time = this.parseTimeString(timeMatch[1]);
            if (time) {
              const todayWithTime = new Date(now);
              todayWithTime.setHours(time.hours, time.minutes, 0, 0);
              return todayWithTime;
            }
          }
        }
        
        if (timeText.includes('tomorrow')) {
          const timeMatch = timeText.match(/(\d{1,2}(?::\d{2})?(?:\s*(?:am|pm|AM|PM))?)/);
          if (timeMatch) {
            const time = this.parseTimeString(timeMatch[1]);
            if (time) {
              const tomorrowWithTime = new Date(now);
              tomorrowWithTime.setDate(tomorrowWithTime.getDate() + 1);
              tomorrowWithTime.setHours(time.hours, time.minutes, 0, 0);
              return tomorrowWithTime;
            }
          }
        }
        
        // Handle day of week
        const dayMatch = timeText.match(/(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i);
        if (dayMatch) {
          const targetDay = dayMatch[1].toLowerCase();
          const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
          const targetDayIndex = days.indexOf(targetDay);
          const currentDayIndex = now.getDay();
          
          let daysUntilTarget = targetDayIndex - currentDayIndex;
          if (daysUntilTarget <= 0) {
            daysUntilTarget += 7; // Next week
          }
          
          const targetDate = new Date(now);
          targetDate.setDate(targetDate.getDate() + daysUntilTarget);
          
          const timeMatch = timeText.match(/(\d{1,2}(?::\d{2})?(?:\s*(?:am|pm|AM|PM))?)/);
          if (timeMatch) {
            const time = this.parseTimeString(timeMatch[1]);
            if (time) {
              targetDate.setHours(time.hours, time.minutes, 0, 0);
            }
          }
          
          return targetDate;
        }
      }
      
      return null;
    } catch (error) {
      console.error('Error parsing time:', error);
      return null;
    }
  }

  private static parseTimeString(timeStr: string): { hours: number; minutes: number } | null {
    const timeMatch = timeStr.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm|AM|PM)?/);
    if (!timeMatch) return null;
    
    let hours = parseInt(timeMatch[1]);
    const minutes = parseInt(timeMatch[2] || '0');
    const meridiem = timeMatch[3]?.toLowerCase();
    
    if (meridiem === 'pm' && hours !== 12) {
      hours += 12;
    } else if (meridiem === 'am' && hours === 12) {
      hours = 0;
    }
    
    return { hours, minutes };
  }

  private static determineContext(content: string): ReminderContext {
    for (const contextPattern of this.contextPatterns) {
      if (contextPattern.pattern.test(content)) {
        return {
          type: contextPattern.type as any,
          urgency: contextPattern.urgency as any,
          defaultLeadTime: contextPattern.leadTime,
          category: contextPattern.type
        };
      }
    }
    
    return {
      type: 'general',
      urgency: 'medium',
      defaultLeadTime: '10 minutes',
      category: 'general'
    };
  }

  private static extractExplicitLeadTime(content: string): string | undefined {
    for (const pattern of this.explicitReminderPatterns) {
      const match = content.match(pattern);
      if (match) {
        return `${match[1]} ${match[2]}`;
      }
    }
    return undefined;
  }

  private static extractAction(content: string): string {
    // Remove time references and reminder keywords to get core action
    let action = content
      .replace(/remind\s+me\s+.*?(?:before|early)/i, '')
      .replace(/(?:at|@)\s*\d{1,2}(?::\d{2})?(?:\s*(?:am|pm|AM|PM))?/i, '')
      .replace(/(?:today|tomorrow|yesterday)/i, '')
      .replace(/(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i, '')
      .replace(/in\s+\d+\s+(?:minutes?|hours?|days?|weeks?|months?)/i, '')
      .trim();
    
    return action || content;
  }

  private static extractSubject(content: string): string | undefined {
    // Extract person names or specific subjects
    const personMatch = content.match(/(?:with|call|meet|see)\s+([a-zA-Z]+)/i);
    if (personMatch) {
      return personMatch[1];
    }
    
    const subjectMatch = content.match(/(?:pick\s*up|get|fetch)\s+([^at]+?)(?:\s+at|\s+from|$)/i);
    if (subjectMatch) {
      return subjectMatch[1].trim();
    }
    
    return undefined;
  }

  private static extractLocation(content: string): string | undefined {
    const locationMatch = content.match(/(?:at|from|in)\s+([^0-9]+?)(?:\s+at\s+\d|$)/i);
    if (locationMatch && !locationMatch[1].match(/\d{1,2}(?::\d{2})?/)) {
      return locationMatch[1].trim();
    }
    return undefined;
  }

  private static extractRecurringPattern(content: string): string | undefined {
    if (/daily|every\s+day/i.test(content)) return 'daily';
    if (/weekly|every\s+week/i.test(content)) return 'weekly';
    if (/monthly|every\s+month/i.test(content)) return 'monthly';
    
    const weeklyMatch = content.match(/every\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i);
    if (weeklyMatch) return `weekly_${weeklyMatch[1].toLowerCase()}`;
    
    const monthlyMatch = content.match(/every\s+(\d+(?:st|nd|rd|th)?)\s+of\s+(?:the\s+)?month/i);
    if (monthlyMatch) return `monthly_${monthlyMatch[1]}`;
    
    return undefined;
  }
}```

### server/utils/miraAIProcessing.ts
```typescript
/**
 * MIRA AI BRAIN - Processing Engine for Intelligent Note Handling
 * 
 * This is the central intelligence layer that ensures uniform AI processing
 * across all note types and input methods. All AI analysis must go through
 * this layer to maintain consistency.
 */

import { analyzeNote as analyzeWithClaude } from "../anthropic";
import { analyzeWithOpenAI, analyzeImageContent as analyzeImageWithOpenAI } from "../openai";

// UNIVERSAL NOTE STRUCTURE - ALL AI RESPONSES MUST FOLLOW THIS FORMAT
export interface MiraAIInput {
  content: string;
  mode: 'text' | 'voice' | 'image' | 'file';
  imageData?: string; // base64 for image analysis
  context?: string; // additional context like voice transcription
}

export interface MiraAIOutput {
  // CORE FIELDS - ALWAYS RETURNED
  title: string; // CRITICAL: 3-5 words max, newspaper headline style
  context: string; // Brief contextual summary (1-2 sentences)
  
  // TASK STRUCTURE
  todos: Array<{
    title: string;
    itemType?: 'task' | 'reminder';
    priority?: 'low' | 'medium' | 'high' | 'critical';
    timeDue?: string; // ISO date string
    timeDependency?: 'none' | 'sequential' | 'parallel';
    plannedNotificationStructure?: {
      enabled: boolean;
      reminderCategory: 'today' | 'tomorrow' | 'this-week' | 'later';
      repeatPattern: 'none' | 'daily' | 'weekly' | 'monthly';
      leadTimeNotifications: string[];
    };
    isActiveReminder?: boolean;
  }>;
  
  // INTELLIGENCE INSIGHTS
  intentType: 'simple-task' | 'complex-project' | 'research-inquiry' | 'personal-reflection' | 'reference-material';
  urgencyLevel: 'low' | 'medium' | 'high' | 'critical';
  complexityScore: number; // 1-10 scale
  
  // ENHANCED CONTEXT (conditional)
  suggestion?: string; // AI-generated follow-up suggestion
  richContext?: {
    recommendedActions: Array<{
      title: string;
      description: string;
      links?: Array<{ title: string; url: string }>;
    }>;
    researchResults?: Array<{
      title: string;
      description: string;
      rating?: string;
      keyPoints: string[];
      contact?: string;
    }>;
    quickInsights: string[];
    fromTheWeb?: Array<{
      title: string;
      url: string;
      summary: string;
    }>;
  };
  
  // INDIVIDUAL ITEM EXTRACTION
  extractedItems?: Array<{
    title: string;
    description?: string;
    category: string;
    metadata?: Record<string, any>;
  }>;
  
  // PREDICTIVE INTELLIGENCE
  nextSteps?: string[];
  timeToComplete?: string;
  successFactors?: string[];
  potentialObstacles?: string[];
  
  // KNOWLEDGE CONNECTIONS
  relatedTopics?: string[];
  skillsRequired?: string[];
  resourcesNeeded?: string[];
  
  // COLLECTION ORGANIZATION
  collectionSuggestion?: {
    name: string;
    icon: string;
    color: string;
  };
}

// UNIVERSAL AI PROCESSING INSTRUCTIONS
const CORE_INSTRUCTIONS = `
You are Mira's AI brain. Process this content and return a structured response.

CRITICAL TITLE RULES:
- Title MUST be 3-5 words maximum
- Use newspaper headline style (active, concise, engaging)
- Examples: "Buy Groceries Tomorrow", "Team Meeting Notes", "Restaurant Research"
- NEVER use long descriptive titles or full sentences

FIELD REQUIREMENTS:
- title: 3-5 words max, newspaper style
- context: 1-2 sentence summary
- todos: Extract clear actionable items
- intentType: Classify the content type
- urgencyLevel: Assess time sensitivity
- complexityScore: Rate 1-10 complexity
- suggestion: Optional helpful follow-up
- collectionSuggestion: Suggest appropriate collection if relevant

RESPONSE FORMAT: Return valid JSON only, no markdown or explanations.
`;

const SIMPLE_TASK_TEMPLATE = `
${CORE_INSTRUCTIONS}

For simple tasks/reminders:
- Keep title ultra-short (3-4 words)
- Focus on the action: "Call Mom", "Buy Milk", "Submit Report"
- Set urgency based on time sensitivity
- Minimal complexity (1-3)
- Brief, helpful suggestions only
`;

const COMPLEX_PROJECT_TEMPLATE = `
${CORE_INSTRUCTIONS}

For complex projects:
- Title captures main theme (4-5 words max)
- Break down into clear action items
- Higher complexity score (6-10)
- Provide strategic suggestions
- Include research recommendations if needed
`;

const RESEARCH_TEMPLATE = `
${CORE_INSTRUCTIONS}

For research/information gathering:
- Title reflects research topic (4-5 words)
- Extract research questions as todos
- Moderate to high complexity (5-8)
- Suggest research strategies
- Include relevant resource recommendations
`;

const IMAGE_ANALYSIS_TEMPLATE = `
${CORE_INSTRUCTIONS}

For image analysis:
- Title describes what's shown (3-5 words)
- Extract any text/data as todos if actionable
- Context explains visual content
- Suggest relevant follow-up actions
- Consider design/visual insights
`;

/**
 * Universal AI Processing Function
 * This is the ONLY function that should be called for AI analysis
 */
export async function processMiraInput(input: MiraAIInput): Promise<MiraAIOutput> {
  try {
    // Create structured prompt with universal template
    const structuredPrompt = createStructuredPrompt(input);
    
    // Route everything to OpenAI for consistency
    let result;
    const openaiModule = await import("../openai");
    
    if (input.mode === 'image' && input.imageData) {
      // Use OpenAI GPT-4o for image analysis
      result = await openaiModule.analyzeImageContent(input.imageData, structuredPrompt);
    } else {
      // Use OpenAI for all text analysis (simple and complex)
      result = await openaiModule.analyzeWithOpenAI(input.content, 'enhanced');
    }
    
    // Enforce universal structure constraints
    const processedResult = enforceStructure(result);
    
    return processedResult;
    
  } catch (error) {
    console.error('Mira AI processing error:', error);
    
    // Fallback response maintaining structure
    return {
      title: extractFallbackTitle(input.content),
      context: "Content processed successfully",
      todos: [],
      intentType: 'personal-reflection',
      urgencyLevel: 'low',
      complexityScore: 1,
    };
  }
}

/**
 * Create Structured Prompt with Universal Template
 */
function createStructuredPrompt(input: MiraAIInput): string {
  const template = selectTemplate(input);
  return `${template}

Content to analyze: "${input.content}"`;
}

/**
 * Template Selection Logic
 */
function selectTemplate(input: MiraAIInput): string {
  const content = input.content.toLowerCase();
  
  // Simple task patterns
  const simplePatterns = [
    /^(call|text|email|buy|pick up|remind|schedule)/,
    /^.{1,50}$/,  // Very short content
    /(tomorrow|today|tonight|this week)/,
  ];
  
  if (simplePatterns.some(pattern => pattern.test(content))) {
    return SIMPLE_TASK_TEMPLATE;
  }
  
  // Research patterns
  const researchPatterns = [
    /(research|find|look up|investigate|study|learn about)/,
    /(how to|what is|why does|when should)/,
    /(compare|analyze|evaluate)/,
  ];
  
  if (researchPatterns.some(pattern => pattern.test(content))) {
    return RESEARCH_TEMPLATE;
  }
  
  // Image analysis
  if (input.mode === 'image') {
    return IMAGE_ANALYSIS_TEMPLATE;
  }
  
  // Default to complex project for longer content
  if (content.length > 200) {
    return COMPLEX_PROJECT_TEMPLATE;
  }
  
  return SIMPLE_TASK_TEMPLATE;
}

/**
 * Enforce Structure Constraints
 */
function enforceStructure(result: any): MiraAIOutput {
  // Get title from AI response
  let title = result.title || result.enhancedContent || "New Note";
  
  // Remove AI partner indicators
  title = title.replace(/^\[claude\]\s*/i, '').replace(/^\[openai\]\s*/i, '');
  
  // CRITICAL: Enforce newspaper headline style (3-5 words MAX)
  title = createNewspaperTitle(title);
  
  return {
    title,
    context: result.context || result.aiContext || "Note processed",
    todos: Array.isArray(result.todos) ? result.todos.map((todo: any) => {
      if (typeof todo === 'string') {
        return { title: todo };
      }
      return {
        title: todo.title || todo,
        itemType: todo.itemType,
        priority: todo.priority,
        timeDue: todo.timeDue,
        timeDependency: todo.timeDependency,
        plannedNotificationStructure: todo.plannedNotificationStructure,
        isActiveReminder: todo.isActiveReminder
      };
    }) : [],
    intentType: result.intentType || 'personal-reflection',
    urgencyLevel: result.urgencyLevel || 'low',
    complexityScore: result.complexityScore || 1,
    suggestion: result.suggestion || result.aiSuggestion,
    richContext: result.richContext ? {
      recommendedActions: result.richContext.recommendedActions || [],
      researchResults: result.richContext.researchResults,
      quickInsights: result.richContext.quickInsights || [],
      fromTheWeb: result.richContext.fromTheWeb
    } : undefined,
    extractedItems: result.extractedItems,
    nextSteps: result.nextSteps,
    timeToComplete: result.timeToComplete,
    successFactors: result.successFactors,
    potentialObstacles: result.potentialObstacles,
    relatedTopics: result.relatedTopics,
    skillsRequired: result.skillsRequired,
    resourcesNeeded: result.resourcesNeeded,
    collectionSuggestion: result.collectionSuggestion
  };
}

/**
 * Create Newspaper Headline Style Title (3-5 words MAX)
 */
function createNewspaperTitle(input: string): string {
  // Clean input
  const cleanInput = input.trim().replace(/['"]/g, '');
  
  // Split into words and filter out articles, prepositions
  const words = cleanInput.split(/\s+/).filter(word => 
    word.length > 0 && 
    !['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(word.toLowerCase())
  );
  
  // Take first 3-4 most important words
  const titleWords = words.slice(0, 3);
  
  // Create proper case title
  const title = titleWords
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
    
  return title || 'New Note';
}

/**
 * Fallback Title Extraction
 */
function extractFallbackTitle(content: string): string {
  const words = content.trim().split(/\s+/).slice(0, 4);
  return words.join(' ') || "New Note";
}

// TEST CASES FOR VALIDATION
export const TEST_CASES = {
  simpleReminder: {
    input: {
      content: "Call mom tomorrow at 2pm about dinner plans",
      mode: 'text' as const,
    },
    expectedOutput: {
      title: "Call Mom Tomorrow", // 3 words
      intentType: 'simple-task',
      urgencyLevel: 'medium',
      complexityScore: 2,
    }
  },
  
  menuUpload: {
    input: {
      content: "Here's the menu from the new Italian restaurant downtown",
      mode: 'image' as const,
      imageData: "base64_image_data",
    },
    expectedOutput: {
      title: "Italian Restaurant Menu", // 3 words
      intentType: 'reference-material',
      urgencyLevel: 'low',
      complexityScore: 4,
    }
  },
  
  businessResearch: {
    input: {
      content: "Research starting a mobile app development consultancy focusing on healthcare apps. Need to understand market size, competition, required certifications, and potential revenue models.",
      mode: 'text' as const,
    },
    expectedOutput: {
      title: "Healthcare App Consultancy", // 3 words
      intentType: 'research-inquiry',
      urgencyLevel: 'medium',
      complexityScore: 8,
    }
  }
};```

### server/utils/title-governor.ts
```typescript
export const makeTitle = (raw:string):string=>{
  const clean=raw.trim().replace(/\s+/g,' ');
  return clean.length>55? clean.slice(0,52)+'…' : (clean||'Untitled');
};```

### server/vite.ts
```typescript
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(import.meta.dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}
```

### server/web-search-patterns.ts
```typescript
/**
 * Web Search Patterns for Rich AI Research Results
 * 
 * These patterns help identify when to trigger web research and how to structure results
 */

export interface WebSearchPattern {
  category: string;
  triggers: string[];
  searchQueries: string[];
  expectedSections: string[];
}

export const WEB_SEARCH_PATTERNS: WebSearchPattern[] = [
  {
    category: "Product Research",
    triggers: ["best", "recommend", "compare", "review", "vs", "which", "top"],
    searchQueries: [
      "best productivity apps 2024 reviews comparison",
      "MacBook Pro vs Dell XPS 13 2024 specs price",
      "best noise canceling headphones under $200",
      "top rated coffee makers consumer reports",
      "iPhone 15 Pro review battery life camera"
    ],
    expectedSections: ["Product Comparisons", "User Reviews", "Price Analysis", "Technical Specs"]
  },
  {
    category: "How-To & Tutorials",
    triggers: ["how to", "tutorial", "guide", "step by step", "learn", "setup"],
    searchQueries: [
      "how to set up home office ergonomic desk setup",
      "Python machine learning tutorial beginners 2024",
      "how to meal prep healthy recipes week",
      "JavaScript async await best practices examples",
      "how to invest in index funds for beginners"
    ],
    expectedSections: ["Step-by-Step Instructions", "Required Tools", "Common Mistakes", "Expert Tips"]
  },
  {
    category: "News & Current Events",
    triggers: ["latest", "news", "update", "current", "2024", "2025", "happening"],
    searchQueries: [
      "latest AI developments GPT-5 Claude 2024",
      "current cryptocurrency market trends Bitcoin",
      "climate change news renewable energy 2024",
      "tech industry layoffs 2024 statistics",
      "space exploration missions SpaceX NASA 2024"
    ],
    expectedSections: ["Recent Developments", "Key Statistics", "Expert Analysis", "Future Outlook"]
  },
  {
    category: "Local Research",
    triggers: ["near me", "local", "in [city]", "around", "nearby"],
    searchQueries: [
      "best restaurants near me Italian food reviews",
      "yoga classes San Francisco beginner friendly",
      "urgent care clinics open Sunday near me",
      "farmers markets Seattle weekend schedule",
      "coworking spaces downtown pricing amenities"
    ],
    expectedSections: ["Top Locations", "Hours & Contact", "Pricing", "User Ratings"]
  },
  {
    category: "Health & Wellness",
    triggers: ["symptoms", "treatment", "exercise", "diet", "wellness", "healthy"],
    searchQueries: [
      "lower back pain exercises physical therapy",
      "Mediterranean diet meal plan benefits research",
      "sleep hygiene tips improve sleep quality",
      "stress management techniques workplace burnout",
      "vitamin D deficiency symptoms treatment"
    ],
    expectedSections: ["Research Findings", "Expert Recommendations", "Action Steps", "Warning Signs"]
  },
  {
    category: "Travel Planning",
    triggers: ["travel", "visit", "trip", "vacation", "flight", "hotel"],
    searchQueries: [
      "best time visit Japan cherry blossom season",
      "Europe travel itinerary 2 weeks budget backpacking",
      "cheap flights New York to London deals",
      "things to do Iceland winter Northern Lights",
      "solo female travel safety tips Southeast Asia"
    ],
    expectedSections: ["Destination Highlights", "Budget Breakdown", "Timing Recommendations", "Practical Tips"]
  },
  {
    category: "Career & Education",
    triggers: ["career", "job", "salary", "skills", "certification", "course"],
    searchQueries: [
      "data scientist salary 2024 remote work trends",
      "Google Cloud certification exam preparation guide",
      "career change software engineering bootcamp reviews",
      "negotiating salary tips remote job offers",
      "LinkedIn profile optimization job search 2024"
    ],
    expectedSections: ["Market Insights", "Skill Requirements", "Career Paths", "Action Items"]
  },
  {
    category: "Technology Research",
    triggers: ["API", "framework", "library", "software", "tool", "platform"],
    searchQueries: [
      "React vs Vue.js 2024 performance comparison",
      "best project management tools small teams",
      "Stripe vs PayPal payment processing fees",
      "Docker containerization benefits tutorial",
      "cybersecurity tools small business recommendations"
    ],
    expectedSections: ["Technical Comparison", "Implementation Guide", "Cost Analysis", "Community Feedback"]
  },
  {
    category: "Financial Research",
    triggers: ["investment", "stock", "crypto", "budget", "loan", "mortgage"],
    searchQueries: [
      "index fund vs ETF investment strategy 2024",
      "first time home buyer mortgage rates",
      "emergency fund savings account high yield",
      "retirement planning 401k vs Roth IRA",
      "cryptocurrency tax implications 2024 filing"
    ],
    expectedSections: ["Financial Analysis", "Risk Assessment", "Current Rates", "Expert Advice"]
  },
  {
    category: "Scientific Research",
    triggers: ["study", "research", "evidence", "data", "statistics", "findings"],
    searchQueries: [
      "intermittent fasting research weight loss benefits",
      "climate change impact renewable energy adoption",
      "artificial intelligence job displacement studies",
      "microplastics health effects latest research",
      "space exploration Mars mission timeline NASA"
    ],
    expectedSections: ["Research Summary", "Key Findings", "Methodology", "Implications"]
  }
];

/**
 * Identifies if content should trigger web search
 */
export function shouldTriggerWebSearch(content: string): boolean {
  const contentLower = content.toLowerCase();
  
  // Check for question patterns
  if (contentLower.includes('?') || 
      contentLower.startsWith('what') || 
      contentLower.startsWith('how') ||
      contentLower.startsWith('where') ||
      contentLower.startsWith('when') ||
      contentLower.startsWith('why') ||
      contentLower.startsWith('which')) {
    return true;
  }
  
  // Check for research triggers
  const researchTriggers = [
    'research', 'find', 'look up', 'search', 'compare', 'best', 'top', 
    'review', 'recommend', 'latest', 'current', 'trend', 'news',
    'learn about', 'tell me about', 'explain', 'guide', 'tutorial'
  ];
  
  return researchTriggers.some(trigger => contentLower.includes(trigger));
}

/**
 * Generates appropriate search queries based on content
 */
export function generateSearchQueries(content: string): string[] {
  const contentLower = content.toLowerCase();
  const queries: string[] = [];
  
  // Find matching patterns
  for (const pattern of WEB_SEARCH_PATTERNS) {
    const hasPattern = pattern.triggers.some(trigger => contentLower.includes(trigger));
    if (hasPattern) {
      // Add context-specific queries
      queries.push(`${content} 2024 latest information`);
      queries.push(`${content} expert recommendations guide`);
      queries.push(`${content} comparison reviews analysis`);
      break;
    }
  }
  
  // Default queries if no pattern matches
  if (queries.length === 0) {
    queries.push(`${content} comprehensive guide 2024`);
    queries.push(`${content} expert analysis recommendations`);
  }
  
  return queries.slice(0, 3); // Limit to 3 queries
}

/**
 * Structures web research results into organized sections
 */
export function structureWebResults(searchResults: any[]): {
  fromTheWeb: any[];
  nextSteps: string[];
  keyInsights: string[];
} {
  return {
    fromTheWeb: searchResults.map(result => ({
      title: result.title || "Research Finding",
      description: result.description || result.content?.substring(0, 200) + "...",
      url: result.url || result.source,
      rating: result.rating || "4.2/5",
      keyPoints: result.keyPoints || [
        "Comprehensive analysis",
        "Expert insights",
        "Current data"
      ],
      lastUpdated: result.lastUpdated || "2024"
    })),
    nextSteps: [
      "Review detailed findings from web sources",
      "Compare different perspectives and recommendations",
      "Identify specific actions based on research",
      "Set follow-up research targets if needed"
    ],
    keyInsights: [
      "Multiple sources provide consistent recommendations",
      "Current trends favor evidence-based approaches",
      "Expert consensus supports strategic implementation"
    ]
  };
}```

### server/web-search.ts
```typescript
export interface WebSearchResult {
  title: string;
  description: string;
  url: string;
  rating?: string;
  keyPoints?: string[];
  category?: string;
  location?: string;
  distance?: string;
}

export interface LocationContext {
  city: string;
  state: string;
  country: string;
  coordinates: {
    lat: number;
    lng: number;
  };
}

/**
 * Check if content should trigger location-based search
 * Smart detection for commercial/shopping queries vs personal tasks
 */
export function shouldTriggerLocationSearch(content: string): boolean {
  const contentLower = content.toLowerCase();
  
  // Exclude personal/family tasks that aren't searchable
  const personalTaskExclusions = [
    'pick up', 'pickup', 'drop off', 'dropoff', 'call', 'text', 'email',
    'remind', 'appointment', 'meeting', 'schedule', 'calendar',
    'homework', 'school', 'work', 'office', 'colleague', 'boss',
    'mom', 'dad', 'parent', 'child', 'kid', 'family', 'friend',
    'doctor', 'dentist', 'vet', 'appointment'
  ];
  
  // If it's a personal task, don't trigger search
  if (personalTaskExclusions.some(exclusion => contentLower.includes(exclusion))) {
    return false;
  }
  
  // Commercial product patterns (product + store/brand)
  const commercialPatterns = [
    // Product + retailer combinations
    { products: ['sock', 'socks', 'shirt', 'pants', 'shoes', 'clothes', 'clothing'], 
      retailers: ['target', 'walmart', 'amazon', 'costco', 'macys', 'nordstrom'] },
    { products: ['food', 'groceries', 'milk', 'bread', 'meat', 'produce'], 
      retailers: ['target', 'walmart', 'safeway', 'kroger', 'whole foods', 'trader joes'] },
    { products: ['electronics', 'phone', 'laptop', 'tv', 'headphones'], 
      retailers: ['best buy', 'target', 'amazon', 'apple store', 'costco'] },
    { products: ['tools', 'hardware', 'paint', 'lumber'], 
      retailers: ['home depot', 'lowes', 'menards'] }
  ];
  
  // Check for commercial product + retailer patterns
  for (const pattern of commercialPatterns) {
    const hasProduct = pattern.products.some(product => contentLower.includes(product));
    const hasRetailer = pattern.retailers.some(retailer => contentLower.includes(retailer));
    
    if (hasProduct && hasRetailer) {
      return true;
    }
  }
  
  // Direct shopping intent keywords
  const shoppingTriggers = [
    'buy from', 'shop at', 'get from', 'purchase at', 'order from',
    'find at', 'available at', 'sold at', 'price at'
  ];
  
  if (shoppingTriggers.some(trigger => contentLower.includes(trigger))) {
    return true;
  }
  
  // Restaurant/venue searches
  const venueTriggers = [
    'restaurant', 'cafe', 'bar', 'hotel', 'venue', 'reservation',
    'book table', 'dinner at', 'lunch at', 'eat at'
  ];
  
  if (venueTriggers.some(trigger => contentLower.includes(trigger))) {
    return true;
  }
  
  return false;
}

/**
 * Generate location-aware search queries
 */
export function generateLocationSearchQueries(content: string, location?: LocationContext | null): string[] {
  const queries: string[] = [];
  const contentLower = content.toLowerCase();
  
  // Extract key terms for search
  const searchTerms = extractSearchTerms(content);
  
  if (location) {
    const locationString = `${location.city}, ${location.state}`;
    
    // Add location-specific queries
    searchTerms.forEach(term => {
      queries.push(`${term} near ${locationString}`);
      queries.push(`${term} ${location.city}`);
      queries.push(`best ${term} ${locationString}`);
    });
    
    // Add specific business/service queries
    if (contentLower.includes('venue') || contentLower.includes('party')) {
      queries.push(`party venues ${locationString}`);
      queries.push(`event spaces ${locationString}`);
    }
    
    if (contentLower.includes('gift') || contentLower.includes('present')) {
      queries.push(`gift shops ${locationString}`);
      queries.push(`toy stores ${locationString}`);
    }
    
    if (contentLower.includes('cake') || contentLower.includes('bakery')) {
      queries.push(`custom birthday cakes ${locationString}`);
      queries.push(`bakeries ${locationString}`);
    }
    
    if (contentLower.includes('decoration')) {
      queries.push(`party decorations ${locationString}`);
      queries.push(`party supply stores ${locationString}`);
    }
  } else {
    // Generic searches when no location is available
    searchTerms.forEach(term => {
      queries.push(`${term} guide`);
      queries.push(`best ${term} reviews`);
      queries.push(`how to find ${term}`);
    });
    
    // Add generic location-agnostic advice
    if (contentLower.includes('venue') || contentLower.includes('party')) {
      queries.push('party venue selection tips');
      queries.push('birthday party venue ideas');
    }
    
    if (contentLower.includes('restaurant')) {
      queries.push('family restaurant selection guide');
      queries.push('restaurant booking tips');
    }
  }
  
  return queries.slice(0, 5); // Limit to 5 queries
}

/**
 * Extract meaningful search terms from content
 */
function extractSearchTerms(content: string): string[] {
  const terms: string[] = [];
  const contentLower = content.toLowerCase();
  
  // Common term patterns
  const termPatterns = [
    /\b(venue|restaurant|store|shop|bakery|party supply)\b/gi,
    /\b(birthday cake|gift|present|decoration|balloon)\b/gi,
    /\b(book|movie|travel|hotel|flight)\b/gi
  ];
  
  termPatterns.forEach(pattern => {
    const matches = content.match(pattern);
    if (matches) {
      terms.push(...matches.map(m => m.toLowerCase()));
    }
  });
  
  // If no specific terms found, use general search terms
  if (terms.length === 0) {
    if (contentLower.includes('party')) terms.push('party supplies');
    if (contentLower.includes('birthday')) terms.push('birthday party');
    if (contentLower.includes('cake')) terms.push('birthday cake');
    if (contentLower.includes('gift')) terms.push('gifts');
  }
  
  return Array.from(new Set(terms)); // Remove duplicates
}

/**
 * Generate generic advice results when no location is available
 */
function generateGenericAdviceResults(query: string): WebSearchResult[] {
  const results: WebSearchResult[] = [];
  const queryLower = query.toLowerCase();
  
  if (queryLower.includes('party venue') || queryLower.includes('venue')) {
    results.push({
      title: "How to Choose the Perfect Party Venue",
      description: "Complete guide to selecting birthday party venues: indoor vs outdoor options, capacity planning, catering considerations, and booking tips.",
      url: "https://example.com/party-venue-guide",
      rating: "4.8/5",
      keyPoints: ["Capacity planning", "Budget considerations", "Amenities checklist", "Booking timeline"],
      category: "Planning Guide"
    });
  }
  
  if (queryLower.includes('restaurant') || queryLower.includes('food')) {
    results.push({
      title: "Family Restaurant Selection Tips",
      description: "Expert advice on choosing family-friendly restaurants: kid-friendly menus, outdoor seating, reservation strategies, and special occasion planning.",
      url: "https://example.com/restaurant-guide",
      rating: "4.6/5",
      keyPoints: ["Kid-friendly options", "Outdoor seating benefits", "Reservation timing", "Special requests"],
      category: "Dining Guide"
    });
  }
  
  if (queryLower.includes('gift') || queryLower.includes('present')) {
    results.push({
      title: "Age-Appropriate Gift Ideas & Shopping Tips",
      description: "Comprehensive guide to selecting birthday gifts: age-appropriate toys, educational options, budget planning, and where to shop.",
      url: "https://example.com/gift-guide",
      rating: "4.7/5",
      keyPoints: ["Age recommendations", "Educational value", "Safety considerations", "Budget planning"],
      category: "Gift Guide"
    });
  }
  
  return results;
}

/**
 * Web search function with location awareness
 */
export async function performLocationWebSearch(
  queries: string[], 
  location?: LocationContext | null
): Promise<WebSearchResult[]> {
  // Return empty results for now - web search integration requires real APIs
  // This prevents showing synthetic data to users
  return [];
}

/**
 * Generate realistic mock search results based on location context
 */
function generateMockLocationResults(query: string, location: LocationContext): WebSearchResult[] {
  const results: WebSearchResult[] = [];
  const queryLower = query.toLowerCase();
  
  const locationString = `${location.city}, ${location.state}`;
  
  if (queryLower.includes('party venue') || queryLower.includes('event space')) {
    results.push({
      title: `Top 10 Party Venues in ${location.city}`,
      description: `Best event spaces and party venues for birthdays, celebrations, and special events in ${locationString}.`,
      url: `https://example.com/party-venues-${location.city.toLowerCase()}`,
      rating: "4.5/5",
      keyPoints: ["Indoor/outdoor options", "Catering available", "Kid-friendly", "Booking required"],
      category: "Venues",
      location: locationString,
      distance: "2-15 miles"
    });
  }
  
  if (queryLower.includes('gift') || queryLower.includes('toy')) {
    results.push({
      title: `Best Gift Shops in ${location.city}`,
      description: `Top-rated toy stores and gift shops for children's presents and birthday gifts in ${locationString}.`,
      url: `https://example.com/gift-shops-${location.city.toLowerCase()}`,
      rating: "4.3/5",
      keyPoints: ["Age-appropriate toys", "Educational games", "Gift wrapping", "Local favorites"],
      category: "Shopping",
      location: locationString,
      distance: "1-8 miles"
    });
  }
  
  if (queryLower.includes('restaurant') || queryLower.includes('food')) {
    results.push({
      title: `Family Restaurants with Outdoor Seating - ${location.city}`,
      description: `Family-friendly restaurants featuring outdoor dining, kids menus, and birthday party accommodations in ${locationString}.`,
      url: `https://example.com/restaurants-${location.city.toLowerCase()}`,
      rating: "4.4/5",
      keyPoints: ["Outdoor seating", "Kids menu", "Birthday celebrations", "Reservations recommended"],
      category: "Dining",
      location: locationString,
      distance: "0.5-12 miles"
    });
  }
  
  if (queryLower.includes('cake') || queryLower.includes('bakery')) {
    results.push({
      title: `Custom Birthday Cakes - ${location.city} Bakeries`,
      description: `Local bakeries specializing in custom birthday cakes, themed designs, and special dietary options in ${locationString}.`,
      url: `https://example.com/bakeries-${location.city.toLowerCase()}`,
      rating: "4.6/5",
      keyPoints: ["Custom designs", "Dietary options", "Advance ordering", "Themed cakes"],
      category: "Bakeries",
      location: locationString,
      distance: "2-10 miles"
    });
  }
  
  if (queryLower.includes('decoration') || queryLower.includes('party supply')) {
    results.push({
      title: `Party City & Local Party Supply Stores - ${location.city}`,
      description: `Party decorations, balloons, and supplies for birthday parties and celebrations in ${locationString}.`,
      url: `https://example.com/party-supplies-${location.city.toLowerCase()}`,
      rating: "4.2/5",
      keyPoints: ["Theme decorations", "Balloon arrangements", "Same-day pickup", "Bulk discounts"],
      category: "Party Supplies",
      location: locationString,
      distance: "1-10 miles"
    });
  }
  
  // Enhanced product + retailer detection with real shopping results
  if (queryLower.includes('target') && (queryLower.includes('sock') || queryLower.includes('clothing'))) {
    results.push({
      title: `Target - ${location.city} Store Locations & Hours`,
      description: `Find Target stores near you in ${locationString}. Current drive times, store hours, and in-stock availability for clothing department.`,
      url: `https://www.target.com/store-locator`,
      rating: "4.1/5 • Open until 10 PM",
      keyPoints: ["Drive time: 8 min", "In-stock socks", "Curbside pickup", "Same-day delivery"],
      category: "Store Locations",
      location: locationString,
      distance: "2.1 miles • Light traffic"
    });
    
    results.push({
      title: `Men's Crew Socks 6pk - Goodfellow & Co.™ - Target`,
      description: `$6.00 • 6-pack cotton blend crew socks. Available in multiple colors. Free shipping on orders $35+.`,
      url: `https://www.target.com/p/men-s-crew-socks-6pk-goodfellow-co/-/A-53476543`,
      rating: "4.3/5 • 2,847 reviews",
      keyPoints: ["Cotton blend", "$6.00 for 6-pack", "Available in 8 colors", "Add to cart"],
      category: "Men's Clothing"
    });
    
    results.push({
      title: `Women's No Show Socks 6pk - A New Day™ - Target`,
      description: `$4.00 • Comfortable no-show socks perfect for sneakers and flats. Moisture-wicking fabric.`,
      url: `https://www.target.com/p/women-s-no-show-socks-6pk-a-new-day/-/A-54367821`,
      rating: "4.4/5 • 1,456 reviews",
      keyPoints: ["$4.00 for 6-pack", "No-show design", "Moisture-wicking", "Machine washable"],
      category: "Women's Clothing"
    });
    
    results.push({
      title: `Athletic Crew Socks 3pk - All in Motion™ - Target`,
      description: `$8.00 • Performance athletic socks with cushioned sole and arch support. Ideal for workouts.`,
      url: `https://www.target.com/p/athletic-crew-socks-3pk-all-in-motion/-/A-79431287`,
      rating: "4.5/5 • 892 reviews",
      keyPoints: ["Cushioned sole", "Arch support", "Moisture-wicking", "Performance fabric"],
      category: "Athletic Wear"
    });
  }
  
  return results;
}

/**
 * Get user's location from IP geolocation or user profile
 */
export async function getUserLocation(req?: any): Promise<LocationContext | null> {
  if (req) {
    const forwardedFor = req.headers['x-forwarded-for'];
    const realIp = req.headers['x-real-ip'];
    const clientIp = forwardedFor || realIp || req.connection.remoteAddress;
    
    if (clientIp && clientIp !== '127.0.0.1' && clientIp !== '::1') {
      try {
        // Use free IP geolocation service
        const response = await fetch(`http://ip-api.com/json/${clientIp}`);
        const data = await response.json();
        
        if (data.status === 'success') {
          return {
            city: data.city,
            state: data.regionName,
            country: data.countryCode,
            coordinates: {
              lat: data.lat,
              lng: data.lon
            }
          };
        }
      } catch (error) {
        console.log(`IP geolocation failed for ${clientIp}:`, (error as Error).message);
      }
    }
  }
  
  // Return null if no location can be determined
  // This prevents arbitrary defaults and forces generic searches
  return null;
}```

### server/welcome-note.ts
```typescript
import { storage } from "./storage";

export async function createWelcomeNote() {
  const welcomeContent = `🎉 Welcome to Mira - Your AI-Powered Memory Assistant!

Think of me as your personal research assistant who's always two steps ahead. Here's what makes Mira special:

🎤 VOICE-TO-INTELLIGENCE
Say: "Research the best Italian restaurants in San Francisco with outdoor seating"
→ I'll transcribe, research actual restaurants, find reviews, get contact info, and create actionable todos

📸 VISUAL UNDERSTANDING  
Take a photo of a recipe, business card, or whiteboard
→ I'll extract text, provide context, and organize everything intelligently

🧠 SMART ORGANIZATION
Everything gets automatically sorted into 10 collections:
• Personal, Work, Home, Family
• Travel, Ideas, Movies & TV, Books
• Health & Fitness, and Undefined (for edge cases)

🔍 GOOGLE-STYLE RESEARCH
I don't just summarize - I research! Ask about:
• "Best homeschooling curriculum for 8-year-olds"
• "Compare Tesla Model 3 vs BMW i4"
• "Plan a 5-day Tokyo itinerary"

And I'll find real data, compare options, provide ratings, and suggest next steps.

✅ AUTO-TODO EXTRACTION
From any note, I automatically create actionable items:
"Research vacation rentals in Tuscany" becomes:
→ "Compare Airbnb vs VRBO prices"
→ "Check flight costs to Florence"
→ "Read reviews for top 5 properties"

💡 TRY THIS NOW:
Voice record: "I want to start learning photography - recommend beginner cameras under $800"

Watch as I research actual camera models, compare specs, find current prices, and create a shopping checklist!

Ready to see what your AI memory can do? 🚀`;

  try {
    const note = await storage.createNote({
      content: welcomeContent,
      mode: "standard"
    });

    // Create some welcome todos
    await storage.createTodo({
      title: "Try voice recording a research question",
      noteId: note.id,
      priority: "normal"
    });

    await storage.createTodo({
      title: "Take a photo of something interesting to analyze",
      noteId: note.id,
      priority: "normal"
    });

    await storage.createTodo({
      title: "Ask Mira to plan something you're curious about",
      noteId: note.id,
      priority: "normal"
    });

    console.log("Welcome note created successfully!");
    return note;
  } catch (error) {
    console.error("Failed to create welcome note:", error);
  }
}```
## FRONTEND SOURCE FILES

### client/src/app-bootstrap.tsx
```typescript
import React, { useEffect, useState, ReactNode } from 'react';
import { useAppStore, setupNetworkMonitoring } from './store/app-store';
import { indexedDB } from './store/indexeddb';
import { Wifi, WifiOff, Loader2, AlertCircle } from 'lucide-react';

interface AppBootstrapProps {
  children: ReactNode;
}

export function AppBootstrap({ children }: AppBootstrapProps) {
  const [isInitialized, setIsInitialized] = useState(false);
  const [initError, setInitError] = useState<string | null>(null);
  
  const { 
    isOffline, 
    isLoading, 
    syncQueue, 
    setNotes, 
    setTodos, 
    setCollections 
  } = useAppStore();

  useEffect(() => {
    let networkCleanup: (() => void) | undefined;

    const initializeApp = async () => {
      try {
        // Initialize IndexedDB
        await indexedDB.init();
        
        // Load data from IndexedDB first (for offline-first experience)
        const [notes, todos, collections] = await Promise.all([
          indexedDB.getAllNotes(),
          indexedDB.getAllTodos(),
          indexedDB.getAllCollections()
        ]);

        // Update store with local data
        setNotes(notes);
        setTodos(todos);
        setCollections(collections);

        // Setup network monitoring
        networkCleanup = setupNetworkMonitoring();

        // If online, sync with server
        if (navigator.onLine) {
          try {
            // Fetch latest data from server
            const [serverNotes, serverTodos, serverCollections] = await Promise.all([
              fetch('/api/notes').then(r => r.json()),
              fetch('/api/todos').then(r => r.json()),
              fetch('/api/collections').then(r => r.json())
            ]);

            // Update both local storage and store
            await Promise.all([
              ...serverNotes.map((note: any) => indexedDB.saveNote(note)),
              ...serverTodos.map((todo: any) => indexedDB.saveTodo(todo)),
              ...serverCollections.map((collection: any) => indexedDB.saveCollection(collection))
            ]);

            setNotes(serverNotes);
            setTodos(serverTodos);
            setCollections(serverCollections);
          } catch (serverError) {
            console.warn('Server sync failed, using local data:', serverError);
            // Continue with local data
          }
        }

        setIsInitialized(true);
      } catch (error) {
        console.error('App initialization failed:', error);
        setInitError(error instanceof Error ? error.message : 'Failed to initialize app');
      }
    };

    initializeApp();

    return () => {
      if (networkCleanup) {
        networkCleanup();
      }
    };
  }, [setNotes, setTodos, setCollections]);



  if (initError) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900">
        <div className="max-w-md w-full mx-4 p-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-red-200 dark:border-red-800">
          <div className="flex items-center gap-3 mb-4">
            <AlertCircle className="w-6 h-6 text-red-500" />
            <h2 className="text-lg font-semibold text-red-800 dark:text-red-200">
              Initialization Failed
            </h2>
          </div>
          
          <p className="text-sm text-red-600 dark:text-red-300 mb-4">
            {initError}
          </p>
          
          <button
            onClick={() => window.location.reload()}
            className="w-full px-4 py-2 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded-md hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors"
          >
            Reload App
          </button>
        </div>
      </div>
    );
  }

  if (!isInitialized) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900">
        <div className="flex flex-col items-center gap-4">
          <Loader2 className="w-8 h-8 text-blue-500 animate-spin" />
          <p className="text-gray-600 dark:text-gray-400">Initializing Mira...</p>
        </div>
      </div>
    );
  }

  return (
    <>
      {children}
    </>
  );
}```

### client/src/App.tsx
```typescript
import React from "react";
import { Router, Route, Switch } from "wouter";
import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";
import { ErrorBoundary } from "@/components/error-boundary";
import { Toaster } from "@/components/ui/toaster";
import DevCacheDebugger from "@/components/dev-cache-debugger";
import { offlineStorage, serviceWorkerManager } from "@/store/offline-storage";
import { useEffect } from "react";

// Import pages
import Notes from "@/pages/notes";
import Remind from "@/pages/remind";

import Profile from "@/pages/profile";
import NoteDetailSimple from "@/components/NoteDetailSimple";
import CollectionDetail from "@/pages/collection-detail";
import TodoDetail from "@/pages/todo-detail";
import NotFound from "@/pages/not-found";

export default function App() {
  // Initialize offline storage and service worker
  useEffect(() => {
    const initializeOfflineFeatures = async () => {
      try {
        await offlineStorage.init();
        await serviceWorkerManager.init();
        
        // Clean stale cache entries periodically
        const interval = setInterval(() => {
          offlineStorage.clearStaleEntries();
        }, 5 * 60 * 1000); // Every 5 minutes
        
        return () => clearInterval(interval);
      } catch (error) {
        console.warn('Failed to initialize offline features:', error);
      }
    };
    
    initializeOfflineFeatures();
  }, []);

  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <Router>
          <div className="min-h-screen bg-[#f1efe8]">
            <Switch>
              <Route path="/" component={Notes} />
              <Route path="/remind" component={Remind} />
              <Route path="/profile" component={Profile} />
              <Route path="/notes/:id" component={NoteDetailSimple} />
              <Route path="/collection/:id" component={CollectionDetail} />
              <Route path="/todo/:id" component={TodoDetail} />
              <Route component={NotFound} />
            </Switch>
          </div>
        </Router>
        <Toaster />
      </QueryClientProvider>
    </ErrorBoundary>
  );
}```

### client/src/components/activity-feed.tsx
```typescript
import { useQuery } from "@tanstack/react-query";
import { useState } from "react";
import { Search, List, Grid } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import type { NoteWithTodos } from "@shared/schema";
import NoteCard from "./note-card";

interface ActivityFeedProps {
  onTodoModalClose?: () => void;
}

export default function ActivityFeed({ onTodoModalClose }: ActivityFeedProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [showSearch, setShowSearch] = useState(false);
  const [isCondensedView, setIsCondensedView] = useState(false);
  
  const { data: notes, isLoading } = useQuery<NoteWithTodos[]>({
    queryKey: ["/api/notes"],
    staleTime: 120000, // Cache for 2 minutes for faster navigation
    gcTime: 600000, // Keep in cache for 10 minutes
    refetchOnWindowFocus: false, // Prevent excessive refetching
    refetchOnMount: false, // Don't refetch when component mounts if data is fresh
  });

  // Debug logging to see what data we're getting
  console.log("ActivityFeed - notes data:", notes);
  console.log("ActivityFeed - isLoading:", isLoading);

  const filteredNotes = notes?.filter(note => {
    return note.content.toLowerCase().includes(searchTerm.toLowerCase());
  }).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()) || [];

  if (isLoading) {
    return (
      <div className="space-y-4">
        <div className="flex items-center justify-between mb-4 pt-6">
          <h2 className="text-2xl font-serif font-medium">Notes</h2>
          <button 
            onClick={() => setShowSearch(!showSearch)}
            className="p-2 hover:bg-[hsl(var(--muted))] rounded-lg"
          >
            <Search className="w-5 h-5" />
          </button>
        </div>
        <div className="space-y-4">
          {[1, 2, 3].map((i) => (
            <div key={i} className="note-card animate-pulse">
              <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
              <div className="h-3 bg-gray-200 rounded w-1/2"></div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (!notes || notes.length === 0) {
    return (
      <div className="space-y-4 px-4">
        <div className="flex items-center justify-between mb-4 pt-6">
          <h2 className="text-2xl font-serif font-medium">Notes</h2>
          <button 
            onClick={() => setShowSearch(!showSearch)}
            className="p-2 hover:bg-[hsl(var(--muted))] rounded-lg"
          >
            <Search className="w-5 h-5" />
          </button>
        </div>
        <div className="text-center py-8">
          <p className="text-[hsl(var(--muted-foreground))]">No notes yet. Start by capturing your first thought!</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between mb-4 px-4 pt-6">
        <h2 className="text-2xl font-serif font-medium">Notes</h2>
        <div className="flex items-center gap-2">
          <button 
            onClick={() => setIsCondensedView(!isCondensedView)}
            className="p-2 hover:bg-[hsl(var(--muted))] rounded-lg"
            title={isCondensedView ? "Switch to expanded view" : "Switch to condensed view"}
          >
            {isCondensedView ? <Grid className="w-5 h-5" /> : <List className="w-5 h-5" />}
          </button>
          <button 
            onClick={() => setShowSearch(!showSearch)}
            className="p-2 hover:bg-[hsl(var(--muted))] rounded-lg"
          >
            <Search className="w-5 h-5" />
          </button>
        </div>
      </div>

      {showSearch && (
        <div className="mb-4">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-[hsl(var(--muted-foreground))]" />
            <input
              type="text"
              placeholder="Search notes..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full pl-10 pr-4 py-2.5 rounded-xl border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-sm"
            />
          </div>
        </div>
      )}

      <div className={isCondensedView ? "space-y-2" : "space-y-4"}>
        {filteredNotes.map((note) => (
          isCondensedView ? (
            <div 
              key={note.id}
              className="flex items-center justify-between p-3 bg-[hsl(var(--card))] rounded-lg border border-[hsl(var(--border))] hover:bg-[hsl(var(--muted))] transition-colors cursor-pointer"
              onClick={() => window.location.href = `/note/${note.id}`}
            >
              <div className="flex-1 min-w-0">
                <p className="text-sm font-medium text-[hsl(var(--foreground))] truncate">
                  {note.content.split('\n')[0] || 'Untitled note'}
                </p>
                <div className="flex items-center gap-2 mt-1">
                  <span className="text-xs text-[hsl(var(--muted-foreground))]">
                    {formatDistanceToNow(new Date(note.createdAt), { addSuffix: true })
                      .replace('about ', '').replace(' hours', 'h').replace(' hour', 'h')
                      .replace(' minutes', 'm').replace(' minute', 'm').replace(' days', 'd')
                      .replace(' day', 'd').replace(' weeks', 'w').replace(' week', 'w')
                      .replace('less than a minute', 'less than a min')
                      .replace('less than am', 'less than a min')}
                  </span>
                  {note.todos && note.todos.length > 0 && (
                    <span className="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full">
                      {note.todos.length} todos
                    </span>
                  )}
                </div>
              </div>
            </div>
          ) : (
            <NoteCard key={note.id} note={note} onTodoModalClose={onTodoModalClose} />
          )
        ))}
      </div>
    </div>
  );
}
```

### client/src/components/ai-comparison.tsx
```typescript
import { useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Card } from "@/components/ui/card";
import { Loader2, GraduationCap, Zap } from "lucide-react";

interface ComparisonResult {
  original: string;
  openAI: {
    success: boolean;
    result: any;
    error: string | null;
  };
  claude: {
    success: boolean;
    result: any;
    error: string | null;
  };
  mira: {
    success: boolean;
    result: any;
    error: string | null;
  };
}

export default function AIComparison() {
  const [content, setContent] = useState("");
  const [results, setResults] = useState<ComparisonResult | null>(null);

  const compareMutation = useMutation({
    mutationFn: async (content: string) => {
      const response = await apiRequest("POST", "/api/compare-ai", { content, mode: "enhanced" });
      return response.json();
    },
    onSuccess: (data) => {
      setResults(data);
    },
  });

  const handleCompare = () => {
    if (content.trim()) {
      compareMutation.mutate(content.trim());
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-4 space-y-6">
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-2">AI Comparison Tool</h2>
        <p className="text-gray-600">Test the same input with both OpenAI and Claude to compare their results</p>
      </div>

      <div className="space-y-4">
        <Textarea
          placeholder="Enter your note content here to compare AI processing..."
          value={content}
          onChange={(e) => setContent(e.target.value)}
          rows={4}
          className="w-full"
        />
        
        <Button 
          onClick={handleCompare} 
          disabled={!content.trim() || compareMutation.isPending}
          className="w-full"
        >
          {compareMutation.isPending ? (
            <>
              <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              Analyzing with both AIs...
            </>
          ) : (
            "Compare AI Results"
          )}
        </Button>
      </div>

      {results && (
        <div className="grid md:grid-cols-2 gap-6">
          {/* OpenAI Results */}
          <Card className="p-6">
            <div className="flex items-center gap-2 mb-4">
              <Zap className="w-5 h-5 text-blue-500" />
              <h3 className="text-lg font-semibold">OpenAI Results</h3>
            </div>
            
            {results.openAI.success ? (
              <div className="space-y-4">
                {results.openAI.result.enhancedContent && (
                  <div>
                    <h4 className="font-medium text-sm text-gray-600 mb-2">Enhanced Content:</h4>
                    <p className="text-sm bg-gray-50 p-3 rounded">{results.openAI.result.enhancedContent}</p>
                  </div>
                )}
                
                {results.openAI.result.todos && results.openAI.result.todos.length > 0 && (
                  <div>
                    <h4 className="font-medium text-sm text-gray-600 mb-2">Extracted Tasks:</h4>
                    <ul className="text-sm space-y-1">
                      {results.openAI.result.todos.map((todo: string, index: number) => (
                        <li key={index} className="flex items-start gap-2">
                          <span className="text-gray-400">•</span>
                          {todo}
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                
                {results.openAI.result.collectionSuggestion && (
                  <div>
                    <h4 className="font-medium text-sm text-gray-600 mb-2">Collection Suggestion:</h4>
                    <p className="text-sm bg-blue-50 p-2 rounded">
                      {results.openAI.result.collectionSuggestion.name} ({results.openAI.result.collectionSuggestion.icon})
                    </p>
                  </div>
                )}
                
                {results.openAI.result.richContext && (
                  <div>
                    <h4 className="font-medium text-sm text-gray-600 mb-2">Key Insights:</h4>
                    <div className="text-sm bg-gray-50 p-3 rounded space-y-2">
                      <p><strong>Summary:</strong> {results.openAI.result.richContext.summary}</p>
                      {results.openAI.result.richContext.keyInsights && results.openAI.result.richContext.keyInsights.length > 0 && (
                        <div>
                          <strong>Insights:</strong>
                          <ul className="mt-1 space-y-1">
                            {results.openAI.result.richContext.keyInsights.map((insight: string, index: number) => (
                              <li key={index} className="ml-4">• {insight}</li>
                            ))}
                          </ul>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <div className="text-red-600 text-sm">
                Error: {results.openAI.error || "Analysis failed"}
              </div>
            )}
          </Card>

          {/* Claude Results */}
          <Card className="p-6">
            <div className="flex items-center gap-2 mb-4">
              <GraduationCap className="w-5 h-5 text-orange-500 opacity-20" />
              <h3 className="text-lg font-semibold">Claude Results</h3>
            </div>
            
            {results.claude.success ? (
              <div className="space-y-4">
                {results.claude.result.enhancedContent && (
                  <div>
                    <h4 className="font-medium text-sm text-gray-600 mb-2">Enhanced Content:</h4>
                    <p className="text-sm bg-gray-50 p-3 rounded">{results.claude.result.enhancedContent}</p>
                  </div>
                )}
                
                {results.claude.result.todos && results.claude.result.todos.length > 0 && (
                  <div>
                    <h4 className="font-medium text-sm text-gray-600 mb-2">Extracted Tasks:</h4>
                    <ul className="text-sm space-y-1">
                      {results.claude.result.todos.map((todo: string, index: number) => (
                        <li key={index} className="flex items-start gap-2">
                          <span className="text-gray-400">•</span>
                          {todo}
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                
                {results.claude.result.collectionSuggestion && (
                  <div>
                    <h4 className="font-medium text-sm text-gray-600 mb-2">Collection Suggestion:</h4>
                    <p className="text-sm bg-orange-50 p-2 rounded">
                      {results.claude.result.collectionSuggestion.name} ({results.claude.result.collectionSuggestion.icon})
                    </p>
                  </div>
                )}
                
                {results.claude.result.richContext && (
                  <div>
                    <h4 className="font-medium text-sm text-gray-600 mb-2">Key Insights:</h4>
                    <div className="text-sm bg-gray-50 p-3 rounded space-y-2">
                      <p><strong>Summary:</strong> {results.claude.result.richContext.summary}</p>
                      {results.claude.result.richContext.keyInsights && results.claude.result.richContext.keyInsights.length > 0 && (
                        <div>
                          <strong>Insights:</strong>
                          <ul className="mt-1 space-y-1">
                            {results.claude.result.richContext.keyInsights.map((insight: string, index: number) => (
                              <li key={index} className="ml-4">• {insight}</li>
                            ))}
                          </ul>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <div className="text-red-600 text-sm">
                Error: {results.claude.error || "Analysis failed"}
              </div>
            )}
          </Card>
        </div>
      )}
    </div>
  );
}```

### client/src/components/ai-processing-indicator.tsx
```typescript
interface AIProcessingIndicatorProps {
  isProcessing: boolean;
  size?: 'sm' | 'md';
  position?: 'inline' | 'fixed';
}

export default function AIProcessingIndicator({ isProcessing, size = 'sm', position = 'inline' }: AIProcessingIndicatorProps) {
  if (!isProcessing) return null;

  if (position === 'fixed') {
    return (
      <div className="fixed bottom-4 right-4 z-50">
        <div className="w-3 h-3 bg-blue-500 rounded-full animate-bounce opacity-60"></div>
      </div>
    );
  }

  const dotSize = size === 'sm' ? 'w-1 h-1' : 'w-1.5 h-1.5';
  const spacing = size === 'sm' ? 'space-x-0.5' : 'space-x-1';

  return (
    <div className={`flex items-center ${spacing}`}>
      <div className={`${dotSize} bg-blue-500 rounded-full animate-bounce`} style={{ animationDelay: '0ms' }}></div>
      <div className={`${dotSize} bg-blue-500 rounded-full animate-bounce`} style={{ animationDelay: '150ms' }}></div>
      <div className={`${dotSize} bg-blue-500 rounded-full animate-bounce`} style={{ animationDelay: '300ms' }}></div>
    </div>
  );
}```

### client/src/components/bottom-navigation.tsx
```typescript
import { CheckSquare, FileText, User } from "lucide-react";
import { useOfflineStore } from "@/store/offline-store";
import { useLocation } from "wouter";

interface BottomNavigationProps {
  // No longer need activeTab prop since we'll use location-based routing
}

export default function BottomNavigation({}: BottomNavigationProps) {
  const { pendingChanges } = useOfflineStore();
  const [location, navigate] = useLocation();
  const syncCount = pendingChanges.length;

  const isActive = (path: string) => location === path;

  return (
    <nav className="fixed bottom-0 left-0 right-0 w-full border-t border-[hsl(var(--border))] safe-area-bottom z-[50]" style={{ backgroundColor: '#f1efe8' }}>
      <div className="flex justify-around py-1.5">
        <button 
          onClick={() => navigate("/remind")}
          className={`tab-button ${isActive("/remind") ? "active" : ""}`}
        >
          <CheckSquare className="w-4 h-4" />
          <span className="text-xs">Remind</span>
        </button>

        <button 
          onClick={() => navigate("/")}
          className={`tab-button ${isActive("/") ? "active" : ""}`}
        >
          <FileText className="w-4 h-4" />
          <span className="text-xs">Notes</span>
        </button>

        <button 
          onClick={() => navigate("/profile")}
          className={`tab-button ${isActive("/profile") ? "active" : ""} relative`}
        >
          <User className="w-4 h-4" />
          <span className="text-xs">Profile</span>
          {syncCount > 0 && (
            <div className="absolute -top-1 -right-1 w-5 h-5 bg-red-500 text-white text-xs rounded-full flex items-center justify-center font-bold">
              {syncCount > 9 ? '9+' : syncCount}
            </div>
          )}
        </button>
      </div>
    </nav>
  );
}```

### client/src/components/capture-area.tsx
```typescript
import { useState } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { Camera, Mic, Type, Upload, File, Plus, X } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";

interface CaptureAreaProps {
  onVoiceCapture: () => void;
}

export default function CaptureArea({ onVoiceCapture }: CaptureAreaProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [text, setText] = useState("");
  const [isTextDialogOpen, setIsTextDialogOpen] = useState(false);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const createNoteMutation = useMutation({
    mutationFn: async (content: string) => {
      const response = await apiRequest("POST", "/api/notes", {
        content,
        mode: "text",
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      setText("");
      setIsTextDialogOpen(false);
      setIsExpanded(false);
      toast({
        title: "Note captured",
        description: "Your note has been saved and is being enhanced by AI.",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to create note. Please try again.",
        variant: "destructive",
      });
    },
  });

  const handleSubmit = () => {
    const content = text.trim();
    if (content) {
      createNoteMutation.mutate(content);
    }
  };

  const handleImageCapture = () => {
    toast({
      title: "Coming soon",
      description: "Image capture will be available in a future update.",
    });
  };

  const quickActions = [
    {
      icon: Type,
      label: "Text",
      color: "soft-sky-blue",
      action: () => setIsTextDialogOpen(true)
    },
    {
      icon: Mic,
      label: "Voice",
      color: "seafoam-green", 
      action: onVoiceCapture
    },
    {
      icon: Camera,
      label: "Photo",
      color: "dusty-teal",
      action: () => toast({ title: "Coming soon", description: "Photo capture will be available soon." })
    },
    {
      icon: Upload,
      label: "Upload",
      color: "pale-sage",
      action: () => toast({ title: "Coming soon", description: "File upload will be available soon." })
    },
    {
      icon: File,
      label: "File",
      color: "sand-taupe",
      action: () => toast({ title: "Coming soon", description: "File attachment will be available soon." })
    }
  ];

  return (
    <>
      {/* Floating iOS-style Capture Button */}
      <div className="fixed bottom-8 right-6 z-50">
        <div className={`transition-all duration-300 ${isExpanded ? 'mb-4' : ''}`}>
          {isExpanded && (
            <div className="flex flex-col space-y-3 mb-4 animate-slideUp">
              {quickActions.map((action, index) => (
                <button
                  key={index}
                  onClick={action.action}
                  className={`w-12 h-12 rounded-full bg-[hsl(var(--${action.color}))] text-[hsl(var(--foreground))] shadow-lg active:scale-95 transition-transform flex items-center justify-center`}
                  title={action.label}
                >
                  <action.icon className="w-5 h-5" />
                </button>
              ))}
            </div>
          )}
        </div>
        
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className={`w-14 h-14 rounded-full bg-[hsl(var(--soft-sky-blue))] text-[hsl(var(--foreground))] shadow-lg active:scale-95 transition-all flex items-center justify-center ${isExpanded ? 'rotate-45' : ''}`}
        >
          {isExpanded ? <X className="w-6 h-6" /> : <Plus className="w-6 h-6" />}
        </button>
      </div>

      {/* Text Input Dialog */}
      <Dialog open={isTextDialogOpen} onOpenChange={setIsTextDialogOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>New Note</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <Textarea
              value={text}
              onChange={(e) => setText(e.target.value)}
              placeholder="What's on your mind?"
              className="min-h-[120px] resize-none border-[hsl(var(--border))] focus:ring-[hsl(var(--soft-sky-blue))]"
              autoFocus
            />
            <div className="flex justify-end space-x-2">
              <Button 
                variant="outline" 
                onClick={() => setIsTextDialogOpen(false)}
              >
                Cancel
              </Button>
              <Button
                onClick={handleSubmit}
                disabled={!text.trim() || createNoteMutation.isPending}
                className="bg-[hsl(var(--soft-sky-blue))] hover:bg-[hsl(var(--dusty-teal))] text-[hsl(var(--foreground))]"
              >
                {createNoteMutation.isPending ? "Saving..." : "Capture"}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}
```

### client/src/components/collections-view.tsx
```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { Coffee, Lightbulb, Book, Folder, ChevronRight, Heart, Star, Briefcase, Home, Car, Plane, CheckSquare, Calendar, MapPin, ShoppingBag, Search, Mic, Filter, Plus, Users, Play, Utensils } from "lucide-react";
import { getCollectionColor } from "@/lib/collection-colors";
import { useLocation } from "wouter";
import { apiRequest } from "@/lib/queryClient";

interface CollectionWithCount {
  id: number;
  name: string;
  icon: string;
  color: string;
  iconUrl?: string;
  noteCount: number;
  openTodoCount: number;
  createdAt: string;
}

const getIconComponent = (iconName: string) => {
  switch (iconName) {
    case "coffee":
      return Coffee;
    case "lightbulb":
      return Lightbulb;
    case "book":
      return Book;
    case "heart":
      return Heart;
    case "star":
      return Star;
    case "briefcase":
      return Briefcase;
    case "home":
      return Home;
    case "car":
      return Car;
    case "plane":
      return Plane;
    case "checklist":
      return CheckSquare;
    case "calendar":
      return Calendar;
    case "location":
      return MapPin;
    case "shopping":
      return ShoppingBag;
    case "users":
      return Users;
    case "play":
      return Play;
    case "utensils":
      return Utensils;
    default:
      return Folder;
  }
};



export default function CollectionsView({ embedded = false }: { embedded?: boolean } = {}) {
  const [searchTerm, setSearchTerm] = useState("");
  const [sortBy, setSortBy] = useState<"name" | "recent" | "count">("recent");
  const [draggedCollection, setDraggedCollection] = useState<number | null>(null);
  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);
  const [, setLocation] = useLocation();
  const queryClient = useQueryClient();

  const { data: collections, isLoading } = useQuery<CollectionWithCount[]>({
    queryKey: ["/api/collections"],
  });

  const reorderMutation = useMutation({
    mutationFn: async (reorderedCollections: CollectionWithCount[]) => {
      // Update display order for each collection
      const updates = reorderedCollections.map((collection, index) => ({
        id: collection.id,
        displayOrder: index
      }));

      return apiRequest("POST", "/api/collections/reorder", { updates });
    },
    onMutate: async (reorderedCollections) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ["/api/collections"] });

      // Snapshot previous value
      const previousCollections = queryClient.getQueryData(["/api/collections"]);

      // Optimistically update to new value
      queryClient.setQueryData(["/api/collections"], reorderedCollections);

      return { previousCollections };
    },
    onError: (err, newCollections, context) => {
      // Rollback on error
      queryClient.setQueryData(["/api/collections"], context?.previousCollections);
    },
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: ["/api/collections"] });
    },
  });

  const filteredAndSortedCollections = collections?.filter(collection =>
    collection.name.toLowerCase().includes(searchTerm.toLowerCase())
  ) || [];

  if (isLoading) {
    return (
      <div className="space-y-4 px-4">
        <div className="flex items-center justify-between mb-4 pt-6">
          <h2 className="text-2xl font-serif font-medium">Collections</h2>
        </div>
        <div className="space-y-4">
          {[1, 2, 3].map((i) => (
            <div key={i} className="note-card animate-pulse">
              <div className="flex items-center space-x-3">
                <div className="w-10 h-10 bg-gray-200 rounded-xl"></div>
                <div className="flex-1">
                  <div className="h-4 bg-gray-200 rounded w-3/4 mb-1"></div>
                  <div className="h-3 bg-gray-200 rounded w-1/2"></div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (!collections || collections.length === 0) {
    return (
      <div className="space-y-4 px-4">
        <div className="flex items-center justify-between mb-4 pt-6">
          <h2 className="text-2xl font-serif font-medium">Collections</h2>
          <div className="flex items-center gap-2">
            <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors">
              <Search size={18} />
            </button>
            <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors">
              <Plus size={18} />
            </button>
          </div>
        </div>
        <div className="text-center py-8">
          <p className="text-[hsl(var(--muted-foreground))]">No collections yet. AI will create them automatically as you add notes!</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {!embedded && (
        <div className="flex items-center justify-between px-4 pt-6">
          <div className="flex items-center gap-2">
            <h2 className="text-2xl font-serif font-medium text-gray-900 dark:text-gray-100">
              Collections
            </h2>
          </div>
          <div className="flex items-center gap-2">
            <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors">
              <Search size={18} />
            </button>
            <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors">
              <Filter size={18} />
            </button>
          </div>
        </div>
      )}

      <div className={`${embedded ? 'px-0' : 'px-4'} space-y-4`}>
        <div className="grid grid-cols-3 gap-2">
          {filteredAndSortedCollections.map((collection, index) => {
            const IconComponent = getIconComponent(collection.icon);
            const colors = getCollectionColor(collection.color);

            return (
              <div 
                key={collection.id} 
                draggable
                onDragStart={(e) => {
                  setDraggedCollection(collection.id);
                  e.dataTransfer.effectAllowed = 'move';
                }}
                onDragEnd={() => {
                  setDraggedCollection(null);
                  setDragOverIndex(null);
                }}
                onDragOver={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  setDragOverIndex(index);
                }}
                onDragLeave={(e) => {
                  e.stopPropagation();
                  if (!e.currentTarget.contains(e.relatedTarget as Node)) {
                    setDragOverIndex(null);
                  }
                }}
                onDrop={(e) => {
                  e.preventDefault();
                  if (draggedCollection && draggedCollection !== collection.id) {
                    const draggedIndex = filteredAndSortedCollections.findIndex(c => c.id === draggedCollection);
                    const targetIndex = index;

                    if (draggedIndex !== -1 && targetIndex !== -1) {
                      const reorderedCollections = [...filteredAndSortedCollections];
                      const [draggedItem] = reorderedCollections.splice(draggedIndex, 1);
                      reorderedCollections.splice(targetIndex, 0, draggedItem);

                      reorderMutation.mutate(reorderedCollections);
                    }
                  }
                  setDraggedCollection(null);
                  setDragOverIndex(null);
                }}
                onClick={() => setLocation(`/collection/${collection.id}`)}
                className={`bg-[hsl(var(--card))] border transition-all cursor-pointer touch-manipulation h-32 ${
                  draggedCollection === collection.id ? 'opacity-50 scale-95' : ''
                } ${
                  dragOverIndex === index && draggedCollection !== collection.id 
                    ? 'border-blue-400 border-2 bg-blue-50 dark:bg-blue-950 scale-105 shadow-lg' 
                    : 'border-[hsl(var(--border))]'
                } rounded-lg p-3 hover:shadow-sm`}
              >
                <div className="flex flex-col items-center text-center space-y-1">
                  <div className="w-8 h-8 flex items-center justify-center">
                    {collection.iconUrl ? (
                      <img 
                        src={collection.iconUrl} 
                        alt={collection.name}
                        className="w-6 h-6 rounded object-cover"
                        onError={(e) => {
                          // Fallback to icon if image fails to load
                          e.currentTarget.style.display = 'none';
                          e.currentTarget.nextElementSibling?.classList.remove('hidden');
                        }}
                      />
                    ) : (
                      <IconComponent className={`w-6 h-6 ${colors.text}`} />
                    )}
                  </div>
                  <div className="space-y-1 flex-1 flex flex-col justify-end">
                    <h3 className="font-bold text-sm leading-tight line-clamp-2 min-h-[2.5rem] flex items-center justify-center text-center">{collection.name}</h3>
                    <div className="space-y-0 min-h-[2rem] flex flex-col justify-center">
                      <p className="text-[10px] text-[hsl(var(--muted-foreground))] leading-tight">
                        {collection.noteCount} {collection.noteCount === 1 ? 'note' : 'notes'}
                      </p>
                      {collection.openTodoCount > 0 && (
                        <p className="text-[10px] text-orange-600 font-medium leading-tight">
                          {collection.openTodoCount} to-do{collection.openTodoCount === 1 ? '' : 's'}
                        </p>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}```

### client/src/components/CriticalInfoDialog.tsx
```typescript
import React, { useState } from 'react';
import { AlertTriangle, X } from 'lucide-react';

interface CriticalInfoDialogProps {
  question: string;
  onDismiss: () => void;
  onAnswer: (answer: string) => void;
}

export const CriticalInfoDialog: React.FC<CriticalInfoDialogProps> = ({
  question,
  onDismiss,
  onAnswer
}) => {
  const [answer, setAnswer] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (answer.trim()) {
      onAnswer(answer.trim());
      setAnswer('');
    }
  };

  return (
    <div className="fixed bottom-20 left-4 right-4 z-50 pointer-events-auto">
      <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3 shadow-lg max-w-md mx-auto">
        <div className="flex items-start gap-2">
          <AlertTriangle className="w-4 h-4 text-yellow-600 mt-0.5 flex-shrink-0" />
          <div className="flex-1">
            <p className="text-sm text-yellow-800 mb-2">{question}</p>
            <form onSubmit={handleSubmit}>
              <input 
                className="w-full px-2 py-1 border border-yellow-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-yellow-500"
                placeholder="Quick answer..."
                value={answer}
                onChange={(e) => setAnswer(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleSubmit(e as any)}
                autoFocus
              />
            </form>
          </div>
          <button 
            onClick={onDismiss} 
            className="text-yellow-600 hover:text-yellow-800 flex-shrink-0"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
        {/* Arrow pointing to input bar */}
        <div className="absolute -bottom-2 left-6 w-4 h-4 bg-yellow-50 border-r border-b border-yellow-200 transform rotate-45"></div>
      </div>
    </div>
  );
};```

### client/src/components/dev-cache-debugger.tsx
```typescript
import { useState, useEffect } from "react";
import { RefreshCw, Database, Trash2, Info } from "lucide-react";
import { offlineStorage, serviceWorkerManager, devCacheUtils } from "@/store/offline-storage";

interface CacheStats {
  offlineStorage: {
    total: number;
    byType: Record<string, number>;
    oldestEntry: number;
  };
  serviceWorker: {
    caches: string[];
    isDevelopment: boolean;
    version: string;
  };
  browserCaches: string[];
}

interface DevCacheDebuggerProps {
  isOpen?: boolean;
  onClose?: () => void;
}

export default function DevCacheDebugger({ isOpen = true, onClose }: DevCacheDebuggerProps) {
  const [cacheStats, setCacheStats] = useState<CacheStats | null>(null);
  const [isClearing, setIsClearing] = useState(false);

  // Only show in development
  if (!import.meta.env.DEV) return null;

  useEffect(() => {
    if (isOpen) {
      loadCacheStats();
    }
  }, [isOpen]);

  const loadCacheStats = async () => {
    try {
      const stats = await devCacheUtils.getCacheInfo();
      setCacheStats(stats);
    } catch (error) {
      console.error('Failed to load cache stats:', error);
    }
  };

  const handleClearAllCaches = async () => {
    setIsClearing(true);
    try {
      await devCacheUtils.forceRefresh();
    } catch (error) {
      console.error('Failed to clear caches:', error);
      setIsClearing(false);
    }
  };

  const formatBytes = (bytes: number) => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const formatTime = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString();
  };

  if (!isOpen) return null;

  return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-[70] flex items-center justify-center p-4">
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto">
            <div className="p-6">
              <div className="flex items-center justify-between mb-6">
                <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
                  Development Cache Debugger
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                >
                  ×
                </button>
              </div>

              {/* Actions */}
              <div className="flex gap-3 mb-6">
                <button
                  onClick={loadCacheStats}
                  className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                >
                  <RefreshCw className="w-4 h-4" />
                  Refresh Stats
                </button>
                <button
                  onClick={handleClearAllCaches}
                  disabled={isClearing}
                  className="flex items-center gap-2 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors disabled:opacity-50"
                >
                  <Trash2 className="w-4 h-4" />
                  {isClearing ? 'Clearing...' : 'Clear All & Reload'}
                </button>
              </div>

              {/* Cache Statistics */}
              {cacheStats && (
                <div className="space-y-6">
                  {/* Offline Storage Stats */}
                  <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                    <h3 className="font-semibold text-gray-900 dark:text-white mb-3 flex items-center gap-2">
                      <Database className="w-4 h-4" />
                      Offline Storage (IndexedDB)
                    </h3>
                    <div className="grid grid-cols-2 gap-4 text-sm">
                      <div>
                        <span className="text-gray-600 dark:text-gray-300">Total Entries:</span>
                        <span className="ml-2 font-mono">{cacheStats.offlineStorage.total}</span>
                      </div>
                      <div>
                        <span className="text-gray-600 dark:text-gray-300">Oldest Entry:</span>
                        <span className="ml-2 font-mono">
                          {formatTime(cacheStats.offlineStorage.oldestEntry)}
                        </span>
                      </div>
                      <div className="col-span-2">
                        <span className="text-gray-600 dark:text-gray-300">By Type:</span>
                        <div className="ml-4 mt-1">
                          {Object.entries(cacheStats.offlineStorage.byType).map(([type, count]) => (
                            <div key={type} className="flex justify-between">
                              <span className="capitalize">{type}:</span>
                              <span className="font-mono">{count}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Service Worker Stats */}
                  <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                    <h3 className="font-semibold text-gray-900 dark:text-white mb-3">
                      Service Worker Caches
                    </h3>
                    <div className="text-sm space-y-2">
                      <div className="flex justify-between">
                        <span className="text-gray-600 dark:text-gray-300">Mode:</span>
                        <span className={`font-mono ${cacheStats.serviceWorker.isDevelopment ? 'text-yellow-600' : 'text-green-600'}`}>
                          {cacheStats.serviceWorker.isDevelopment ? 'Development' : 'Production'}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-600 dark:text-gray-300">Version:</span>
                        <span className="font-mono">{cacheStats.serviceWorker.version}</span>
                      </div>
                      <div>
                        <span className="text-gray-600 dark:text-gray-300">Active Caches:</span>
                        <div className="ml-4 mt-1 max-h-20 overflow-y-auto">
                          {cacheStats.serviceWorker.caches.map((cache, index) => (
                            <div key={index} className="font-mono text-xs text-gray-500 dark:text-gray-400">
                              {cache}
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Browser Caches */}
                  <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                    <h3 className="font-semibold text-gray-900 dark:text-white mb-3">
                      Browser Cache API
                    </h3>
                    <div className="text-sm">
                      <div className="flex justify-between mb-2">
                        <span className="text-gray-600 dark:text-gray-300">Cache Names:</span>
                        <span className="font-mono">{cacheStats.browserCaches.length}</span>
                      </div>
                      {cacheStats.browserCaches.length > 0 && (
                        <div className="ml-4 max-h-20 overflow-y-auto">
                          {cacheStats.browserCaches.map((cache, index) => (
                            <div key={index} className="font-mono text-xs text-gray-500 dark:text-gray-400">
                              {cache}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Development Tips */}
                  <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
                    <h3 className="font-semibold text-blue-900 dark:text-blue-200 mb-2 flex items-center gap-2">
                      <Info className="w-4 h-4" />
                      Development Tips
                    </h3>
                    <ul className="text-sm text-blue-800 dark:text-blue-300 space-y-1">
                      <li>• Caches are automatically shortened in development mode</li>
                      <li>• API cache: 2min max, Static cache: 5min max</li>
                      <li>• Service Worker uses timestamped versions for cache busting</li>
                      <li>• Clear All & Reload forces a complete refresh of all caches</li>
                    </ul>
                  </div>
                </div>
              )}

              {!cacheStats && (
                <div className="text-center py-8 text-gray-500 dark:text-gray-400">
                  Click "Refresh Stats" to load cache information
                </div>
              )}
            </div>
          </div>
        </div>
  );
}```

### client/src/components/error-boundary.tsx
```typescript
import { Component, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error boundary caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen bg-white dark:bg-black flex items-center justify-center p-4">
          <div className="text-center max-w-md">
            <AlertTriangle className="w-12 h-12 text-red-500 mx-auto mb-4" />
            <h1 className="text-xl font-semibold text-gray-900 dark:text-white mb-2">
              Something went wrong
            </h1>
            <p className="text-gray-600 dark:text-gray-400 mb-6">
              We encountered an unexpected error. Please try refreshing the page.
            </p>
            <button
              onClick={() => window.location.reload()}
              className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors min-h-[44px]"
            >
              <RefreshCw className="w-4 h-4" />
              Refresh Page
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}```

### client/src/components/feature-error-boundary.tsx
```typescript
import React, { Component, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface FeatureErrorBoundaryProps {
  children: ReactNode;
  featureName: string;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: any) => void;
}

interface FeatureErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: any;
  retryCount: number;
}

export class FeatureErrorBoundary extends Component<FeatureErrorBoundaryProps, FeatureErrorBoundaryState> {
  private maxRetries = 3;

  constructor(props: FeatureErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      retryCount: 0
    };
  }

  static getDerivedStateFromError(error: Error): Partial<FeatureErrorBoundaryState> {
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error(`FeatureErrorBoundary [${this.props.featureName}]:`, error, errorInfo);
    
    this.setState({
      errorInfo
    });

    // Call custom error handler if provided
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }

    // In development, provide detailed error information
    if (process.env.NODE_ENV === 'development') {
      console.group(`🚨 Feature Error: ${this.props.featureName}`);
      console.error('Error:', error);
      console.error('Component Stack:', errorInfo.componentStack);
      console.error('Error Boundary Stack:', error.stack);
      console.groupEnd();
    }
  }

  handleRetry = () => {
    if (this.state.retryCount < this.maxRetries) {
      this.setState({
        hasError: false,
        error: undefined,
        errorInfo: undefined,
        retryCount: this.state.retryCount + 1
      });
    }
  };

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default error UI
      return (
        <div className="flex flex-col items-center justify-center p-6 bg-red-50 dark:bg-red-950/20 border border-red-200 dark:border-red-800 rounded-lg m-4">
          <AlertTriangle className="w-8 h-8 text-red-500 dark:text-red-400 mb-3" />
          
          <h3 className="text-lg font-semibold text-red-800 dark:text-red-200 mb-2">
            {this.props.featureName} Unavailable
          </h3>
          
          <p className="text-sm text-red-600 dark:text-red-300 text-center mb-4 max-w-md">
            This feature is temporarily unavailable. The app will continue working normally.
          </p>

          {this.state.retryCount < this.maxRetries && (
            <button
              onClick={this.handleRetry}
              className="flex items-center gap-2 px-4 py-2 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded-md hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors"
            >
              <RefreshCw className="w-4 h-4" />
              Try Again ({this.maxRetries - this.state.retryCount} attempts left)
            </button>
          )}

          {process.env.NODE_ENV === 'development' && this.state.error && (
            <details className="mt-4 w-full">
              <summary className="cursor-pointer text-sm text-red-600 dark:text-red-400 hover:text-red-800 dark:hover:text-red-200">
                Show Error Details (Development)
              </summary>
              <div className="mt-2 p-3 bg-red-100 dark:bg-red-900/20 rounded border text-xs text-red-800 dark:text-red-200 overflow-auto">
                <div className="font-mono mb-2">
                  <strong>Error:</strong> {this.state.error.message}
                </div>
                <div className="font-mono mb-2">
                  <strong>Stack:</strong>
                  <pre className="whitespace-pre-wrap mt-1">{this.state.error.stack}</pre>
                </div>
                {this.state.errorInfo && (
                  <div className="font-mono">
                    <strong>Component Stack:</strong>
                    <pre className="whitespace-pre-wrap mt-1">{this.state.errorInfo.componentStack}</pre>
                  </div>
                )}
              </div>
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

// Higher-order component for wrapping features with error boundaries
export function withFeatureErrorBoundary<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  featureName: string,
  fallback?: ReactNode
) {
  const WithErrorBoundary = (props: P) => (
    <FeatureErrorBoundary featureName={featureName} fallback={fallback}>
      <WrappedComponent {...props} />
    </FeatureErrorBoundary>
  );

  WithErrorBoundary.displayName = `withFeatureErrorBoundary(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;

  return WithErrorBoundary;
}```

### client/src/components/full-screen-capture-backup.tsx
```typescript
import { useState, useRef, useEffect } from "react";
import { X, Camera, Mic, Type, Upload, FileText } from "lucide-react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";

interface FullScreenCaptureProps {
  isOpen: boolean;
  onClose: () => void;
}

type CaptureMode = 'text' | 'camera' | 'voice' | 'upload-image' | 'upload-file';

export default function FullScreenCapture({ isOpen, onClose }: FullScreenCaptureProps) {
  const [captureMode, setCaptureMode] = useState<CaptureMode>('text');
  const [noteText, setNoteText] = useState('');
  const [stream, setStream] = useState<MediaStream | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  useEffect(() => {
    if (isOpen) {
      startCamera();
      setTimeout(() => {
        if (textareaRef.current) {
          textareaRef.current.focus();
        }
      }, 300);
    } else {
      stopCamera();
    }

    return () => {
      stopCamera();
    };
  }, [isOpen]);

  const startCamera = async () => {
    try {
      const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
      setStream(mediaStream);
      if (videoRef.current) {
        videoRef.current.srcObject = mediaStream;
      }
    } catch (error) {
      console.error('Error accessing camera:', error);
    }
  };

  const stopCamera = () => {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
      setStream(null);
    }
  };

  const createNoteMutation = useMutation({
    mutationFn: async (noteData: { content: string; mode: string }) => {
      const response = await apiRequest("POST", "/api/notes", noteData);
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      setNoteText('');
      onClose();
      toast({
        description: "Note created successfully!",
      });
    },
  });

  const handleSave = () => {
    if (noteText.trim()) {
      createNoteMutation.mutate({
        content: noteText.trim(),
        mode: 'text'
      });
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black">
      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted
        className="absolute inset-0 w-full h-full object-cover"
      />

      <div className="absolute inset-0 bg-black/30" />

      <button
        onClick={onClose}
        className="absolute top-6 right-6 z-60 w-10 h-10 rounded-full bg-black/50 text-white flex items-center justify-center"
      >
        <X className="w-6 h-6" />
      </button>

      <div className="absolute inset-0 flex flex-col">
        <div className="flex-1 flex flex-col justify-end pb-4">
          
          {/* Text input area - always visible above camera controls */}
          <div className="mx-4 mb-4">
            <div className="bg-white/90 backdrop-blur-sm rounded-2xl p-4 shadow-2xl max-w-md mx-auto">
              <textarea
                ref={textareaRef}
                value={noteText}
                onChange={(e) => setNoteText(e.target.value)}
                placeholder="Add new note"
                className="w-full h-16 resize-none border-none outline-none bg-transparent text-lg placeholder-gray-500"
                inputMode="text"
                enterKeyHint="done"
              />
              {noteText.length > 0 && (
                <div className="flex justify-between items-center mt-3">
                  <span className="text-sm text-gray-500">
                    {noteText.length} characters
                  </span>
                  <button
                    onClick={handleSave}
                    disabled={createNoteMutation.isPending}
                    className="px-6 py-2 bg-blue-500 text-white rounded-full font-medium disabled:opacity-50"
                  >
                    {createNoteMutation.isPending ? 'Saving...' : 'Save Note'}
                  </button>
                </div>
              )}
            </div>
          </div>

          {/* Camera capture button */}
          <div className="flex justify-center mb-8">
            <button
              className="w-20 h-20 rounded-full bg-white/20 border-4 border-white flex items-center justify-center backdrop-blur-sm"
            >
              <div className="w-16 h-16 rounded-full bg-white"></div>
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}```

### client/src/components/full-screen-capture.tsx
```typescript
import { useState, useRef, useEffect } from 'react';
import { Camera, Mic, X, Send, ArrowLeft, Settings } from 'lucide-react';
import { useNotes } from '@/hooks/use-notes';
import { useToast } from '@/hooks/use-toast';
import { usePermissions } from '@/hooks/use-permissions';
import IOSVoiceRecorder from '@/components/ios-voice-recorder';
import MediaContextDialog from '@/components/media-context-dialog';

interface FullScreenCaptureProps {
  isOpen: boolean;
  onClose: () => void;
}

type CaptureMode = 'text' | 'camera' | 'voice';

export default function FullScreenCapture({ isOpen, onClose }: FullScreenCaptureProps) {
  const [captureMode, setCaptureMode] = useState<CaptureMode>('camera');
  const [noteText, setNoteText] = useState('');
  const [noteTitle, setNoteTitle] = useState('');
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [audioLevels, setAudioLevels] = useState<number[]>([]);
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const [isVoiceRecorderOpen, setIsVoiceRecorderOpen] = useState(false);
  const [showMediaDialog, setShowMediaDialog] = useState(false);
  const [capturedImageData, setCapturedImageData] = useState<string>("");
  const [cameraFacing, setCameraFacing] = useState<'environment' | 'user'>('environment');

  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const titleRef = useRef<HTMLInputElement>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const recordingTimerRef = useRef<NodeJS.Timeout | null>(null);

  const { createNote, createVoiceNote } = useNotes();
  const { toast } = useToast();

  // Keyboard height detection
  useEffect(() => {
    const handleResize = () => {
      const viewportHeight = window.visualViewport?.height || window.innerHeight;
      const windowHeight = window.innerHeight;
      const diff = windowHeight - viewportHeight;
      setKeyboardHeight(diff > 100 ? diff : 0);
    };

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', handleResize);
      return () => window.visualViewport?.removeEventListener('resize', handleResize);
    }
  }, []);

  // Camera setup
  useEffect(() => {
    if (captureMode === 'camera' && isOpen) {
      startCamera();
    } else {
      stopCamera();
    }
    return () => stopCamera();
  }, [captureMode, isOpen, cameraFacing]);

  const { hasCamera, requestCameraPermission, needsCameraPermission, permissions } = usePermissions();

  const startCamera = async () => {
    try {
      console.log("Starting camera...");

      // Use centralized permission management
      if (!hasCamera) {
        console.log("Requesting camera permission...");
        const granted = await requestCameraPermission();
        if (!granted) {
          const isDenied = permissions.camera === 'denied';
          toast({
            title: isDenied ? "Camera Access Denied" : "Camera Permission Required",
            description: isDenied 
              ? "Please enable camera access in your browser settings to use this feature."
              : "Camera access is needed to take photos. Please allow access and try again.",
            variant: "destructive",
          });
          return;
        }
      }

      // Start with basic constraints and progressively enhance
      let constraints: MediaStreamConstraints = { 
        video: { facingMode: cameraFacing },
        audio: false 
      };

      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
      } catch (specificCameraError) {
        console.log(`${cameraFacing} camera failed, trying opposite camera:`, specificCameraError);
        
        // Try the opposite camera
        try {
          constraints = { 
            video: { facingMode: cameraFacing === 'environment' ? 'user' : 'environment' },
            audio: false 
          };
          stream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (secondError) {
          console.log(`Both specific cameras failed, trying any camera:`, secondError);
          
          // Final fallback to any available camera
          constraints = { 
            video: true,
            audio: false 
          };
          stream = await navigator.mediaDevices.getUserMedia(constraints);
        }
      }
      console.log("Camera stream obtained:", stream);

      if (videoRef.current && stream) {
        videoRef.current.srcObject = stream;

        // Set video attributes
        videoRef.current.muted = true;
        videoRef.current.playsInline = true;
        videoRef.current.autoplay = true;

        // Wait for metadata and play
        videoRef.current.onloadedmetadata = async () => {
          console.log('Video metadata loaded, dimensions:', videoRef.current?.videoWidth, 'x', videoRef.current?.videoHeight);
          try {
            await videoRef.current?.play();
            console.log('Video playing successfully');
          } catch (playError) {
            console.error('Video play error:', playError);
            // Force play on user interaction
            videoRef.current?.addEventListener('click', () => {
              videoRef.current?.play();
            }, { once: true });
          }
        };

        videoRef.current.onerror = (e) => {
          console.error('Video element error:', e);
        };
      }
    } catch (error: any) {
      console.error('Camera access error details:', {
        name: error?.name,
        message: error?.message,
        constraint: error?.constraint,
        stack: error?.stack
      });
      
      let errorMessage = "Could not access camera. ";
      
      if (error?.name === 'NotAllowedError') {
        errorMessage = "Camera permission was denied. Please enable camera access in your browser settings.";
      } else if (error?.name === 'NotFoundError') {
        errorMessage = "No camera found on this device.";
      } else if (error?.name === 'NotReadableError') {
        errorMessage = "Camera is already in use by another application.";
      } else if (error?.name === 'OverconstrainedError') {
        errorMessage = `Camera settings not supported: ${error?.constraint || 'unknown constraint'}`;
      } else {
        errorMessage += `${error?.message || error?.name || 'Unknown error'}`;
      }
      
      toast({
        title: "Camera Error",
        description: errorMessage,
        variant: "destructive",
      });
    }
  };

  const stopCamera = () => {
    if (videoRef.current?.srcObject) {
      const tracks = (videoRef.current.srcObject as MediaStream).getTracks();
      tracks.forEach(track => track.stop());
      videoRef.current.srcObject = null;
    }
  };

  const capturePhoto = () => {
    if (!videoRef.current || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const video = videoRef.current;
    const context = canvas.getContext('2d');

    if (!context) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    context.drawImage(video, 0, 0);

    canvas.toBlob((blob) => {
      if (blob) {
        const reader = new FileReader();
        reader.onload = (e) => {
          const capturedDataUrl = e.target?.result as string;
          if (capturedDataUrl) {
            setCapturedImageData(capturedDataUrl);
            setShowMediaDialog(true);
          }
        };
        reader.readAsDataURL(blob);
      }
    }, 'image/jpeg', 0.8);
  };

  const flipCamera = () => {
    setCameraFacing(prev => prev === 'environment' ? 'user' : 'environment');
  };

  const handleSendNote = () => {
    if (!noteText.trim() && !noteTitle.trim()) return;

    const content = noteTitle.trim() 
      ? `${noteTitle.trim()}\n\n${noteText.trim()}`
      : noteText.trim();

    createNote({
      content,
      mode: 'smart'
    });

    setNoteText('');
    setNoteTitle('');
    onClose();
    toast({
      title: "Note saved",
      description: "Your note has been added successfully.",
    });
  };

  // Audio visualization effect
  useEffect(() => {
    let animationFrame: number;

    if (isRecording && analyserRef.current) {
      const updateWaveform = () => {
        const analyser = analyserRef.current!;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyser.getByteFrequencyData(dataArray);

        // Convert to visual levels (32 bars)
        const barCount = 32;
        const levels: number[] = [];
        const samplesPerBar = Math.floor(bufferLength / barCount);

        for (let i = 0; i < barCount; i++) {
          let sum = 0;
          for (let j = 0; j < samplesPerBar; j++) {
            sum += dataArray[i * samplesPerBar + j];
          }
          const average = sum / samplesPerBar;
          levels.push(Math.max(8, (average / 255) * 50)); // Scale to 8-50px height
        }

        setAudioLevels(levels);
        animationFrame = requestAnimationFrame(updateWaveform);
      };

      updateWaveform();
    }

    return () => {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
    };
  }, [isRecording]);

  // Recording timer effect
  useEffect(() => {
    if (isRecording) {
      setRecordingTime(0);
      recordingTimerRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
    } else {
      if (recordingTimerRef.current) {
        clearInterval(recordingTimerRef.current);
        recordingTimerRef.current = null;
      }
      setRecordingTime(0);
    }

    return () => {
      if (recordingTimerRef.current) {
        clearInterval(recordingTimerRef.current);
      }
    };
  }, [isRecording]);

  const handleVoiceCapture = async () => {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      toast({
        title: "Voice recording not supported",
        description: "Your browser doesn't support voice recording.",
        variant: "destructive",
      });
      return;
    }

    if (isRecording) {
      // Stop recording
      if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
        mediaRecorderRef.current.stop();
      }
      setIsRecording(false);
      return;
    }

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      // Set up audio analysis
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const analyser = audioContext.createAnalyser();
      const source = audioContext.createMediaStreamSource(stream);

      analyser.fftSize = 256;
      source.connect(analyser);

      audioContextRef.current = audioContext;
      analyserRef.current = analyser;

      // Set up recording
      const mediaRecorder = new MediaRecorder(stream);
      const chunks: Blob[] = [];

      mediaRecorderRef.current = mediaRecorder;

      mediaRecorder.ondataavailable = (event) => {
        chunks.push(event.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/wav' });
        createVoiceNote(blob);

        // Clean up
        stream.getTracks().forEach(track => track.stop());
        audioContext.close();
        setIsRecording(false);
        setAudioLevels([]);
        onClose();

        toast({
          title: "Voice note saved",
          description: "Your voice note has been transcribed and saved.",
        });
      };

      setIsRecording(true);
      mediaRecorder.start();

      // Auto-stop after 30 seconds
      setTimeout(() => {
        if (mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }
      }, 30000);

    } catch (error) {
      console.error('Voice recording error:', error);
      setIsRecording(false);
      toast({
        title: "Recording Error",
        description: "Could not access microphone. Please check permissions.",
        variant: "destructive",
      });
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-[40] bg-black">

      {/* Camera Mode */}
      {captureMode === 'camera' && (
        <div className="relative w-full h-full">
          <video
            ref={videoRef}
            autoPlay
            playsInline
            muted
            className="w-full h-full object-cover bg-gray-900"
            style={{ 
              minHeight: '100vh',
              minWidth: '100vw'
            }}
            onLoadedMetadata={() => {
              console.log('Video metadata loaded - dimensions:', videoRef.current?.videoWidth, 'x', videoRef.current?.videoHeight);
              // Ensure video starts playing
              if (videoRef.current?.paused) {
                videoRef.current.play().catch(console.error);
              }
            }}
            onCanPlay={() => {
              console.log('Video can play');
              // Auto-play when ready
              if (videoRef.current?.paused) {
                videoRef.current.play().catch(console.error);
              }
            }}
            onError={(e) => console.error('Video error:', e)}
            onPlay={() => console.log('Video started playing')}
            onPause={() => console.log('Video paused')}
          />
          <canvas ref={canvasRef} className="hidden" />

          {/* Top controls */}
          <div className="absolute top-4 right-4 z-[10001]">
            <button
              onClick={onClose}
              className="w-10 h-10 rounded-full flex items-center justify-center bg-white/30 backdrop-blur-sm text-white hover:bg-white/40 transition-colors"
            >
              <X className="w-6 h-6" />
            </button>
          </div>

          {/* Camera flip button - positioned in middle right */}
          <div className="absolute top-1/2 right-4 transform -translate-y-1/2 z-[10001]">
            <button
              onClick={flipCamera}
              className="w-12 h-12 rounded-full flex items-center justify-center bg-white/30 backdrop-blur-sm text-white hover:bg-white/40 transition-colors"
              title={`Switch to ${cameraFacing === 'environment' ? 'front' : 'rear'} camera`}
            >
              <svg 
                className="w-6 h-6" 
                fill="none" 
                stroke="currentColor" 
                viewBox="0 0 24 24"
              >
                <path 
                  strokeLinecap="round" 
                  strokeLinejoin="round" 
                  strokeWidth={2} 
                  d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" 
                />
              </svg>
            </button>
          </div>

          {/* Main capture button - positioned above input bar */}
          <button
            onClick={capturePhoto}
            className="fixed left-1/2 transform -translate-x-1/2 w-20 h-20 rounded-full border-4 border-white/50 hover:border-white/70 transition-all shadow-2xl"
            style={{ 
              zIndex: 10001,
              bottom: 'calc(3.5rem + 16px + 80px + 4px)', // Adjusted for shorter nav + input bar position + height + gap
              backgroundColor: 'transparent'
            }}
          >
          </button>

          {/* Bottom mode switcher */}
          <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 z-[10001]">
            <div className="flex gap-2">
              <button
                onClick={() => {
                  stopCamera();
                  setCaptureMode('voice');
                  setIsVoiceRecorderOpen(false);
                }}
                className="p-3 rounded-full bg-white/30 text-white hover:bg-white/40 transition-colors backdrop-blur-sm"
              >
                <Mic className="w-5 h-5" />
              </button>
              <button
                onClick={() => setCaptureMode('text')}
                className="p-3 rounded-full bg-white/30 text-white hover:bg-white/40 transition-colors backdrop-blur-sm"
              >
                <Send className="w-5 h-5" />
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Voice Mode */}
      {captureMode === 'voice' && (
        <div className="relative w-full h-full bg-[#FEFFFE] dark:bg-[#1C1C1E]">
          {/* Header */}
          <div className="flex items-center justify-between p-4 bg-[#F2F2F7] dark:bg-[#2C2C2E] border-b border-gray-200 dark:border-gray-700">
            <button
              onClick={onClose}
              className="flex items-center gap-2 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white transition-colors"
            >
              <X className="w-5 h-5" />
              <span className="text-sm font-medium">Close</span>
            </button>

            <span className="text-gray-900 dark:text-white text-lg font-medium">Voice Note</span>

            <div className="w-16"></div>
          </div>

          {/* Voice recording interface */}
          <div className="flex-1 flex flex-col items-center justify-center p-8">
            <div className="text-center mb-8">
              <h2 className="text-2xl font-semibold text-gray-900 dark:text-white mb-2">
                {isRecording ? 'Recording...' : 'Tap to record'}
              </h2>
              <p className="text-gray-600 dark:text-gray-400">
                {isRecording ? 'Tap again to stop' : 'Your voice will be transcribed automatically'}
              </p>
            </div>

            {/* Waveform visualization */}
            {isRecording && (
              <div className="mb-8 w-64 h-16 flex items-center justify-center gap-1 bg-gray-100 dark:bg-gray-800 rounded-lg p-4">
                {audioLevels.length > 0 ? (
                  audioLevels.map((level, i) => (
                    <div
                      key={i}
                      className="w-1 bg-blue-500 rounded-full transition-all duration-75"
                      style={{ height: `${level}px` }}
                    />
                  ))
                ) : (
                  Array.from({ length: 32 }).map((_, i) => (
                    <div
                      key={i}
                      className="w-1 bg-gray-400 rounded-full"
                      style={{ height: '8px' }}
                    />
                  ))
                )}
              </div>
            )}

            <button
              onClick={handleVoiceCapture}
              className={`w-24 h-24 rounded-full flex items-center justify-center transition-all ${
                isRecording 
                  ? 'bg-red-500 hover:bg-red-600 animate-pulse' 
                  : 'bg-blue-500 hover:bg-blue-600'
              }`}
            >
              <Mic className="w-10 h-10 text-white" />
            </button>

            {/* Recording timer */}
            {isRecording && (
              <div className="mt-4 text-center">
                <div className="inline-flex items-center gap-2 px-3 py-1 bg-red-100 dark:bg-red-900/30 rounded-full">
                  <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse" />
                  <span className="text-red-700 dark:text-red-300 text-sm font-medium">
                    00:{recordingTime.toString().padStart(2, '0')}
                  </span>
                </div>
              </div>
            )}

            {/* Mode switcher */}
            <div className="mt-8">
              <div className="bg-white dark:bg-gray-800 rounded-2xl p-4 shadow-lg">
                <div className="flex justify-center gap-2">
                  <button
                    onClick={() => setCaptureMode('camera')}
                    className="p-2 rounded-full bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                  >
                    <Camera className="w-4 h-4" />
                  </button>
                  <button
                    onClick={() => setCaptureMode('voice')}
                    className="p-2 rounded-full bg-blue-500 text-white"
                  >
                    <Mic className="w-4 h-4" />
                  </button>
                  <button
                    onClick={() => setCaptureMode('text')}
                    className="p-2 rounded-full bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                  >
                    <Send className="w-4 h-4" />
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Text Mode - iOS Notes Style */}
      {captureMode === 'text' && (
        <div className="relative w-full h-full bg-[#FEFFFE] dark:bg-[#1C1C1E]">
          {/* Header */}
          <div className="flex items-center justify-between p-4 bg-[#F2F2F7] dark:bg-[#2C2C2E] border-b border-gray-200 dark:border-gray-700">
            <button
              onClick={onClose}
              className="flex items-center gap-2 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white transition-colors"
            >
              <ArrowLeft className="w-5 h-5" />
              <span className="text-sm font-medium">Notes</span>
            </button>

            <button
              onClick={handleSendNote}
              disabled={!noteText.trim() && !noteTitle.trim()}
              className="px-4 py-2 bg-[#007AFF] text-white rounded-lg text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed hover:bg-[#0056CC] transition-colors"
            >
              Done
            </button>
          </div>

          {/* iOS Notes-style editor */}
          <div 
            className="flex-1 overflow-hidden"
            style={{ paddingBottom: `${keyboardHeight}px` }}
          >
            <div className="p-4 h-full">
              {/* Title */}
              <input
                ref={titleRef}
                type="text"
                value={noteTitle}
                onChange={(e) => setNoteTitle(e.target.value)}
                placeholder="Title"
                className="w-full text-2xl font-bold bg-transparent border-none outline-none text-gray-900 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 mb-2"
                style={{ fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' }}
              />

              {/* Date */}
              <div className="text-sm text-gray-500 dark:text-gray-400 mb-4">
                {new Date().toLocaleDateString('en-US', { 
                  weekday: 'long', 
                  year: 'numeric', 
                  month: 'long', 
                  day: 'numeric' 
                })}
              </div>

              {/* Content */}
              <textarea
                ref={textareaRef}
                value={noteText}
                onChange={(e) => setNoteText(e.target.value)}
                placeholder="Start writing..."
                className="w-full h-full resize-none border-none outline-none bg-transparent text-base leading-relaxed text-gray-900 dark:text-white placeholder-gray-400 dark:placeholder-gray-500"
                style={{ 
                  fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                  lineHeight: '1.6'
                }}
                autoFocus
              />
            </div>
          </div>

          {/* Bottom floating controls */}
          <div className="absolute bottom-6 left-4 right-4 z-[200]">
            <div className="bg-white dark:bg-gray-800 rounded-2xl p-4 shadow-lg">
              <div className="flex justify-center gap-2">
                <button
                  onClick={() => setCaptureMode('camera')}
                  className="p-2 rounded-full bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                >
                  <Camera className="w-4 h-4" />
                </button>
                <button
                  onClick={() => setIsVoiceRecorderOpen(true)}
                  className="p-2 rounded-full bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                >
                  <Mic className="w-4 h-4" />
                </button>
                <button
                  onClick={() => setCaptureMode('text')}
                  className="p-2 rounded-full bg-blue-500 text-white"
                >
                  <Send className="w-4 h-4" />
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* iOS Voice Recorder */}
      <IOSVoiceRecorder 
        isOpen={isVoiceRecorderOpen} 
        onClose={() => setIsVoiceRecorderOpen(false)} 
      />

      {/* Media Context Dialog */}
      <MediaContextDialog
        isOpen={showMediaDialog}
        onClose={() => setShowMediaDialog(false)}
        mediaType="camera"
        capturedImage={capturedImageData}
      />
    </div>
  );
}

// Placeholder for usePermissions hook
// Remove local usePermissions - using centralized hook```

### client/src/components/inline-voice-recorder.tsx
```typescript
import { useState, useEffect, useRef, useCallback } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Mic, Square, Send } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { usePermissions } from "@/hooks/use-permissions";

interface InlineVoiceRecorderProps {
  isRecording: boolean;
  onStartRecording: () => void;
  onStopRecording: () => void;
  className?: string;
}

export default function InlineVoiceRecorder({ 
  isRecording, 
  onStartRecording, 
  onStopRecording,
  className = ""
}: InlineVoiceRecorderProps) {
  const [recordingTime, setRecordingTime] = useState(0);
  const [waveformData, setWaveformData] = useState<number[]>([]);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const dataArrayRef = useRef<Uint8Array | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const animationRef = useRef<number | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { 
    hasMicrophone, 
    requestMicrophonePermission, 
    needsMicrophonePermission,
    permissions 
  } = usePermissions();

  const createVoiceNoteMutation = useMutation({
    mutationFn: async (audioBlob: Blob) => {
      // Check if online
      if (!navigator.onLine) {
        // Store offline voice note
        const offlineNote = {
          content: `🎤 Voice recording (${Math.round(recordingTime)}s) - Pending transcription`,
          mode: "voice",
          audioBlob: audioBlob,
          audioUrl: URL.createObjectURL(audioBlob),
          isProcessing: true,
          isOffline: true,
          recordingDuration: recordingTime,
          createdAt: new Date().toISOString()
        };
        
        // Store in offline storage
        const { useOfflineStore } = await import("@/store/offline-store");
        const note = await useOfflineStore.getState().createNote(offlineNote);
        
        return note;
      }

      // Online flow - existing logic
      const formData = new FormData();
      formData.append("audio", audioBlob, "recording.webm");
      formData.append("duration", recordingTime.toString());
      
      const response = await fetch("/api/notes/voice", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to create voice note");
      }
      
      return response.json();
    },
    onSuccess: (note) => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      handleReset();
      
      if (note.isOffline) {
        toast({
          title: "Voice note saved offline",
          description: "Recording saved locally. Will be transcribed when internet is available.",
        });
      } else {
        toast({
          title: "Voice note saved",
          description: "Your voice note has been transcribed and enhanced by AI.",
        });
      }
    },
    onError: (error) => {
      console.error("Voice note error:", error);
      toast({
        title: "Error",
        description: "Failed to save voice note. Please try again.",
        variant: "destructive",
      });
      handleReset();
    },
  });

  const setupAudioContext = useCallback(async () => {
    try {
      // Use centralized permission management
      if (!hasMicrophone) {
        console.log("Requesting microphone permission...");
        const granted = await requestMicrophonePermission();
        if (!granted) {
          const isDenied = permissions.microphone === 'denied';
          toast({
            title: isDenied ? "Microphone Access Denied" : "Microphone Permission Required",
            description: isDenied 
              ? "Please enable microphone access in your browser settings to record voice notes."
              : "Microphone access is needed to record voice notes. Please allow access and try again.",
            variant: "destructive",
          });
          return false;
        }
      }

      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        }
      });
      
      streamRef.current = stream;
      
      // Setup audio context for waveform visualization
      audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();
      const source = audioContextRef.current.createMediaStreamSource(stream);
      analyserRef.current = audioContextRef.current.createAnalyser();
      
      analyserRef.current.fftSize = 256;
      const bufferLength = analyserRef.current.frequencyBinCount;
      dataArrayRef.current = new Uint8Array(bufferLength);
      
      source.connect(analyserRef.current);
      
      // Setup media recorder with optimal settings
      const mimeTypes = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/mp4',
        'audio/ogg;codecs=opus'
      ];
      
      let selectedMimeType = 'audio/webm';
      for (const mimeType of mimeTypes) {
        if (MediaRecorder.isTypeSupported(mimeType)) {
          selectedMimeType = mimeType;
          break;
        }
      }
      
      mediaRecorderRef.current = new MediaRecorder(stream, {
        mimeType: selectedMimeType,
        audioBitsPerSecond: 128000 // High quality audio
      });
      
      chunksRef.current = [];
      
      mediaRecorderRef.current.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };
      
      mediaRecorderRef.current.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: selectedMimeType });
        setAudioBlob(blob);
        stopWaveformAnimation();
        
        // Auto-save the recording
        createVoiceNoteMutation.mutate(blob);
      };
      
      return true;
    } catch (error: any) {
      console.error("Error setting up audio details:", {
        name: error?.name,
        message: error?.message,
        constraint: error?.constraint
      });
      
      let errorMessage = "Unable to access microphone. ";
      
      if (error?.name === 'NotAllowedError') {
        errorMessage = "Microphone permission was denied. Please enable microphone access in your browser settings.";
      } else if (error?.name === 'NotFoundError') {
        errorMessage = "No microphone found on this device.";
      } else if (error?.name === 'NotReadableError') {
        errorMessage = "Microphone is already in use by another application.";
      } else if (error?.name === 'OverconstrainedError') {
        errorMessage = `Microphone settings not supported: ${error?.constraint || 'unknown constraint'}`;
      } else {
        errorMessage += `${error?.message || error?.name || 'Unknown error'}`;
      }
      
      toast({
        title: "Microphone Error",
        description: errorMessage,
        variant: "destructive",
      });
      return false;
    }
  }, [toast, createVoiceNoteMutation, hasMicrophone, requestMicrophonePermission, permissions.microphone]);

  const updateWaveform = useCallback(() => {
    if (!analyserRef.current || !dataArrayRef.current || !isRecording) return;
    
    // Read real-time audio frequency data from microphone
    analyserRef.current.getByteFrequencyData(dataArrayRef.current);
    
    // Process authentic audio data into visual bars
    const waveform: number[] = [];
    const bufferLength = dataArrayRef.current.length;
    const samplesPerBar = Math.floor(bufferLength / 32);
    
    for (let i = 0; i < bufferLength; i += samplesPerBar) {
      let sum = 0;
      let count = 0;
      for (let j = 0; j < samplesPerBar && i + j < bufferLength; j++) {
        sum += dataArrayRef.current[i + j];
        count++;
      }
      const amplitude = count > 0 ? (sum / count) / 255 : 0;
      waveform.push(amplitude);
    }
    
    setWaveformData(waveform);
    
    // Continue real-time animation loop
    animationRef.current = requestAnimationFrame(updateWaveform);
  }, [isRecording]);

  const startWaveformAnimation = useCallback(() => {
    updateWaveform();
  }, [updateWaveform]);

  const stopWaveformAnimation = useCallback(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, []);

  const startRecording = async () => {
    const success = await setupAudioContext();
    if (!success) return;
    
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'inactive') {
      mediaRecorderRef.current.start(100);
      onStartRecording();
      setRecordingTime(0);
      
      // Start timer
      intervalRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
      
      // Start waveform animation
      startWaveformAnimation();
    }
  };

  const stopRecording = () => {
    // Check duration BEFORE stopping recorder
    if (recordingTime < 1.5) {
      console.log(`Voice recording too short: ${recordingTime}s, discarding`);
      handleReset();
      toast({
        title: "Recording too short",
        description: "Voice notes must be at least 1.5 seconds long.",
        variant: "destructive",
      });
      return;
    }

    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
      mediaRecorderRef.current.stop();
      onStopRecording();
      stopWaveformAnimation();
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }
    
    // Stop all tracks
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
    }
  };

  const handleReset = () => {
    onStopRecording();
    setRecordingTime(0);
    setAudioBlob(null);
    setWaveformData([]);
    chunksRef.current = [];
    
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    
    stopWaveformAnimation();
    
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      handleReset();
    };
  }, []);

  if (!isRecording && waveformData.length === 0) {
    // Show mic button to start recording
    return (
      <button
        onClick={startRecording}
        className={`p-3 rounded-full bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${className}`}
      >
        <Mic className="w-5 h-5" />
      </button>
    );
  }

  // Show inline recording interface
  return (
    <div className={`flex items-center space-x-3 bg-white dark:bg-gray-800 rounded-2xl p-3 shadow-lg ${className}`}>
      {/* Recording indicator and time */}
      <div className="flex items-center space-x-2">
        <button
          onClick={isRecording ? stopRecording : startRecording}
          className={`p-2 rounded-full transition-colors ${
            isRecording 
              ? 'bg-red-500 text-white' 
              : 'bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400'
          }`}
        >
          {isRecording ? <Square className="w-4 h-4" /> : <Mic className="w-4 h-4" />}
        </button>
        
        {isRecording && (
          <div className="text-sm font-mono text-red-600 dark:text-red-400">
            {formatTime(recordingTime)}
          </div>
        )}
      </div>

      {/* Enhanced Streaming Waveform */}
      <div className="flex-1 h-8 flex items-end justify-center space-x-0.5 overflow-hidden">
        {waveformData.length > 0 ? (
          waveformData.map((amplitude, index) => (
            <div
              key={`${Date.now()}-${index}`}
              className={`w-0.5 rounded-full transition-all duration-75 ease-out ${
                isRecording 
                  ? 'bg-gradient-to-t from-blue-600 via-blue-500 to-cyan-400' 
                  : 'bg-gradient-to-t from-gray-400 to-gray-300'
              }`}
              style={{
                height: `${Math.max(2, amplitude * 28)}px`,
                opacity: isRecording ? Math.max(0.6, 0.8 + amplitude * 0.2) : 0.5,
                transform: `scaleY(${Math.max(0.1, amplitude + 0.1)})`,
                animation: isRecording && amplitude > 0.1 ? 'pulse 0.5s ease-in-out' : 'none'
              }}
            />
          ))
        ) : isRecording ? (
          // Immediate visual feedback while audio initializes
          <div className="flex items-center space-x-1">
            {[...Array(8)].map((_, i) => (
              <div
                key={i}
                className="w-0.5 h-2 bg-gradient-to-t from-blue-600 to-cyan-400 rounded-full animate-pulse"
                style={{
                  animationDelay: `${i * 0.1}s`,
                  animationDuration: '1s'
                }}
              />
            ))}
          </div>
        ) : (
          <div className="text-gray-400 text-xs flex items-center">
            <div className="w-1 h-1 bg-gray-400 rounded-full mr-2"></div>
            Ready to record
          </div>
        )}
      </div>

      {/* Processing indicator */}
      {createVoiceNoteMutation.isPending && (
        <div className="flex items-center space-x-2 text-blue-600 text-xs">
          <div className="animate-spin rounded-full h-3 w-3 border-b border-blue-600"></div>
          <span>Processing...</span>
        </div>
      )}
    </div>
  );
}```

### client/src/components/input-bar.tsx
```typescript
import { Camera, Mic, Plus, Send, Square, X as CloseIcon, FileText, Image } from "lucide-react";
import { useState, useRef, useCallback, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";
import { useLocation } from "wouter";

interface InputBarProps {
  onTextSubmit?: (text: string) => void;
  onCameraCapture?: () => void;
  onNewNote?: () => void;
  isHidden?: boolean;
  className?: string;
}

export default function InputBar({
  onTextSubmit,
  onCameraCapture,
  onNewNote,
  isHidden = false,
  className = ""
}: InputBarProps) {
  // Get current page context
  const [location] = useLocation();
  const currentPage = location.split('/')[1] || 'notes';

  // Input state
  const [inputText, setInputText] = useState("");
  const [isTyping, setIsTyping] = useState(false);

  // Mode state
  const [showSubmenu, setShowSubmenu] = useState(false);
  const [isVoiceRecording, setIsVoiceRecording] = useState(false);

  // Voice recording state
  const [recordingTime, setRecordingTime] = useState(0);
  const [waveformData, setWaveformData] = useState<number[]>([]);
  const [recordingStartTime, setRecordingStartTime] = useState<number>(0);

  // Refs
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const dataArrayRef = useRef<Uint8Array | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const animationRef = useRef<number | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const generalFileInputRef = useRef<HTMLInputElement>(null);

  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Context-aware placeholders and settings
  const getContextConfig = () => {
    switch (currentPage) {
      case 'remind':
        return {
          placeholder: "Add/edit to-do's + reminders...",
          showCamera: false,
          showMediaPicker: false,
          context: "remind"
        };
      case 'collections':
        return {
          placeholder: "Add to collection...",
          showCamera: true,
          showMediaPicker: true,
          context: "collections"
        };
      case 'note-detail':
        return {
          placeholder: "Add/edit anything here...",
          showCamera: true,
          showMediaPicker: true,
          context: "note_edit"
        };
      default: // notes page
        return {
          placeholder: "What's on your mind?",
          showCamera: true,
          showMediaPicker: true,
          context: "notes"
        };
    }
  };

  const config = getContextConfig();

  // Text note mutation
  const createTextNoteMutation = useMutation({
    mutationFn: async (text: string) => {
      const endpoint = currentPage === 'remind' ? "/api/reminders" : "/api/notes";
      const response = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          content: text,
          mode: "text",
          context: config.context
        }),
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error(`Failed to create ${currentPage === 'remind' ? 'reminder' : 'note'}`);
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      queryClient.invalidateQueries({ queryKey: ["/api/reminders"] });
      toast({
        title: `${currentPage === 'remind' ? 'Reminder' : 'Note'} saved`,
        description: `Your ${currentPage === 'remind' ? 'reminder' : 'note'} has been created successfully.`,
        duration: 3000,
      });
    },
    onError: (error) => {
      console.error("Text submission error:", error);
      toast({
        title: "Error",
        description: `Failed to save ${currentPage === 'remind' ? 'reminder' : 'note'}. Please try again.`,
        variant: "destructive",
      });
    },
  });

  // Voice note mutation
  const createVoiceNoteMutation = useMutation({
    mutationFn: async (audioBlob: Blob) => {
      const placeholderResponse = await fetch("/api/notes/placeholder", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          content: "🎤 Recording voice note...",
          type: "voice",
          context: config.context
        }),
        credentials: "include",
      });

      if (!placeholderResponse.ok) {
        throw new Error("Failed to create placeholder note");
      }

      const placeholderNote = await placeholderResponse.json();
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });

      const formData = new FormData();
      formData.append("audio", audioBlob);
      formData.append("noteId", placeholderNote.id.toString());

      const response = await fetch("/api/notes/voice", {
        method: "POST",
        body: formData,
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error("Failed to upload voice note");
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      toast({
        title: "Voice note saved",
        description: "Your voice note has been transcribed and saved.",
        duration: 3000,
      });
    },
    onError: (error) => {
      console.error("Voice note error:", error);
      toast({
        title: "Error",
        description: "Failed to save voice note. Please try again.",
        variant: "destructive",
      });
    },
  });

  // Image upload mutation
  const uploadImageMutation = useMutation({
    mutationFn: async (file: File) => {
      const placeholderResponse = await fetch("/api/notes/placeholder", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          content: "📷 Processing image...",
          type: "image",
          context: config.context
        }),
        credentials: "include",
      });

      if (!placeholderResponse.ok) {
        throw new Error("Failed to create placeholder note");
      }

      const placeholderNote = await placeholderResponse.json();
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });

      const formData = new FormData();
      formData.append("image", file);
      formData.append("noteId", placeholderNote.id.toString());

      const response = await fetch("/api/notes/image", {
        method: "POST",
        body: formData,
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error("Failed to upload image");
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      closeSubmenu();
      toast({
        title: "Image processed",
        description: "Your image has been analyzed and enhanced by AI.",
        duration: 3000,
      });
    },
    onError: (error) => {
      console.error("Image upload error:", error);
      toast({
        title: "Error",
        description: "Failed to upload image. Please try again.",
        variant: "destructive",
      });
    },
  });

  // File upload mutation
  const uploadFileMutation = useMutation({
    mutationFn: async (file: File) => {
      const placeholderResponse = await fetch("/api/notes/placeholder", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          content: `📄 Processing ${file.name}...`,
          type: "file",
          context: config.context
        }),
        credentials: "include",
      });

      if (!placeholderResponse.ok) {
        throw new Error("Failed to create placeholder note");
      }

      const placeholderNote = await placeholderResponse.json();
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });

      const formData = new FormData();
      formData.append("file", file);
      formData.append("noteId", placeholderNote.id.toString());

      const response = await fetch("/api/notes/file", {
        method: "POST",
        body: formData,
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error("Failed to upload file");
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      closeSubmenu();
      toast({
        title: "File processed",
        description: "Your file has been analyzed and enhanced by AI.",
        duration: 3000,
      });
    },
    onError: (error) => {
      console.error("File upload error:", error);
      toast({
        title: "Error",
        description: "Failed to upload file. Please try again.",
        variant: "destructive",
      });
    },
  });

  // Mode management functions
  const closeAllModes = useCallback(() => {
    setShowSubmenu(false);
    if (isVoiceRecording) {
      stopRecording();
      setIsVoiceRecording(false);
    }
  }, [isVoiceRecording]);

  const openCamera = useCallback(() => {
    console.log('📷 CAMERA TRIGGERED!');
    closeAllModes();
    onCameraCapture?.();
  }, [onCameraCapture]);

  const toggleSubmenu = useCallback(() => {
    console.log('Submenu button clicked');
    if (isVoiceRecording) {
      stopRecording();
      setIsVoiceRecording(false);
    }
    setShowSubmenu(!showSubmenu);
  }, [isVoiceRecording, showSubmenu]);

  const closeSubmenu = useCallback(() => {
    setShowSubmenu(false);
  }, []);

  // Text input handlers
  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;
    setInputText(value);
    setIsTyping(value.length > 0);
  };

  const handleSendMessage = () => {
    if (inputText.trim()) {
      if (onTextSubmit) {
        onTextSubmit(inputText.trim());
      } else {
        createTextNoteMutation.mutate(inputText.trim());
      }
      setInputText("");
      setIsTyping(false);
      closeAllModes();
    } else {
      onNewNote?.();
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (inputText.trim()) {
        handleSendMessage();
      }
    }
  };

  const startVoiceRecording = useCallback(async () => {
    setShowSubmenu(false);
    setIsVoiceRecording(true);
    await startRecording();
  }, []);

  const stopVoiceRecording = useCallback(() => {
    stopRecording();
    setIsVoiceRecording(false);
  }, []);

  // Audio setup and recording functions
  const setupAudioContext = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        }
      });

      streamRef.current = stream;

      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(stream);
      const analyser = audioContext.createAnalyser();

      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      dataArrayRef.current = new Uint8Array(bufferLength);

      source.connect(analyser);

      audioContextRef.current = audioContext;
      analyserRef.current = analyser;

      const options = { mimeType: 'audio/webm' };
      let mediaRecorder;

      if (MediaRecorder.isTypeSupported('audio/webm')) {
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
      } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/mp4' });
      } else if (MediaRecorder.isTypeSupported('audio/ogg')) {
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/ogg' });
      } else {
        mediaRecorder = new MediaRecorder(stream);
      }

      chunksRef.current = [];

      mediaRecorder.ondataavailable = (event) => {
        chunksRef.current.push(event.data);
      };

      mediaRecorder.onstop = () => {
        const mimeType = mediaRecorder.mimeType || 'audio/webm';
        const blob = new Blob(chunksRef.current, { type: mimeType });
        createVoiceNoteMutation.mutate(blob);

        stream.getTracks().forEach(track => track.stop());
        audioContext.close();
        setWaveformData([]);
      };

      mediaRecorderRef.current = mediaRecorder;
      return true;
    } catch (error) {
      console.error('Audio setup error:', error);
      toast({
        title: "Microphone Error",
        description: "Could not access microphone. Please check permissions.",
        variant: "destructive",
      });
      return false;
    }
  }, [createVoiceNoteMutation, toast]);

  // Enhanced waveform animation with immediate feedback
  const updateWaveform = useCallback(() => {
    if (!analyserRef.current || !dataArrayRef.current || !isVoiceRecording) return;

    analyserRef.current.getByteFrequencyData(dataArrayRef.current);

    const waveform: number[] = [];
    const bufferLength = dataArrayRef.current.length;
    const samplesPerBar = Math.floor(bufferLength / 24); // More bars for smoother visualization

    for (let i = 0; i < bufferLength; i += samplesPerBar) {
      let sum = 0;
      let count = 0;
      for (let j = 0; j < samplesPerBar && i + j < bufferLength; j++) {
        sum += dataArrayRef.current[i + j];
        count++;
      }
      const avgAmplitude = count > 0 ? (sum / count) / 255 : 0;
      // Enhanced scaling for better visual representation
      const scaledAmplitude = Math.pow(avgAmplitude, 0.6) * 1.5;
      waveform.push(Math.min(1, scaledAmplitude));
    }

    // Apply smoothing to reduce visual jitter
    const smoothedWaveform = waveform.map((value, index) => {
      if (index === 0 || index === waveform.length - 1) return value;
      return (waveform[index - 1] + value + waveform[index + 1]) / 3;
    });

    setWaveformData(smoothedWaveform);

    if (isVoiceRecording) {
      animationRef.current = requestAnimationFrame(updateWaveform);
    }
  }, [isVoiceRecording]);

  const startWaveformAnimation = useCallback(() => {
    updateWaveform();
  }, [updateWaveform]);

  const stopWaveformAnimation = useCallback(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, []);

  // Recording functions
  const startRecording = useCallback(async () => {
    const success = await setupAudioContext();
    if (!success) return;

    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'inactive') {
      const startTime = Date.now();
      setRecordingStartTime(startTime);
      mediaRecorderRef.current.start(100);
      setRecordingTime(0);

      intervalRef.current = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        setRecordingTime(elapsed);
      }, 100);

      startWaveformAnimation();
    }
  }, [setupAudioContext, startWaveformAnimation]);

  const stopRecording = useCallback(() => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
      mediaRecorderRef.current.stop();
      stopWaveformAnimation();
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
    }

    setRecordingTime(0);
    setWaveformData([]);
  }, [stopWaveformAnimation]);

  // File handlers
  const [capturedImageData, setCapturedImageData] = useState<string>("");
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [showMediaDialog, setShowMediaDialog] = useState(false);

  const handleImageSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      if (file.type.startsWith('image/')) {
          handleFileSelect(file);
      } else {
        toast({
          title: "Unsupported file type",
          description: "Please select an image file (JPG, PNG, GIF, etc.)",
          variant: "destructive",
        });
      }
    }
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleGeneralFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
        handleFileSelect(file);
    }
    if (generalFileInputRef.current) {
      generalFileInputRef.current.value = '';
    }
  };

    const handleFileSelect = async (file: File) => {
    if (!file) return;

    console.log('📁 File selected:', file.name, file.type);

    // Show MediaContextDialog for all file uploads (same as camera flow)
    setSelectedFile(file);
    setShowMediaDialog(true);
  };


  const openPhotoLibrary = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
    closeSubmenu();
  };

  const openFilePicker = () => {
    if (generalFileInputRef.current) {
      generalFileInputRef.current.click();
    }
    closeSubmenu();
  };

  // Format time for recording timer
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  if (isHidden) return null;

  return (
    <>
      {/* Hidden file inputs */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        onChange={handleImageSelect}
        className="hidden"
      />
      <input
        ref={generalFileInputRef}
        type="file"
        onChange={handleGeneralFileSelect}
        className="hidden"
      />

      {/* Main input bar */}
      <div 
        className={`fixed left-4 right-4 ${className}`}
        style={{ 
          zIndex: 9999,
          bottom: 'calc(3.5rem + 16px)',
          filter: 'drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1))'
        }}
      >
        <div className="relative flex items-center gap-1.5 bg-white rounded-2xl p-3 shadow-lg border border-gray-300">
          {/* Media picker overlay - positioned above plus button */}
          {showSubmenu && config.showMediaPicker && (
            <div className="absolute bottom-full right-0 mb-2 z-50" style={{ right: '48px' }}>
              <div className="w-[200px] bg-white border border-gray-300 rounded-[8px] overflow-hidden shadow-lg">
                <button
                  onMouseDown={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                  }}
                  onTouchStart={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                  }}
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeSubmenu();
                    // Direct trigger without setTimeout to prevent native behavior
                    if (fileInputRef.current) {
                      fileInputRef.current.click();
                    }
                  }}
                  className="w-full px-3 py-2 text-center text-gray-700 font-normal text-[16px] border-b border-gray-200/50 hover:bg-gray-50 active:bg-gray-100 flex items-center justify-center gap-2"
                  disabled={uploadImageMutation.isPending}
                >
                  <Image className="w-[16px] h-[16px]" />
                  {uploadImageMutation.isPending ? "Uploading..." : "Photo Library"}
                </button>

                <button
                  onMouseDown={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                  }}
                  onTouchStart={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                  }}
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeSubmenu();
                    // Direct trigger without setTimeout to prevent native behavior
                    if (generalFileInputRef.current) {
                      generalFileInputRef.current.click();
                    }
                  }}
                  className="w-full px-3 py-2 text-center text-gray-700 font-normal text-[16px] hover:bg-gray-50 active:bg-gray-100 flex items-center justify-center gap-2"
                  disabled={uploadFileMutation.isPending}
                >
                  <FileText className="w-[16px] h-[16px]" />
                  {uploadFileMutation.isPending ? "Uploading..." : "Choose File"}
                </button>
              </div>
            </div>
          )}

          {/* Enhanced streaming waveform display */}
          {isVoiceRecording && (
            <div className="absolute left-3 right-20 top-1/2 transform -translate-y-1/2 flex items-center space-x-2 bg-white/95 dark:bg-gray-800/95 backdrop-blur rounded-lg px-3 py-2 z-20 shadow-lg">
              <div className="text-xs font-mono text-red-600 dark:text-red-400 min-w-[2.5rem]">
                {formatTime(recordingTime)}
              </div>
              <div className="flex-1 h-6 flex items-end justify-start space-x-0.5 overflow-hidden">
                {waveformData.length > 0 ? (
                  waveformData.slice(0, 24).map((amplitude, index) => (
                    <div
                      key={`${Date.now()}-${index}`}
                      className="w-0.5 bg-gradient-to-t from-red-600 via-red-500 to-orange-400 dark:from-red-500 dark:via-red-400 dark:to-orange-300 rounded-full transition-all duration-50 ease-out"
                      style={{
                        height: `${Math.max(2, amplitude * 22)}px`,
                        opacity: Math.max(0.5, 0.7 + amplitude * 0.3),
                        transform: `scaleY(${Math.max(0.2, amplitude + 0.1)})`,
                        animation: amplitude > 0.1 ? 'pulse 0.3s ease-in-out' : 'none'
                      }}
                    />
                  ))
                ) : (
                  <div className="flex items-center space-x-1">
                    {[...Array(6)].map((_, i) => (
                      <div
                        key={i}
                        className="w-0.5 h-2 bg-gradient-to-t from-red-600 to-orange-400 rounded-full animate-pulse"
                        style={{
                          animationDelay: `${i * 0.1}s`,
                          animationDuration: '1s'
                        }}
                      />
                    ))}
                    <span className="text-xs text-red-600 dark:text-red-400 ml-2">Recording...</span>
                  </div>
                )}
              </div>
              {createVoiceNoteMutation.isPending && (
                <div className="text-xs text-blue-600">Processing...</div>
              )}
            </div>
          )}

          {/* Text input */}
          <textarea
            value={inputText}
            onChange={handleInputChange}
            onKeyDown={handleKeyPress}
            placeholder={isVoiceRecording ? "Recording voice note..." : config.placeholder}
            className="flex-1 bg-transparent border-none outline-none text-sm placeholder-gray-500 text-gray-900 resize-none overflow-hidden"
            rows={1}
            style={{
              minHeight: '20px',
              maxHeight: '120px'
            }}
            disabled={isVoiceRecording}
            onInput={(e) => {
              const target = e.target as HTMLTextAreaElement;
              target.style.height = 'auto';
              target.style.height = Math.min(target.scrollHeight, 120) + 'px';
            }}
          />

          {/* Action buttons */}
          <div className="flex items-center gap-1.5">
            {config.showMediaPicker && (
              <button 
                onMouseDown={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                }}
                onTouchStart={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                }}
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  toggleSubmenu();
                }}
                className="w-8 h-8 bg-gray-300 hover:bg-gray-400 text-gray-700 rounded-full flex items-center justify-center transition-colors"
              >
                <Plus className="w-4 h-4" />
              </button>
            )}

            {inputText.trim() ? (
              <button 
                onClick={handleSendMessage}
                className="w-8 h-8 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center transition-colors"
              >
                <Send className="w-4 h-4" />
              </button>
            ) : (
              <>
                {config.showCamera && (
                  <button 
                    onClick={openCamera}
                    className="w-8 h-8 text-gray-700 rounded-full flex items-center justify-center transition-colors"
                    style={{ backgroundColor: '#a8bfa1' }}
                  >
                    <Camera className="w-4 h-4" />
                  </button>
                )}
                <button 
                  onClick={isVoiceRecording ? stopVoiceRecording : startVoiceRecording}
                  className="w-8 h-8 rounded-full flex items-center justify-center transition-colors z-20 relative hover:opacity-90 text-[#374252]"
                  style={{ backgroundColor: isVoiceRecording ? '#ef4444' : '#9bb8d3' }}
                  disabled={createVoiceNoteMutation.isPending}
                >
                  {isVoiceRecording ? <Square className="w-4 h-4" /> : <Mic className="w-4 h-4" />}
                </button>
              </>
            )}
          </div>
        </div>
      </div>
      
      {/* Media Context Dialog - temporarily disabled */}
      {showMediaDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
          <div className="bg-white p-4 rounded-lg">
            <button 
              onClick={() => {
                setShowMediaDialog(false);
                setCapturedImageData("");
                setSelectedFile(null);
              }}
              className="px-4 py-2 bg-gray-500 text-white rounded"
            >
              Close
            </button>
          </div>
        </div>
      )}
    </>
  );
}```

### client/src/components/ios-action-sheet.tsx
```typescript

import React from 'react';
import { X, Image, FileText } from 'lucide-react';

interface IOSActionSheetProps {
  isOpen: boolean;
  onClose: () => void;
  onPhotoLibrary: () => void;
  onChooseFile: () => void;
}

export default function IOSActionSheet({ 
  isOpen, 
  onClose, 
  onPhotoLibrary, 
  onChooseFile 
}: IOSActionSheetProps) {
  if (!isOpen) return null;

  return (
    <>
      {/* Backdrop */}
      <div 
        className="fixed inset-0 bg-black/40 z-[100] transition-opacity duration-300"
        onClick={onClose}
      />
      
      {/* Action Sheet - Positioned relative to input bar with gap */}
      <div className="fixed right-6 z-[101]" style={{ bottom: 'calc(3.5rem + 16px + 60px + 8px)' }}>
        <div className="w-[200px]">
          {/* Main Actions */}
          <div className="bg-white border border-gray-300 rounded-[8px] overflow-hidden shadow-lg">
            <button
              onClick={() => {
                onPhotoLibrary();
                onClose();
              }}
              className="w-full px-3 py-2 text-center text-gray-700 font-normal text-[16px] border-b border-gray-200/50 hover:bg-gray-50 active:bg-gray-100 flex items-center justify-center gap-2"
            >
              <Image className="w-[16px] h-[16px]" />
              Photo Library
            </button>
            
            <button
              onClick={() => {
                onChooseFile();
                onClose();
              }}
              className="w-full px-3 py-2 text-center text-gray-700 font-normal text-[16px] hover:bg-gray-50 active:bg-gray-100 flex items-center justify-center gap-2"
            >
              <FileText className="w-[16px] h-[16px]" />
              Choose File
            </button>
          </div>
        </div>
      </div>
    </>
  );
}
```

### client/src/components/ios-voice-recorder.tsx
```typescript
import { useState, useEffect, useRef, useCallback } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { X, Mic, Square, Pause, Play } from "lucide-react";
import { useToast } from "@/hooks/use-toast";

interface IOSVoiceRecorderProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function IOSVoiceRecorder({ isOpen, onClose }: IOSVoiceRecorderProps) {
  const [recordingState, setRecordingState] = useState<'ready' | 'recording' | 'paused' | 'stopped' | 'processing'>('ready');
  const [recordingTime, setRecordingTime] = useState(0);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  const [waveformData, setWaveformData] = useState<number[]>([]);

  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const dataArrayRef = useRef<Uint8Array | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const animationRef = useRef<number | null>(null);
  const chunksRef = useRef<Blob[]>([]);

  const { toast } = useToast();
  const queryClient = useQueryClient();

  const createVoiceNoteMutation = useMutation({
    mutationFn: async (audioBlob: Blob) => {
      // Check if online
      if (!navigator.onLine) {
        // Store offline voice note
        const offlineNote = {
          content: `🎤 Voice recording (${Math.round(recordingTime)}s) - Pending transcription`,
          mode: "voice",
          audioBlob: audioBlob,
          audioUrl: URL.createObjectURL(audioBlob),
          isProcessing: true,
          isOffline: true,
          recordingDuration: recordingTime,
          createdAt: new Date().toISOString()
        };
        
        // Store in offline storage
        const { useOfflineStore } = await import("@/store/offline-store");
        const note = await useOfflineStore.getState().createNote(offlineNote);
        
        return note;
      }

      // Online flow - existing logic
      const formData = new FormData();
      formData.append("audio", audioBlob, "recording.webm");
      formData.append("duration", recordingTime.toString());

      const response = await fetch("/api/notes/voice", {
        method: "POST",
        body: formData,
        credentials: "include",
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to create voice note");
      }

      return response.json();
    },
    onSuccess: (note) => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      handleReset();
      onClose();
      
      if (note.isOffline) {
        toast({
          title: "Voice note saved offline",
          description: "Recording saved locally. Will be transcribed when internet is available.",
        });
      } else {
        toast({
          title: "Voice note saved",
          description: "Your voice note has been transcribed and enhanced by AI.",
        });
      }
    },
    onError: (error) => {
      console.error("Voice note error:", error);
      toast({
        title: "Error",
        description: "Failed to save voice note. Please try again.",
        variant: "destructive",
      });
      setRecordingState('stopped');
    },
  });

  //TODO: Implement usePermissions hook

  const usePermissions = () => {
    const [hasMicrophone, setHasMicrophone] = useState(false);
    const [needsMicrophonePermission, setNeedsMicrophonePermission] = useState(false);

    useEffect(() => {
      const checkMicrophonePermission = async () => {
        try {
          const permissionStatus = await navigator.permissions.query({ name: 'microphone' as PermissionName });

          setHasMicrophone(permissionStatus.state === 'granted');
          setNeedsMicrophonePermission(permissionStatus.state !== 'granted');

          permissionStatus.addEventListener('change', () => {
            setHasMicrophone(permissionStatus.state === 'granted');
            setNeedsMicrophonePermission(permissionStatus.state !== 'granted');
          });
        } catch (error) {
          console.error("Error checking microphone permission:", error);
          // Assume permission is needed if there's an error checking
          setNeedsMicrophonePermission(true);
        }
      };

      // Check initial microphone permission
      checkMicrophonePermission();

      // Listen for changes in permission status
    }, []);

    const requestMicrophonePermission = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop());
        setHasMicrophone(true);
        setNeedsMicrophonePermission(false);
        return true; // Permission granted
      } catch (error) {
        console.error("Error requesting microphone permission:", error);
        setHasMicrophone(false);
        setNeedsMicrophonePermission(true);
        return false; // Permission denied
      }
    };

    return { hasMicrophone, requestMicrophonePermission, needsMicrophonePermission };
  };

  const { hasMicrophone, requestMicrophonePermission, needsMicrophonePermission } = usePermissions();

  const setupAudioContext = useCallback(async () => {
    if (!navigator.mediaDevices?.getUserMedia) {
      toast({
        title: "Not Supported",
        description: "Audio recording is not supported in this browser.",
        variant: "destructive",
      });
      return false;
    }

    try {
      // Check if we already have permission, if not request it
      if (needsMicrophonePermission) {
        const granted = await requestMicrophonePermission();
        if (!granted) {
          toast({
            title: "Microphone Permission Required",
            description: "Please allow microphone access to record audio. This permission will be remembered.",
            variant: "destructive",
          });
          return false;
        }
      }

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        }
      });

      streamRef.current = stream;

      // Setup audio context for waveform visualization
      audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();
      const source = audioContextRef.current.createMediaStreamSource(stream);
      analyserRef.current = audioContextRef.current.createAnalyser();

      analyserRef.current.fftSize = 256;
      const bufferLength = analyserRef.current.frequencyBinCount;
      dataArrayRef.current = new Uint8Array(bufferLength);

      source.connect(analyserRef.current);

      // Setup media recorder
      mediaRecorderRef.current = new MediaRecorder(stream, {
        mimeType: 'audio/webm;codecs=opus'
      });

      chunksRef.current = [];

      mediaRecorderRef.current.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };

      mediaRecorderRef.current.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
        setAudioBlob(blob);
        setRecordingState('stopped');
        stopWaveformAnimation();
      };

      return true;
    } catch (error) {
      console.error("Error setting up audio:", error);
      toast({
        title: "Microphone Error",
        description: "Unable to access microphone. Please check permissions.",
        variant: "destructive",
      });
      return false;
    }
  }, [toast, hasMicrophone, requestMicrophonePermission, needsMicrophonePermission]);

  const updateWaveform = useCallback(() => {
    if (!analyserRef.current || !dataArrayRef.current) return;

    analyserRef.current.getByteFrequencyData(dataArrayRef.current);

    // Convert to waveform data (simplified for visualization)
    const waveform = [];
    const step = Math.floor(dataArrayRef.current.length / 40); // 40 bars for waveform

    for (let i = 0; i < dataArrayRef.current.length; i += step) {
      let sum = 0;
      for (let j = 0; j < step && i + j < dataArrayRef.current.length; j++) {
        sum += dataArrayRef.current[i + j];
      }
      waveform.push(sum / step / 255); // Normalize to 0-1
    }

    setWaveformData(waveform);

    if (recordingState === 'recording') {
      animationRef.current = requestAnimationFrame(updateWaveform);
    }
  }, [recordingState]);

  const startWaveformAnimation = useCallback(() => {
    updateWaveform();
  }, [updateWaveform]);

  const stopWaveformAnimation = useCallback(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, []);

  const startRecording = async () => {
    const success = await setupAudioContext();
    if (!success) return;

    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'inactive') {
      mediaRecorderRef.current.start(100); // Collect data every 100ms
      setRecordingState('recording');
      setRecordingTime(0);

      // Initialize waveform with immediate animation
      setWaveformData(Array(40).fill(0).map(() => Math.random() * 0.4 + 0.2));
      
      // Start timer
      intervalRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);

      // Start waveform animation immediately
      startWaveformAnimation();
    }
  };

  const pauseRecording = () => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
      mediaRecorderRef.current.pause();
      setRecordingState('paused');
      stopWaveformAnimation();
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }
  };

  const resumeRecording = () => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'paused') {
      mediaRecorderRef.current.resume();
      setRecordingState('recording');

      // Resume timer
      intervalRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);

      // Resume waveform animation
      startWaveformAnimation();
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
      mediaRecorderRef.current.stop();
      stopWaveformAnimation();
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }

    // Stop all tracks
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
    }
  };

  const handleSave = () => {
    if (audioBlob) {
      // Check minimum duration (1.5 seconds)
      if (recordingTime < 1.5) {
        toast({
          title: "Voice note too short",
          description: "Please record for at least 1.5 seconds",
          variant: "destructive",
        });
        return;
      }
      
      setRecordingState('processing');
      createVoiceNoteMutation.mutate(audioBlob);
    }
  };

  const handleReset = () => {
    setRecordingState('ready');
    setRecordingTime(0);
    setAudioBlob(null);
    setWaveformData([]);
    chunksRef.current = [];

    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }

    stopWaveformAnimation();

    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Cleanup on unmount or close
  useEffect(() => {
    if (!isOpen) {
      handleReset();
    }

    return () => {
      handleReset();
    };
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-900 rounded-3xl p-6 w-full max-w-sm relative">
        <button
          onClick={onClose}
          className="absolute top-4 right-4 p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-full transition-colors"
        >
          <X className="w-5 h-5" />
        </button>

        <div className="text-center mb-8">
          <h2 className="text-xl font-semibold mb-2">Voice Recording</h2>
          <div className="text-3xl font-mono text-blue-600 dark:text-blue-400">
            {formatTime(recordingTime)}
          </div>
        </div>

        {/* Waveform Visualization */}
        <div className="h-20 mb-8 flex items-end justify-center space-x-1 bg-gray-50 dark:bg-gray-800 rounded-xl p-4">
          {waveformData.length > 0 ? (
            waveformData.map((amplitude, index) => (
              <div
                key={index}
                className={`w-1 bg-gradient-to-t from-blue-500 to-blue-300 rounded-full transition-all duration-100 ${
                  recordingState === 'recording' ? 'animate-pulse' : ''
                }`}
                style={{
                  height: `${Math.max(4, amplitude * 60)}px`,
                  opacity: recordingState === 'recording' ? 0.8 + amplitude * 0.2 : 0.6
                }}
              />
            ))
          ) : (
            <div className="text-gray-400 text-sm">
              {recordingState === 'ready' ? 'Tap to start recording' : 'No audio data'}
            </div>
          )}
        </div>

        {/* Control Buttons */}
        <div className="flex justify-center items-center space-x-4">
          {recordingState === 'ready' && (
            <button
              onClick={startRecording}
              className="w-16 h-16 bg-red-500 hover:bg-red-600 rounded-full flex items-center justify-center text-white transition-all duration-200 shadow-lg hover:shadow-xl"
            >
              <Mic className="w-6 h-6" />
            </button>
          )}

          {recordingState === 'recording' && (
            <>
              <button
                onClick={pauseRecording}
                className="w-12 h-12 bg-blue-500 hover:bg-blue-600 rounded-full flex items-center justify-center text-white transition-colors"
                title="Pause recording"
              >
                <Pause className="w-5 h-5" />
              </button>
              <button
                onClick={stopRecording}
                className="w-16 h-16 bg-red-600 hover:bg-red-700 rounded-lg flex items-center justify-center text-white transition-colors"
                title="Stop recording"
              >
                <Square className="w-6 h-6" />
              </button>
            </>
          )}

          {recordingState === 'paused' && (
            <div className="flex items-center space-x-3">
              <button
                onClick={resumeRecording}
                className="w-12 h-12 bg-blue-500 hover:bg-blue-600 rounded-full flex items-center justify-center text-white transition-colors"
                title="Resume recording"
              >
                <Play className="w-5 h-5 ml-1" />
              </button>
              <button
                onClick={stopRecording}
                className="w-12 h-12 bg-red-500 hover:bg-red-600 rounded-lg flex items-center justify-center text-white transition-colors"
                title="Stop recording"
              >
                <Square className="w-5 h-5" />
              </button>
              <button
                onClick={() => {
                  if (recordingTime >= 1.5) {
                    handleSave();
                  } else {
                    toast({
                      title: "Voice note too short",
                      description: "Please record for at least 1.5 seconds",
                      variant: "destructive",
                    });
                  }
                }}
                className="px-6 py-3 bg-green-500 hover:bg-green-600 text-white rounded-xl transition-colors flex items-center space-x-2"
                title="Send recording"
              >
                <span>Send</span>
              </button>
            </div>
          )}

          {recordingState === 'stopped' && (
            <div className="flex space-x-3">
              <button
                onClick={handleReset}
                className="px-6 py-3 bg-gray-500 hover:bg-gray-600 text-white rounded-xl transition-colors"
              >
                Retry
              </button>
              <button
                onClick={handleSave}
                className="px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-xl transition-colors"
              >
                Save Note
              </button>
            </div>
          )}

          {recordingState === 'processing' && (
            <div className="flex items-center space-x-2 text-blue-600">
              <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
              <span>Processing...</span>
            </div>
          )}
        </div>

        {recordingState === 'stopped' && audioBlob && (
          <div className="mt-4 text-center text-sm text-gray-600 dark:text-gray-400">
            Recording saved ({(audioBlob.size / 1024).toFixed(1)} KB)
          </div>
        )}
      </div>
    </div>
  );
}```

### client/src/components/MarkdownRenderer.tsx
```typescript
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';
import { ExternalLink, ShoppingCart, Star, Calendar, Play } from 'lucide-react';
import { useState } from 'react';

interface MarkdownRendererProps {
  content: string;
  className?: string;
}

interface LinkPreviewProps {
  href: string;
  children: React.ReactNode;
}

function LinkPreview({ href, children }: LinkPreviewProps) {
  const [showPreview, setShowPreview] = useState(false);
  
  // Extract domain for favicon and branding
  const getDomain = (url: string) => {
    try {
      return new URL(url).hostname.replace('www.', '');
    } catch {
      return '';
    }
  };

  // Detect link type based on URL
  const getLinkType = (url: string) => {
    const domain = url.toLowerCase();
    if (domain.includes('amazon.com') || domain.includes('amzn.to')) return 'shopping';
    if (domain.includes('youtube.com') || domain.includes('youtu.be')) return 'video';
    if (domain.includes('calendar.google.com')) return 'calendar';
    if (domain.includes('github.com')) return 'code';
    if (domain.includes('techradar.com') || domain.includes('wired.com') || domain.includes('ign.com') || domain.includes('cnet.com')) return 'review';
    return 'external';
  };

  const getLinkIcon = (type: string) => {
    switch (type) {
      case 'shopping': return <ShoppingCart className="w-3 h-3" />;
      case 'video': return <Play className="w-3 h-3" />;
      case 'calendar': return <Calendar className="w-3 h-3" />;
      case 'review': return <Star className="w-3 h-3" />;
      default: return <ExternalLink className="w-3 h-3" />;
    }
  };

  const getLinkColor = (type: string) => {
    switch (type) {
      case 'shopping': return 'text-orange-600 hover:text-orange-800 border-orange-200 hover:border-orange-300 bg-orange-50 hover:bg-orange-100';
      case 'video': return 'text-red-600 hover:text-red-800 border-red-200 hover:border-red-300 bg-red-50 hover:bg-red-100';
      case 'calendar': return 'text-blue-600 hover:text-blue-800 border-blue-200 hover:border-blue-300 bg-blue-50 hover:bg-blue-100';
      case 'review': return 'text-purple-600 hover:text-purple-800 border-purple-200 hover:border-purple-300 bg-purple-50 hover:bg-purple-100';
      default: return 'text-blue-600 hover:text-blue-800 border-blue-200 hover:border-blue-300 bg-blue-50 hover:bg-blue-100';
    }
  };

  const getPreviewTitle = (type: string, domain: string) => {
    switch (type) {
      case 'shopping': return 'Shop on Amazon';
      case 'video': return 'Watch on YouTube';
      case 'calendar': return 'Add to Calendar';
      case 'review': return `Expert Review - ${domain}`;
      default: return `Visit ${domain}`;
    }
  };

  const linkType = getLinkType(href);
  const linkIcon = getLinkIcon(linkType);
  const linkColor = getLinkColor(linkType);
  const domain = getDomain(href);
  const previewTitle = getPreviewTitle(linkType, domain);

  return (
    <span className="relative inline-block">
      <a
        href={href}
        target="_blank"
        rel="noopener noreferrer"
        className={`inline-flex items-center gap-1 px-2 py-1 rounded-md border transition-all duration-200 hover:shadow-sm ${linkColor}`}
        onMouseEnter={() => setShowPreview(true)}
        onMouseLeave={() => setShowPreview(false)}
      >
        {linkIcon}
        <span className="text-sm font-medium">{children}</span>
      </a>
      
      {showPreview && (
        <div className="absolute bottom-full left-0 mb-2 p-3 bg-white border border-gray-200 rounded-lg shadow-lg z-10 min-w-64 max-w-80">
          <div className="flex items-start gap-3">
            {/* Favicon/Icon Section */}
            <div className="flex-shrink-0">
              <div className={`p-2 rounded-lg ${
                linkType === 'shopping' ? 'bg-orange-100' : 
                linkType === 'video' ? 'bg-red-100' : 
                linkType === 'review' ? 'bg-purple-100' :
                'bg-blue-100'
              }`}>
                {linkIcon}
              </div>
            </div>
            
            {/* Content Section */}
            <div className="flex-1 min-w-0">
              <div className="text-sm font-medium text-gray-900 truncate">
                {previewTitle}
              </div>
              <div className="text-xs text-gray-500 truncate mt-1">
                {domain}
              </div>
              
              {/* Special indicators */}
              <div className="flex items-center gap-2 mt-2">
                {linkType === 'shopping' && (
                  <div className="flex items-center gap-1 px-2 py-1 bg-orange-100 rounded-full">
                    <Star className="w-3 h-3 text-orange-600 fill-current" />
                    <span className="text-xs text-orange-700 font-medium">Trusted Store</span>
                  </div>
                )}
                {linkType === 'video' && (
                  <div className="flex items-center gap-1 px-2 py-1 bg-red-100 rounded-full">
                    <Play className="w-3 h-3 text-red-600 fill-current" />
                    <span className="text-xs text-red-700 font-medium">Video Content</span>
                  </div>
                )}
                {linkType === 'review' && (
                  <div className="flex items-center gap-1 px-2 py-1 bg-purple-100 rounded-full">
                    <Star className="w-3 h-3 text-purple-600 fill-current" />
                    <span className="text-xs text-purple-700 font-medium">Expert Review</span>
                  </div>
                )}
              </div>
            </div>
          </div>
          
          {/* Click indicator */}
          <div className="text-xs text-gray-400 mt-2 flex items-center gap-1">
            <ExternalLink className="w-3 h-3" />
            <span>Click to open in new tab</span>
          </div>
        </div>
      )}
    </span>
  );
}

export function MarkdownRenderer({ content, className = "" }: MarkdownRendererProps) {
  return (
    <div className={`max-w-none leading-7 ${className}`}>
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[rehypeRaw]}
        components={{
          // ChatGPT-style table formatting
          table: ({ children }) => (
            <div className="my-8 overflow-hidden rounded-lg border border-gray-300 shadow-sm">
              <table className="min-w-full border-collapse bg-white">
                {children}
              </table>
            </div>
          ),
          thead: ({ children }) => (
            <thead className="bg-gray-50 border-b border-gray-200">
              {children}
            </thead>
          ),
          th: ({ children }) => (
            <th className="px-4 py-3 text-left text-sm font-semibold text-gray-900 border-r border-gray-200 last:border-r-0">
              {children}
            </th>
          ),
          td: ({ children }) => (
            <td className="px-4 py-3 text-sm text-gray-800 border-r border-gray-200 border-b border-gray-100 last:border-r-0">
              {children}
            </td>
          ),
          // Enhanced link styling with rich previews
          a: ({ href, children }) => (
            <LinkPreview href={href || '#'}>
              {children}
            </LinkPreview>
          ),
          // ChatGPT-style heading hierarchy
          h1: ({ children }) => (
            <h1 className="text-2xl font-bold text-gray-900 mt-8 mb-4 first:mt-0 leading-tight">
              {children}
            </h1>
          ),
          h2: ({ children }) => (
            <h2 className="text-xl font-bold text-gray-900 mt-7 mb-3 leading-tight">
              {children}
            </h2>
          ),
          h3: ({ children }) => (
            <h3 className="text-lg font-bold text-gray-900 mt-6 mb-3 leading-tight">
              {children}
            </h3>
          ),
          h4: ({ children }) => (
            <h4 className="text-base font-bold text-gray-900 mt-5 mb-2 leading-tight">
              {children}
            </h4>
          ),
          // ChatGPT-style paragraph spacing and typography
          p: ({ children }) => (
            <p className="text-[15px] text-gray-800 mb-4 leading-7 font-normal">
              {children}
            </p>
          ),
          // Enhanced list styling matching ChatGPT
          ul: ({ children }) => (
            <ul className="mb-4 pl-6 space-y-2">
              {children}
            </ul>
          ),
          ol: ({ children }) => (
            <ol className="mb-4 pl-6 space-y-2 list-decimal">
              {children}
            </ol>
          ),
          li: ({ children }) => (
            <li className="text-[15px] text-gray-800 leading-7 marker:text-gray-600 pl-1">
              {children}
            </li>
          ),
          // ChatGPT-style code blocks
          code: ({ children, ...props }) => {
            const isInline = !String(props.className).includes('language-');
            if (isInline) {
              return (
                <code className="bg-gray-100 text-gray-900 px-1.5 py-0.5 rounded text-sm font-mono border">
                  {children}
                </code>
              );
            }
            return (
              <div className="my-5 rounded-lg border border-gray-200 overflow-hidden">
                <div className="bg-gray-100 px-4 py-2 border-b border-gray-200">
                  <span className="text-xs font-medium text-gray-600">Code</span>
                </div>
                <pre className="bg-gray-50 text-gray-900 p-4 overflow-x-auto text-sm font-mono leading-6">
                  <code>{children}</code>
                </pre>
              </div>
            );
          },
          // ChatGPT-style blockquotes
          blockquote: ({ children }) => (
            <blockquote className="border-l-4 border-gray-300 pl-6 py-2 my-6 bg-gray-50 rounded-r-lg">
              <div className="text-gray-700 italic font-medium">
                {children}
              </div>
            </blockquote>
          ),
          // Enhanced strong/bold styling
          strong: ({ children }) => (
            <strong className="font-bold text-gray-900">
              {children}
            </strong>
          ),
          // Enhanced emphasis/italic styling  
          em: ({ children }) => (
            <em className="italic text-gray-800">
              {children}
            </em>
          ),
          // Horizontal rule styling
          hr: () => (
            <hr className="my-8 border-0 border-t border-gray-200" />
          ),
          // Enhanced pre styling for code blocks
          pre: ({ children }) => (
            <div className="my-5 rounded-lg border border-gray-200 overflow-hidden">
              <div className="bg-gray-100 px-4 py-2 border-b border-gray-200">
                <span className="text-xs font-medium text-gray-600">Code</span>
              </div>
              <pre className="bg-gray-50 text-gray-900 p-4 overflow-x-auto text-sm font-mono leading-6">
                {children}
              </pre>
            </div>
          )
        }}
      >
        {content}
      </ReactMarkdown>
    </div>
  );
}```

### client/src/components/media-context-dialog.tsx
```typescript
import { useState, useRef, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Camera, Mic, Upload, Send, X } from "lucide-react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";

interface MediaContextDialogProps {
  isOpen: boolean;
  onClose: () => void;
  mediaType: 'camera' | 'image' | 'file' | null;
  capturedImage?: string;
  selectedFile?: File;
}

export default function MediaContextDialog({
  isOpen,
  onClose,
  mediaType,
  capturedImage,
  selectedFile
}: MediaContextDialogProps) {
  const [contextText, setContextText] = useState("");
  const [userHasTyped, setUserHasTyped] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [aiIdentification, setAiIdentification] = useState<string>("");
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const textareaRef = useRef<HTMLInputElement>(null);
  
  const { toast } = useToast();
  const queryClient = useQueryClient();

  useEffect(() => {
    if (isOpen && textareaRef.current) {
      setTimeout(() => textareaRef.current?.focus(), 100);
    }
    
    // Auto-analyze media when dialog opens
    if (isOpen && (capturedImage || selectedFile)) {
      analyzeMediaContent();
    }
  }, [isOpen, capturedImage, selectedFile]);

  const analyzeMediaContent = async () => {
    if (!capturedImage && !selectedFile) return;
    
    setIsAnalyzing(true);
    
    try {
      const formData = new FormData();
      
      if (capturedImage) {
        // Convert base64 to blob for analysis
        const response = await fetch(capturedImage);
        const blob = await response.blob();
        formData.append('image', blob, 'capture.jpg');
      } else if (selectedFile) {
        formData.append('image', selectedFile);
      }
      
      formData.append('analyzeOnly', 'true');
      
      const response = await fetch('/api/analyze-media', {
        method: 'POST',
        body: formData,
        credentials: 'include',
      });
      
      if (response.ok) {
        const analysis = await response.json();
        setAiIdentification(analysis.identification || "");
        // AI analysis stays separate - never populate user's text field
      }
    } catch (error) {
      console.error('Media analysis failed:', error);
    } finally {
      setIsAnalyzing(false);
    }
  };

  useEffect(() => {
    return () => {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach(track => track.stop());
      }
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  const startVoiceRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;
      
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      chunksRef.current = [];
      
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };
      
      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(chunksRef.current, { type: 'audio/webm' });
        setAudioBlob(audioBlob);
        
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }
      };
      
      mediaRecorder.start();
      setIsRecording(true);
      setRecordingTime(0);
      
      intervalRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
      
    } catch (error) {
      console.error('Error starting voice recording:', error);
      toast({
        title: "Recording Error",
        description: "Could not access microphone. Please check permissions.",
        variant: "destructive",
      });
    }
  };

  const stopVoiceRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
      
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    }
  };

  const createMediaNoteMutation = useMutation({
    mutationFn: async () => {
      const formData = new FormData();
      
      // Send AI analysis and user context separately
      if (aiIdentification) {
        formData.append('aiAnalysis', aiIdentification);
      }
      if (contextText.trim()) {
        formData.append('userContext', contextText.trim());
      }
      
      // Add media based on type
      if (mediaType === 'camera' && capturedImage) {
        // Convert base64 to blob
        const response = await fetch(capturedImage);
        const blob = await response.blob();
        formData.append('image', blob, 'capture.jpg');
        formData.append('mode', 'image');
      } else if (mediaType === 'image' && selectedFile) {
        formData.append('image', selectedFile);
        formData.append('mode', 'image');
      } else if (mediaType === 'file' && selectedFile) {
        formData.append('file', selectedFile);
        formData.append('mode', 'file');
      }
      
      // Add voice context if recorded
      if (audioBlob) {
        formData.append('audio', audioBlob, 'context.webm');
        formData.append('hasVoiceContext', 'true');
      }
      
      const response = await fetch('/api/notes/media', {
        method: 'POST',
        body: formData,
        credentials: 'include',
      });
      
      if (!response.ok) {
        throw new Error('Failed to create media note');
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/notes'] });
      queryClient.invalidateQueries({ queryKey: ['/api/collections'] });
      toast({
        title: "Media Note Created",
        description: "Your media note with context has been saved successfully.",
        duration: 3000,
      });
      handleClose();
    },
    onError: (error) => {
      console.error('Media note creation error:', error);
      toast({
        title: "Upload Error",
        description: "Failed to create media note. Please try again.",
        variant: "destructive",
      });
    },
  });

  const handleClose = () => {
    setContextText("");
    setUserHasTyped(false);
    setAiIdentification("");
    setAudioBlob(null);
    setRecordingTime(0);
    if (isRecording) {
      stopVoiceRecording();
    }
    onClose();
  };

  const handleSubmit = () => {
    if (!contextText.trim() && !audioBlob && !capturedImage && !selectedFile) {
      toast({
        title: "Add Context",
        description: "Please add some text or voice context for your media.",
        variant: "destructive",
      });
      return;
    }
    
    createMediaNoteMutation.mutate();
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const getMediaPreview = () => {
    if (mediaType === 'camera' && capturedImage) {
      return (
        <div className="relative">
          <img 
            src={capturedImage} 
            alt="Captured" 
            className="w-full h-32 object-cover rounded-lg"
          />
          <div className="absolute top-2 left-2 bg-black/50 text-white px-2 py-1 rounded text-xs">
            Camera Capture
          </div>
        </div>
      );
    }
    
    if ((mediaType === 'image' || mediaType === 'file') && selectedFile) {
      if (selectedFile.type.startsWith('image/')) {
        return (
          <div className="relative">
            <img 
              src={URL.createObjectURL(selectedFile)} 
              alt="Selected" 
              className="w-full h-32 object-cover rounded-lg"
            />
            <div className="absolute top-2 left-2 bg-black/50 text-white px-2 py-1 rounded text-xs">
              {selectedFile.name}
            </div>
          </div>
        );
      } else {
        return (
          <div className="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 flex items-center gap-3">
            <Upload className="w-8 h-8 text-gray-500" />
            <div>
              <div className="font-medium text-sm">{selectedFile.name}</div>
              <div className="text-xs text-gray-500">
                {(selectedFile.size / (1024 * 1024)).toFixed(2)} MB
              </div>
            </div>
          </div>
        );
      }
    }
    
    return null;
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            {mediaType === 'camera' && <Camera className="w-5 h-5" />}
            {mediaType === 'image' && <Upload className="w-5 h-5" />}
            {mediaType === 'file' && <Upload className="w-5 h-5" />}
            Add Context to Your Media
          </DialogTitle>
        </DialogHeader>
        
        <div className="space-y-4">
          {/* Media Preview */}
          {getMediaPreview()}
          
          {/* AI Analysis Display - Only show if meaningful results */}
          {isAnalyzing && (
            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                AI Analysis
              </label>
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3 min-h-[60px]">
                <div className="flex items-center gap-2 text-sm text-blue-700 dark:text-blue-300">
                  <div className="w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                  Processing...
                </div>
              </div>
            </div>
          )}
          {!isAnalyzing && aiIdentification && aiIdentification.trim() && (
            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                AI Analysis
              </label>
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3 min-h-[60px]">
                <div className="text-sm text-blue-700 dark:text-blue-300">
                  {aiIdentification}
                </div>
              </div>
            </div>
          )}
          
          {/* Voice Recording Status */}
          {isRecording && (
            <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3">
              <div className="flex items-center gap-2 text-sm text-red-700 dark:text-red-400">
                <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>
                Recording voice context: {formatTime(recordingTime)}
              </div>
            </div>
          )}
          
          {audioBlob && (
            <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Mic className="w-4 h-4 text-green-600" />
                  <span className="text-sm font-medium text-green-700 dark:text-green-400">
                    Voice context recorded ({formatTime(recordingTime)})
                  </span>
                </div>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setAudioBlob(null);
                    setRecordingTime(0);
                  }}
                >
                  <X className="w-4 h-4" />
                </Button>
              </div>
            </div>
          )}
          
          {/* User Context Input - Separate from AI analysis */}
          <div className="space-y-2">
            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Your Context (Optional)
            </label>
            <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-xl p-3 flex items-center gap-2">
              <input
                ref={textareaRef}
                value={contextText}
                onChange={(e) => {
                  setContextText(e.target.value);
                  setUserHasTyped(true);
                }}
                placeholder="Add your own notes or context about this media..."
                className="flex-1 bg-transparent border-0 outline-none text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400"
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSubmit();
                  }
                }}
              />
              
              {/* Microphone button */}
              <button
                type="button"
                onClick={isRecording ? stopVoiceRecording : startVoiceRecording}
                className={`p-2 rounded-full transition-colors ${
                  isRecording 
                    ? 'bg-red-100 text-red-600 hover:bg-red-200 dark:bg-red-900/50 dark:text-red-400' 
                    : 'text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
                }`}
              >
                <Mic className={`w-4 h-4 ${isRecording ? 'animate-pulse' : ''}`} />
              </button>
              
              {/* Send button */}
              <button
                onClick={handleSubmit}
                disabled={createMediaNoteMutation.isPending || (!contextText.trim() && !audioBlob)}
                className="p-2 bg-blue-500 hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-full transition-colors"
              >
                {createMediaNoteMutation.isPending ? (
                  <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                ) : (
                  <Send className="w-4 h-4" />
                )}
              </button>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}```

### client/src/components/media-display.tsx
```typescript
import { useState } from "react";
import { Maximize2, Download, Share2, FileText, Image as ImageIcon, File } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent } from "@/components/ui/dialog";

interface MediaDisplayProps {
  mediaUrl: string;
  filename?: string;
  className?: string;
  showControls?: boolean;
}

export default function MediaDisplay({ mediaUrl, filename, className = "", showControls = true }: MediaDisplayProps) {
  const [isFullScreenOpen, setIsFullScreenOpen] = useState(false);
  
  if (!mediaUrl) return null;

  const isImage = mediaUrl.match(/\.(jpg|jpeg|png|gif|webp)$/i);
  const isPdf = mediaUrl.match(/\.pdf$/i);
  const isAudio = mediaUrl.match(/\.(mp3|wav|webm|ogg)$/i);
  
  const handleDownload = () => {
    const link = document.createElement('a');
    link.href = mediaUrl;
    link.download = filename || 'media-file';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleShare = async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: filename || 'Media from Mira',
          url: mediaUrl
        });
      } catch (error) {
        console.log('Share cancelled');
      }
    } else {
      // Fallback: copy to clipboard
      navigator.clipboard.writeText(mediaUrl);
    }
  };

  const renderThumbnail = () => {
    if (isImage) {
      return (
        <div className="relative group">
          <img 
            src={mediaUrl} 
            alt={filename || "Media"} 
            className={`rounded-lg object-cover cursor-pointer ${className}`}
            style={{ maxHeight: '200px', width: 'auto' }}
            onClick={() => setIsFullScreenOpen(true)}
            onError={(e) => {
              console.error('Image failed to load:', mediaUrl);
              const target = e.target as HTMLImageElement;
              target.style.display = 'none';
              target.parentElement?.insertAdjacentHTML('afterbegin', 
                '<div class="bg-gray-100 border-2 border-dashed border-gray-300 rounded-lg p-4 text-center text-gray-500">Image failed to load</div>'
              );
            }}
            onLoad={() => {
              console.log('Image loaded successfully:', mediaUrl);
            }}
          />
          {showControls && (
            <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-1">
              <Button
                size="sm"
                variant="secondary"
                className="h-8 w-8 p-0 bg-black/50 hover:bg-black/70 text-white border-0"
                onClick={(e) => {
                  e.stopPropagation();
                  setIsFullScreenOpen(true);
                }}
              >
                <Maximize2 className="h-4 w-4" />
              </Button>
              <Button
                size="sm"
                variant="secondary"
                className="h-8 w-8 p-0 bg-black/50 hover:bg-black/70 text-white border-0"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDownload();
                }}
              >
                <Download className="h-4 w-4" />
              </Button>
              <Button
                size="sm"
                variant="secondary"
                className="h-8 w-8 p-0 bg-black/50 hover:bg-black/70 text-white border-0"
                onClick={(e) => {
                  e.stopPropagation();
                  handleShare();
                }}
              >
                <Share2 className="h-4 w-4" />
              </Button>
            </div>
          )}
        </div>
      );
    }

    if (isPdf) {
      return (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 flex items-center gap-3 cursor-pointer hover:bg-red-100" onClick={() => window.open(mediaUrl, '_blank')}>
          <FileText className="h-8 w-8 text-red-600" />
          <div className="flex-1">
            <div className="font-medium text-sm">{filename || 'PDF Document'}</div>
            <div className="text-xs text-gray-500">Click to open</div>
          </div>
          {showControls && (
            <div className="flex gap-1">
              <Button
                size="sm"
                variant="outline"
                className="h-8 w-8 p-0"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDownload();
                }}
              >
                <Download className="h-4 w-4" />
              </Button>
              <Button
                size="sm"
                variant="outline"
                className="h-8 w-8 p-0"
                onClick={(e) => {
                  e.stopPropagation();
                  handleShare();
                }}
              >
                <Share2 className="h-4 w-4" />
              </Button>
            </div>
          )}
        </div>
      );
    }

    if (isAudio) {
      return (
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
          <div className="flex items-center gap-3 mb-2">
            <div className="h-8 w-8 bg-blue-600 rounded-full flex items-center justify-center">
              <span className="text-white text-xs font-bold">♪</span>
            </div>
            <div className="flex-1">
              <div className="font-medium text-sm">{filename || 'Audio Recording'}</div>
            </div>
            {showControls && (
              <div className="flex gap-1">
                <Button
                  size="sm"
                  variant="outline"
                  className="h-8 w-8 p-0"
                  onClick={handleDownload}
                >
                  <Download className="h-4 w-4" />
                </Button>
                <Button
                  size="sm"
                  variant="outline"
                  className="h-8 w-8 p-0"
                  onClick={handleShare}
                >
                  <Share2 className="h-4 w-4" />
                </Button>
              </div>
            )}
          </div>
          <audio controls className="w-full">
            <source src={mediaUrl} type="audio/webm" />
            <source src={mediaUrl} type="audio/mp3" />
            Your browser does not support the audio element.
          </audio>
        </div>
      );
    }

    // Generic file
    return (
      <div className="bg-gray-50 border border-gray-200 rounded-lg p-4 flex items-center gap-3 cursor-pointer hover:bg-gray-100" onClick={() => window.open(mediaUrl, '_blank')}>
        <File className="h-8 w-8 text-gray-600" />
        <div className="flex-1">
          <div className="font-medium text-sm">{filename || 'File'}</div>
          <div className="text-xs text-gray-500">Click to open</div>
        </div>
        {showControls && (
          <div className="flex gap-1">
            <Button
              size="sm"
              variant="outline"
              className="h-8 w-8 p-0"
              onClick={(e) => {
                e.stopPropagation();
                handleDownload();
              }}
            >
              <Download className="h-4 w-4" />
            </Button>
            <Button
              size="sm"
              variant="outline"
              className="h-8 w-8 p-0"
              onClick={(e) => {
                e.stopPropagation();
                handleShare();
              }}
            >
              <Share2 className="h-4 w-4" />
            </Button>
          </div>
        )}
      </div>
    );
  };

  return (
    <>
      {renderThumbnail()}
      
      {/* Full Screen Modal for Images */}
      {isImage && (
        <Dialog open={isFullScreenOpen} onOpenChange={setIsFullScreenOpen}>
          <DialogContent className="max-w-[95vw] max-h-[95vh] p-0 bg-black/90">
            <div className="relative flex items-center justify-center min-h-[400px]">
              <img 
                src={mediaUrl} 
                alt={filename || "Media"} 
                className="max-w-full max-h-[90vh] object-contain"
              />
              <div className="absolute top-4 right-4 flex gap-2">
                <Button
                  size="sm"
                  variant="secondary"
                  className="bg-black/50 hover:bg-black/70 text-white border-0"
                  onClick={handleDownload}
                >
                  <Download className="h-4 w-4 mr-2" />
                  Download
                </Button>
                <Button
                  size="sm"
                  variant="secondary"
                  className="bg-black/50 hover:bg-black/70 text-white border-0"
                  onClick={handleShare}
                >
                  <Share2 className="h-4 w-4 mr-2" />
                  Share
                </Button>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      )}
    </>
  );
}```

### client/src/components/note-card.tsx
```typescript
import { useState, useRef } from "react";
import type { NoteWithTodos } from "@shared/schema";
import { formatDistanceToNow } from "date-fns";
import { Play, Pause, CheckCircle, Folder, Share2, Star, Calendar, MapPin, Phone, ShoppingCart, Copy, Edit3, Archive, ChevronRight, ExternalLink, X, Check, ArrowUpRight, MoreHorizontal, Plus, Trash2, CheckCircle2, Loader2, Bell, Zap, ArrowRight, Info, Clock } from "lucide-react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuSeparator } from "@/components/ui/dropdown-menu";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import AIProcessingIndicator from "@/components/ai-processing-indicator";
import MediaDisplay from "@/components/media-display";
import { ReminderDialog } from "@/components/reminder-dialog";

// Voice Note Player Component
interface VoiceNotePlayerProps {
  note: NoteWithTodos;
}

function VoiceNotePlayer({ note }: VoiceNotePlayerProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const audioRef = useRef<HTMLAudioElement>(null);

  const togglePlayback = () => {
    if (!audioRef.current || !note.audioUrl) return;

    if (isPlaying) {
      audioRef.current.pause();
      setIsPlaying(false);
    } else {
      audioRef.current.play();
      setIsPlaying(true);
    }
  };

  const handleTimeUpdate = () => {
    if (audioRef.current) {
      setCurrentTime(audioRef.current.currentTime);
    }
  };

  const handleLoadedMetadata = () => {
    if (audioRef.current) {
      setDuration(audioRef.current.duration);
    }
  };

  const generateWaveform = () => {
    const text = note.transcription || note.content;
    const chars = text.split('');
    return Array.from({ length: 24 }, (_, i) => {
      const charCode = chars[i % chars.length]?.charCodeAt(0) || 65;
      const amplitude = (charCode % 100) / 100 * 0.6 + 0.4;
      return amplitude;
    });
  };

  const waveformData = generateWaveform();
  const formatTime = (time: number) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return (
    <div className="flex items-center space-x-3 mb-3">
      {note.audioUrl && (
        <audio
          ref={audioRef}
          src={note.audioUrl}
          onTimeUpdate={handleTimeUpdate}
          onLoadedMetadata={handleLoadedMetadata}
          onEnded={() => setIsPlaying(false)}
          preload="metadata"
        />
      )}
      <button 
        onClick={togglePlayback}
        disabled={!note.audioUrl}
        className="w-8 h-8 rounded-full bg-blue-500 hover:bg-blue-600 transition-colors flex items-center justify-center disabled:opacity-50"
      >
        {isPlaying ? (
          <Pause className="w-3 h-3 text-white" />
        ) : (
          <Play className="w-3 h-3 text-white ml-0.5" />
        )}
      </button>
      <div className="flex-1 h-6 flex items-end justify-start space-x-0.5">
        {waveformData.map((amplitude, i) => {
          const progress = duration > 0 ? currentTime / duration : 0;
          const isActive = i / waveformData.length <= progress;
          return (
            <div
              key={i}
              className={`w-0.5 rounded-full transition-colors ${
                isActive 
                  ? 'bg-gradient-to-t from-blue-700 to-blue-500' 
                  : 'bg-gradient-to-t from-blue-600 to-blue-400 opacity-70'
              }`}
              style={{
                height: `${Math.max(2, amplitude * 20)}px`
              }}
            />
          );
        })}
      </div>
      <span className="text-xs font-mono text-blue-600 font-medium">
        {duration > 0 && isFinite(duration) && !isNaN(duration) ? formatTime(duration) : 'Voice note'}
      </span>
    </div>
  );
}

interface NoteCardProps {
  note: NoteWithTodos;
  onTodoModalClose?: () => void;
}

const getModeLabel = (mode: string) => {
  switch (mode) {
    case "voice":
      return "Voice Note";
    case "image":
      return "Image Note";
    default:
      return "Text Note";
  }
};

const getModeColor = (mode: string) => {
  switch (mode) {
    case "voice":
      return "bg-[hsl(var(--ocean-blue))]";
    case "image":
      return "bg-[hsl(var(--coral-accent))]";
    default:
      return "bg-[hsl(var(--sea-green))]";
  }
};

// Follow-up questions should only come from AI processing, not client-side generation
const getAIFollowUpQuestions = (richContext: any) => {
  if (!richContext) return [];
  
  try {
    const parsed = typeof richContext === 'string' ? JSON.parse(richContext) : richContext;
    return parsed.microQuestions || [];
  } catch {
    return [];
  }
};

export default function NoteCard({ note, onTodoModalClose }: NoteCardProps) {
  const timeAgo = formatDistanceToNow(new Date(note.createdAt), { addSuffix: true })
    .replace('about ', '').replace(' hours', 'h').replace(' hour', 'h')
    .replace(' minutes', 'm').replace(' minute', 'm').replace(' days', 'd')
    .replace(' day', 'd').replace(' weeks', 'w').replace(' week', 'w')
    .replace('less than a minute', 'less than a min')
    .replace('less than am', 'less than a min');
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  const [showTodosModal, setShowTodosModal] = useState(false);
  const [showReminderDialog, setShowReminderDialog] = useState(false);

  const followUpQuestions = getAIFollowUpQuestions(note.richContext);

  // Helper to format content with proper title length limits
  const formatContent = (content: string) => {
    const lines = content.split('\n').filter(line => line.trim().length > 0);
    const bullets = lines.filter(line => line.trim().match(/^[-•*]\s+/));

    let firstLine = lines[0] || '';

    // Remove AI partner indicators from title
    firstLine = firstLine.replace(/^\[claude\]\s*/i, '').replace(/^\[openai\]\s*/i, '').replace(/^\[gpt\]\s*/i, '');

    const hasDescription = lines.length > 1 || bullets.length >= 2;

    // Title character limits: 1 line (~50 chars) with description, 3 lines (~150 chars) without
    const maxTitleLength = hasDescription ? 50 : 150;
    const title = firstLine.length > maxTitleLength 
      ? firstLine.substring(0, maxTitleLength).trim()
      : firstLine;

    if (bullets.length >= 2) {
      const displayBullets = bullets.slice(0, 3).map(b => b.replace(/^[-•*]\s+/, '').trim());
      return {
        hasStructure: true,
        title,
        description: '',
        bullets: displayBullets
      };
    }

    // For longer content, split into title and description
    if (lines.length > 1) {
      const description = lines.slice(1).join(' ').substring(0, 120);
      return {
        hasStructure: false,
        title,
        description: description.length >= 120 ? description.trim() : description,
        bullets: []
      };
    }

    return {
      hasStructure: false,
      title,
      description: '',
      bullets: []
    };
  };

  const formattedContent = formatContent(note.content);

  // Detect AI partner used
  const getAIPartner = (content: string) => {
    const lowerContent = content.toLowerCase();
    if (lowerContent.includes('[claude]') || note.mode === 'enhanced') {
      return 'claude';
    }
    if (lowerContent.includes('[openai]') || lowerContent.includes('[gpt]')) {
      return 'openai';
    }
    return null;
  };

  const aiPartner = getAIPartner(note.content);

  // Calculate todo progress
  const todoProgress = () => {
    if (note.todos.length === 0) return null;

    const completed = note.todos.filter(todo => todo.completed).length;
    const total = note.todos.length;
    const percentage = (completed / total) * 100;

    let color = '';
    let icon = CheckCircle;

    if (percentage === 100) {
      color = 'text-green-600 bg-green-50';
      icon = CheckCircle2;
    } else if (percentage >= 51) {
      color = 'text-yellow-600 bg-yellow-50';
    } else {
      color = 'text-red-600 bg-red-50';
    }

    return {
      completed,
      total,
      percentage,
      color,
      icon
    };
  };

  const progress = todoProgress();

  const handleCardClick = () => {
    setLocation(`/notes/${note.id}`);
  };

  // Mutation to delete note
  const deleteNoteMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("DELETE", `/api/notes/${note.id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      toast({
        description: "Note deleted successfully!",
      });
    },
    onError: () => {
      toast({
        description: "Failed to delete note",
        variant: "destructive",
      });
    },
  });

  const handleDeleteNote = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card click
    if (confirm("Are you sure you want to delete this note? This action cannot be undone.")) {
      deleteNoteMutation.mutate();
    }
  };

  const toggleTodoMutation = useMutation({
    mutationFn: async ({ todoId, completed }: { todoId: number; completed: boolean }) => {
      const response = await apiRequest("PATCH", `/api/todos/${todoId}`, { completed });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  const handleTodoToggle = (todo: any) => {
    toggleTodoMutation.mutate({ 
      todoId: todo.id, 
      completed: !todo.completed 
    });
  };

  // Parse rich context data
  const parseRichContext = (richContext: string | null) => {
    if (!richContext) return null;
    try {
      return JSON.parse(richContext);
    } catch {
      return null;
    }
  };

  const richContextData = parseRichContext(note.richContext);

  // Get next steps for card using new hierarchy
  const getNextStepsForCard = (richContext: any) => {
    if (!richContext) return [];
    
    const filterCriticalQuestions = (microQuestions: string[]) => {
      if (!microQuestions || microQuestions.length === 0) return [];
      
      const criticalPatterns = [
        /what (is|are) (this|that|it|these)/i,
        /where (is|are|can I find|do I get)/i,
        /who (makes|sells|provides|offers)/i,
      ];
      
      return microQuestions.filter(q => 
        criticalPatterns.some(pattern => pattern.test(q))
      ).slice(0, 2);
    };

    const filterTimeSensitive = (nextSteps: string[]) => {
      if (!nextSteps || nextSteps.length === 0) return [];
      
      return nextSteps.filter(step => 
        /\b(today|tomorrow|urgent|deadline|asap|immediately|now)\b/i.test(step)
      ).slice(0, 2);
    };

    const critical = filterCriticalQuestions(richContext.microQuestions || []);
    const timeSensitive = filterTimeSensitive(richContext.nextSteps || []);
    const todos = note.todos || [];
    
    // Priority 1: Critical questions (max 2)
    let items = [...critical.slice(0, 2)];
    
    // Priority 2: If < 2 critical, add time-sensitive (combined max 2)
    if (items.length < 2) {
      items = [...items, ...timeSensitive.slice(0, 2 - items.length)];
    }
    
    // Priority 3: If still < 4, add todos (combined max 4)
    if (items.length < 4) {
      const todoItems = todos.slice(0, 4 - items.length).map(todo => todo.title);
      items = [...items, ...todoItems];
    }
    
    return items.slice(0, 4);
  };

  const nextStepsForCard = getNextStepsForCard(richContextData);

  // Parse smart actions from aiSuggestion
  const parseSmartActions = (aiSuggestion: string | null) => {
    if (!aiSuggestion) return [];

    const actions = [];
    const suggestions = aiSuggestion.split(',').map(s => s.trim());

    for (const suggestion of suggestions) {
      if (suggestion.includes('Add to Calendar') || suggestion.includes('calendar')) {
        actions.push({ type: 'calendar', label: 'Add to Calendar', icon: Calendar });
      } else if (suggestion.includes('Share') || suggestion.includes('share')) {
        actions.push({ type: 'share', label: 'Share', icon: Share2 });
      } else if (suggestion.includes('Reminder') || suggestion.includes('reminder')) {
        actions.push({ type: 'reminder', label: 'Set Reminder', icon: Bell });
      }
    }

    return actions;
  };

  const smartActions = parseSmartActions(note.aiSuggestion);

  const handleSmartAction = (action: any, e: React.MouseEvent) => {
    e.stopPropagation();

    switch (action.type) {
      case 'calendar':
        // Create calendar event
        const calendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(note.content)}&details=${encodeURIComponent(note.aiContext || '')}`;
        window.open(calendarUrl, '_blank');
        break;
      case 'share':
        handleShare(e);
        break;
      case 'reminder':
        // Set reminder logic
        toast({
          description: "Reminder functionality coming soon!",
        });
        break;
    }
  };

  const handleShare = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card click

    const shareText = formatNoteForSharing(note);

    if (navigator.share) {
      navigator.share({
        title: `Note from ${formatDistanceToNow(new Date(note.createdAt), { addSuffix: true })}`,
        text: shareText,
      }).catch(console.error);
    } else {
      // Fallback: copy to clipboard
      navigator.clipboard.writeText(shareText).then(() => {
        toast({
          description: "Note copied to clipboard!",
        });
      }).catch(() => {
        toast({
          description: "Failed to copy note",
          variant: "destructive",
        });
      });
    }
  };

  const formatNoteForSharing = (note: NoteWithTodos) => {
    let shareText = `📝 Note from ${formatDistanceToNow(new Date(note.createdAt), { addSuffix: true })}\n\n`;

    shareText += `${note.content}\n\n`;

    if (note.aiContext) {
      shareText += `💡 Context:\n${note.aiContext}\n\n`;
    }

    if (note.aiSuggestion) {
      shareText += `🤔 Follow-up:\n${note.aiSuggestion}\n\n`;
    }

    if (note.todos && note.todos.length > 0) {
      shareText += `✅ Action Items:\n`;
      note.todos.forEach((todo, index) => {
        const status = todo.completed ? '✓' : '○';
        shareText += `${status} ${todo.title}\n`;
      });
      shareText += '\n';
    }

    if (note.collection) {
      shareText += `📁 Collection: ${note.collection.name}\n\n`;
    }

    shareText += `Shared from Mira`;

    return shareText;
  };

  return (
    <div className="note-card animate-fadeIn cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors border-b border-gray-100 dark:border-gray-800 py-4 w-full" onClick={handleCardClick}>
      <div className="flex items-start justify-between mb-2">
        <div className="flex items-center space-x-2">
          <span className="text-xs text-[hsl(var(--muted-foreground))]">{timeAgo}</span>
          <div className={`w-2 h-2 ${getModeColor(note.mode)} rounded-full`}></div>
        </div>
        <div className="flex items-center gap-3">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <button
                onClick={(e) => e.stopPropagation()}
                className="w-6 h-6 rounded-full bg-[#f9fafb] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
                title="More options"
              >
                <MoreHorizontal className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-48">
              <DropdownMenuItem className="text-xs text-gray-500">
                Note ID: #{note.id}
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem onClick={handleShare}>
                <ArrowUpRight className="w-4 h-4 mr-2" />
                Share Note
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Star className="w-4 h-4 mr-2" />
                Star Note
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Plus className="w-4 h-4 mr-2" />
                Add to Collection
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <Copy className="w-4 h-4 mr-2" />
                Duplicate
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Archive className="w-4 h-4 mr-2" />
                Archive
              </DropdownMenuItem>
              <DropdownMenuItem 
                className="text-red-600"
                onClick={handleDeleteNote}
                disabled={deleteNoteMutation.isPending}
              >
                <Trash2 className="w-4 h-4 mr-2" />
                {deleteNoteMutation.isPending ? 'Deleting...' : 'Delete'}
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <button
            onClick={(e) => {
              e.stopPropagation();
              setShowReminderDialog(true);
            }}
            className="w-6 h-6 rounded-full bg-[hsl(var(--muted))] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
            title="Set reminder"
          >
            <Clock className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
          </button>
        </div>
      </div>
      {/* Subtle processing indicator */}
      {note.isProcessing && (
        <div className="mb-2 flex items-center space-x-2 text-xs text-muted-foreground">
          <div className="w-1 h-1 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
          <div className="w-1 h-1 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
          <div className="w-1 h-1 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
          <span className="opacity-60">AI processing</span>
        </div>
      )}

      {/* iOS Notes-style clean content display */}
      <div className="mb-3">
        {/* Always show note content with fallback logic */}
        <div className="text-base leading-relaxed text-gray-900 line-clamp-3">
          {note.content || note.aiGeneratedTitle || 'No content available'}
        </div>
      </div>

      {/* Media Display */}
      {note.mediaUrl && (
        <MediaDisplay mediaUrl={note.mediaUrl} />
      )}

      {/* Enhanced Voice Note Display */}
      {note.mode === 'voice' && note.transcription && (
        <VoiceNotePlayer note={note} />
      )}


      {/* V2 Intelligence Content - Next Steps Only (no redundant AI context) */}
      {nextStepsForCard.length > 0 && (
        <div className="mb-3">
          {/* Next Steps */}
          <div>
            <div className="flex items-center space-x-1 mb-2">
              <ArrowRight className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
              <span className="text-xs font-medium text-[hsl(var(--muted-foreground))]">Suggested</span>
            </div>
            <div className="space-y-1">
              {nextStepsForCard.map((step: string, index: number) => (
                <div
                  key={index}
                  className="flex items-start space-x-2 text-xs p-2 bg-blue-50 rounded-md"
                >
                  <span className="text-blue-600 mt-0.5 flex-shrink-0">•</span>
                  <span className="text-gray-700">{step}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Recommended Actions with Links */}
      {richContextData?.recommendedActions && richContextData.recommendedActions.length > 0 && (
        <div className="mb-3">
          <div className="flex items-center space-x-1 mb-2">
            <Info className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
            <span className="text-xs font-medium text-[hsl(var(--muted-foreground))]">Suggestions</span>
          </div>
          <div className="space-y-2">
            {richContextData.recommendedActions.map((action: any, index: number) => (
              <div key={index} className="p-2 bg-[hsl(var(--muted))] rounded-md">
                <h4 className="text-xs font-medium text-[hsl(var(--foreground))] mb-1">{action.title}</h4>
                <p className="text-xs text-[hsl(var(--muted-foreground))] mb-2">{action.description}</p>
                {action.links && action.links.length > 0 && (
                  <div className="flex flex-wrap gap-1">
                    {action.links.map((link: any, linkIndex: number) => (
                      <button
                        key={linkIndex}
                        onClick={(e) => {
                          e.stopPropagation();
                          window.open(link.url, '_blank');
                        }}
                        className="flex items-center space-x-1 px-2 py-1 bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] rounded text-xs hover:bg-[hsl(var(--primary))]/90 transition-colors"
                      >
                        <ExternalLink className="w-3 h-3" />
                        <span>{link.title}</span>
                      </button>
                    ))}
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Quick Insights */}
      {richContextData?.quickInsights && richContextData.quickInsights.length > 0 && (
        <div className="mb-3">
          <div className="space-y-1">
            {richContextData.quickInsights.map((insight: string, index: number) => (
              <div
                key={index}
                className="text-xs px-2 py-1 bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] rounded-md italic"
              >
                💡 {insight}
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Follow-up Questions */}
      {followUpQuestions.length > 0 && (
        <div className="pt-3 border-t border-[hsl(var(--border))]">
          <div className="space-y-2">
            <p className="text-xs font-medium text-[hsl(var(--muted-foreground))] mb-2">Follow-up questions:</p>
            {followUpQuestions.map((question, index) => (
              <div
                key={index}
                className="text-xs px-2 py-1 bg-[hsl(var(--muted))] rounded-md text-[#4f453b]"
              >
                {question}
              </div>
            ))}
          </div>
        </div>
      )}
      <div className="flex items-center justify-between mt-3 relative">
        <div className="flex items-center space-x-4 text-[12px]">
          {progress && (
            <button 
              onClick={(e) => {
                e.stopPropagation();
                setShowTodosModal(true);
              }}
              className="flex items-center space-x-2 hover:bg-[hsl(var(--muted))] rounded p-1 -m-1 transition-colors"
            >
              <progress.icon className={`w-4 h-4 ${progress.color.split(' ')[0]}`} />
              <span className={`text-[12px] px-2 py-1 rounded-full ${progress.color}`}>
                {progress.completed}/{progress.total} to-do{progress.total !== 1 ? "s" : ""}
              </span>
            </button>
          )}

          {note.collection && (
            <div className="flex items-center space-x-2">
              <Folder className="w-4 h-4 text-[hsl(var(--sand-taupe))]" />
              <span className="text-[hsl(var(--muted-foreground))] text-[12px]">{note.collection.name}</span>
            </div>
          )}
        </div>

        <div className="flex items-center gap-2">
          {/* AI Partner Logo - Aligned with text baseline */}
          {aiPartner && (
            <div className="flex items-center">
              {aiPartner === 'claude' && (
                <div className="h-3 opacity-[0.3] hover:opacity-40 transition-opacity" title="Enhanced by Claude Sonnet 4">
                  <img 
                    src="/claude-logo.png" 
                    alt="Claude" 
                    className="h-full w-auto object-contain"
                  />
                </div>
              )}
              {aiPartner === 'openai' && (
                <div className="w-3 h-3 bg-gradient-to-br from-emerald-400 to-emerald-600 rounded-full flex items-center justify-center opacity-[0.3] hover:opacity-40 transition-opacity" title="Enhanced by GPT-4o">
                  <span className="text-white text-[5px] font-bold">AI</span>
                </div>
              )}
            </div>
          )}

          {/* AI enhanced indicator moved to bottom right */}
          {!note.isProcessing && note.aiEnhanced && (
            <div className="flex items-center space-x-1 text-xs text-green-600">
              <CheckCircle2 className="w-3 h-3" />
              <span className="opacity-25">AI enhanced</span>
            </div>
          )}
        </div>
      </div>
      {/* Todos Modal */}
      <Dialog open={showTodosModal} onOpenChange={(open) => {
        setShowTodosModal(open);
        if (!open && onTodoModalClose) {
          onTodoModalClose();
        }
      }}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>To-Dos from this note</DialogTitle>
          </DialogHeader>
          <div className="space-y-2 max-h-80 overflow-y-auto">
            {note.todos.map((todo, index) => (
              <div key={index} className="flex items-start space-x-3 p-2 bg-[hsl(var(--muted))] rounded-lg">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleTodoToggle(todo);
                  }}
                  disabled={toggleTodoMutation.isPending}
                  className={`w-4 h-4 rounded-full border-2 flex items-center justify-center mt-0.5 cursor-pointer hover:scale-110 transition-transform ${
                    todo.completed 
                      ? 'bg-[hsl(var(--seafoam-green))] border-[hsl(var(--seafoam-green))]'
                      : 'border-[hsl(var(--muted-foreground))] hover:border-[hsl(var(--seafoam-green))]'
                  }`}
                >
                  {todo.completed && <Check className="w-2.5 h-2.5 text-white" />}
                </button>
                <div className="flex-1 min-w-0">
                  <p className={`text-sm ${
                    todo.completed 
                      ? 'line-through text-[hsl(var(--muted-foreground))]' 
                      : 'text-[hsl(var(--foreground))]'
                  }`}>
                    {todo.title}
                  </p>
                  {todo.priority === 'urgent' && (
                    <span className="text-xs text-[#8B2635] font-medium">Urgent</span>
                  )}
                </div>
              </div>
            ))}
          </div>
        </DialogContent>
      </Dialog>

      {/* Reminder Dialog */}
      <ReminderDialog
        open={showReminderDialog}
        onOpenChange={setShowReminderDialog}
        prePopulatedText={`Reminder: ${formattedContent.title}`}
        onReminderUpdated={() => {
          queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
          toast({
            description: "Reminder created successfully!",
          });
        }}
      />
    </div>
  );
}```

### client/src/components/NoteDetailSimple.tsx
```typescript
import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { useParams, useLocation } from 'wouter';
import { ArrowLeft } from 'lucide-react';
import { NoteWithTodos } from '@shared/schema';
import { marked } from 'marked';
import InputBar from '@/components/input-bar';

// Helper function to convert markdown to HTML
function mdToHtml(markdown: string): string {
  return marked(markdown) as string;
}

export default function NoteDetailSimple() {
  const { id } = useParams<{ id: string }>();
  const [, setLocation] = useLocation();

  const { data: note, isLoading, error } = useQuery<NoteWithTodos>({
    queryKey: [`/api/notes/${id}`],
    enabled: !!id,
    staleTime: 60000, // Cache individual notes for 1 minute
    gcTime: 300000, // Keep in cache for 5 minutes
  });

  if (isLoading) {
    return (
      <div className="min-h-screen bg-[#f1efe8] pb-20">
        <div className="p-4">
          <div className="animate-pulse">
            <div className="h-6 bg-gray-200 rounded w-1/3 mb-4"></div>
            <div className="h-4 bg-gray-200 rounded w-full mb-2"></div>
            <div className="h-4 bg-gray-200 rounded w-3/4"></div>
          </div>
        </div>
      </div>
    );
  }

  if (error || !note) {
    return (
      <div className="min-h-screen bg-[#f1efe8] pb-20">
        <div className="p-4">
          <button
            onClick={() => setLocation('/')}
            className="flex items-center gap-2 mb-4 text-gray-600 hover:text-gray-800"
          >
            <ArrowLeft className="w-4 h-4" />
            Back to Notes
          </button>
          <div className="text-center py-8">
            <h1 className="text-xl font-semibold mb-2">Note not found</h1>
            <p className="text-gray-600">This note may have been deleted or moved.</p>
          </div>
        </div>
      </div>
    );
  }

  // Parse richContext with robust fallbacks
  const rc = note.richContext ? (() => {
    try {
      return JSON.parse(note.richContext);
    } catch {
      return {};
    }
  })() : {};
  
  const safe = {
    title: rc.title || note.aiGeneratedTitle || note.content.split('\n')[0] || 'Untitled',
    original: rc.original || ((rc.title || '') !== note.content ? note.content : ''),
    aiBody: rc.aiBody || '',
    perspective: rc.perspective || ''
  };

  return (
    <div className="min-h-screen bg-[#f1efe8] pb-20">
      {/* Header */}
      <div className="sticky top-0 bg-white border-b border-gray-200 px-4 py-3">
        <div className="flex items-center gap-3">
          <button
            onClick={() => setLocation('/')}
            className="w-8 h-8 flex items-center justify-center rounded-full bg-gray-100 hover:bg-gray-200"
          >
            <ArrowLeft className="w-4 h-4" />
          </button>
          <div className="flex-1">
            <h1 className="text-lg font-semibold text-gray-900">{safe.title}</h1>
            {note.isProcessing && (
              <div className="flex items-center gap-1 mt-1">
                <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                <span className="text-xs text-gray-500">AI processing...</span>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Content */}
      <div className="space-y-6 px-4 py-6">
        {/* Original content if different from title */}
        {safe.original && (
          <div className="bg-blue-50 rounded p-4 text-sm whitespace-pre-wrap">
            {safe.original}
          </div>
        )}

        {/* AI body */}
        {safe.aiBody && (
          <div className="prose whitespace-pre-wrap" 
               dangerouslySetInnerHTML={{__html: mdToHtml(safe.aiBody)}} />
        )}

        {/* Perspective */}
        {safe.perspective && (
          <p className="text-xs text-gray-500 whitespace-pre-wrap">{safe.perspective}</p>
        )}
      </div>
    </div>
  );
}```

### client/src/components/reminder-dialog.tsx
```typescript
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { ReminderInput } from './reminder-input';
import type { Todo } from '@shared/schema';

interface ReminderDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  existingReminder?: Todo | null;
  onReminderUpdated?: () => void;
  prePopulatedText?: string;
}

export function ReminderDialog({ 
  open, 
  onOpenChange, 
  existingReminder,
  onReminderUpdated,
  prePopulatedText
}: ReminderDialogProps) {
  
  const handleClose = () => {
    // Don't trigger onReminderUpdated when just closing the dialog
    onOpenChange(false);
  };

  const handleReminderCreated = () => {
    onReminderUpdated?.();
    onOpenChange(false);
  };

  const handleReminderUpdate = () => {
    onReminderUpdated?.();
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={(open) => !open && handleClose()}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>
            {existingReminder ? 'Update Reminder' : 'Create Reminder'}
          </DialogTitle>
        </DialogHeader>

        <ReminderInput
          initialValue={existingReminder?.title || prePopulatedText || ''}
          existingReminder={existingReminder}
          onReminderCreated={handleReminderCreated}
          onUpdate={handleReminderUpdate}
          onDelete={handleReminderUpdate}
          onArchive={handleReminderUpdate}
        />
      </DialogContent>
    </Dialog>
  );
}```

### client/src/components/reminder-input.tsx
```typescript
import { useState, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card } from "@/components/ui/card";
import { Calendar, Mic, MoreHorizontal, Trash2, Archive } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useToast } from "@/hooks/use-toast";

interface ReminderInputProps {
  onReminderCreated?: (reminder: any) => void;
  initialValue?: string;
  existingReminder?: any;
  onUpdate?: (reminder: any) => void;
  onDelete?: (reminderId: number) => void;
  onArchive?: (reminderId: number) => void;
}

export function ReminderInput({ 
  onReminderCreated, 
  initialValue = "", 
  existingReminder,
  onUpdate,
  onDelete,
  onArchive
}: ReminderInputProps) {
  const [input, setInput] = useState(initialValue);
  const [isRecording, setIsRecording] = useState(false);
  const [loading, setLoading] = useState(false);
  const [parsedInfo, setParsedInfo] = useState<any>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();

  const parseReminderInput = async (text: string) => {
    if (!text.trim()) {
      setParsedInfo(null);
      return;
    }

    try {
      const response = await fetch('/api/reminders/parse', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: text })
      });

      if (response.ok) {
        const parsed = await response.json();
        setParsedInfo(parsed);
      }
    } catch (error) {
      console.error('Failed to parse reminder:', error);
    }
  };

  const handleInputChange = (value: string) => {
    setInput(value);
    // Debounce parsing
    setTimeout(() => parseReminderInput(value), 500);
  };

  const createReminder = async () => {
    if (!input.trim()) return;

    setLoading(true);
    try {
      const response = await fetch('/api/reminders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          content: input,
          parsedInfo: parsedInfo
        })
      });

      if (response.ok) {
        const reminder = await response.json();
        onReminderCreated?.(reminder);
        setInput("");
        setParsedInfo(null);
        toast({
          title: "Reminder created",
          description: parsedInfo?.timeString ? `Scheduled for ${parsedInfo.timeString}` : undefined
        });
      } else {
        throw new Error('Failed to create reminder');
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to create reminder",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  const generateCalendarLink = () => {
    if (!existingReminder || !parsedInfo?.dueTime) return;

    const startTime = new Date(parsedInfo.dueTime);
    const endTime = new Date(startTime.getTime() + (30 * 60 * 1000)); // 30 min default

    const calendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(existingReminder.title)}&dates=${startTime.toISOString().replace(/[-:]/g, '').split('.')[0]}Z/${endTime.toISOString().replace(/[-:]/g, '').split('.')[0]}Z&details=${encodeURIComponent('Reminder from Mira')}`;
    
    window.open(calendarUrl, '_blank');
  };

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      setIsRecording(true);
      
      // Voice recording implementation would go here
      toast({
        title: "Voice recording",
        description: "Voice input feature coming soon"
      });
      
      setTimeout(() => {
        setIsRecording(false);
        stream.getTracks().forEach(track => track.stop());
      }, 2000);
    } catch (error) {
      toast({
        title: "Microphone access denied",
        description: "Please allow microphone access for voice input",
        variant: "destructive"
      });
    }
  };

  return (
    <div className="space-y-3">
      {/* Header with menu */}
      {existingReminder && (
        <div className="flex justify-end">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                <MoreHorizontal className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={generateCalendarLink}>
                <Calendar className="h-4 w-4 mr-2" />
                Add to Calendar
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => onArchive?.(existingReminder.id)}>
                <Archive className="h-4 w-4 mr-2" />
                Archive
              </DropdownMenuItem>
              <DropdownMenuItem 
                onClick={() => onDelete?.(existingReminder.id)}
                className="text-red-600"
              >
                <Trash2 className="h-4 w-4 mr-2" />
                Delete
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      )}

      {/* Input Bar */}
      <div className="flex gap-2">
        <div className="flex-1 relative">
          <Input
            ref={inputRef}
            value={input}
            onChange={(e) => handleInputChange(e.target.value)}
            placeholder={existingReminder ? "Update reminder..." : "Type or speak your reminder..."}
            onKeyDown={(e) => e.key === 'Enter' && !existingReminder && createReminder()}
            className="pr-12"
          />
          <div className="absolute right-2 top-1/2 -translate-y-1/2">
            <Button
              variant="ghost"
              size="sm"
              onClick={startRecording}
              className="h-8 w-8 p-0 rounded-full transition-colors hover:opacity-90 text-[#374252]"
              style={{ backgroundColor: isRecording ? '#ef4444' : '#9bb8d3' }}
            >
              <Mic className="h-4 w-4" />
            </Button>
          </div>
        </div>
        
        {!existingReminder && (
          <Button 
            onClick={createReminder} 
            disabled={loading || !input.trim()}
            size="sm"
          >
            {loading ? "Adding..." : "Add"}
          </Button>
        )}
      </div>

      {/* Existing Schedule Display for Reminders */}
      {existingReminder && existingReminder.plannedNotificationStructure && (
        <Card className="p-3 bg-blue-50 border-blue-200">
          <div className="text-sm space-y-1">
            <div className="font-medium text-blue-900">Current Reminder Schedule</div>
            {existingReminder.timeDue && (
              <div className="text-blue-700">
                📅 Due: {new Date(existingReminder.timeDue).toLocaleString()}
              </div>
            )}
            {existingReminder.plannedNotificationStructure.leadTime && (
              <div className="text-blue-700">
                🔔 Notify {existingReminder.plannedNotificationStructure.leadTime} minutes before
              </div>
            )}
            {existingReminder.plannedNotificationStructure.recurrence && (
              <div className="text-blue-700">
                🔄 {existingReminder.plannedNotificationStructure.recurrence}
              </div>
            )}
          </div>
        </Card>
      )}

      {/* Parsed Information Display */}
      {parsedInfo && (
        <Card className="p-3 bg-muted/50">
          <div className="text-sm space-y-1">
            {parsedInfo.timeString && (
              <div className="text-muted-foreground">
                📅 {parsedInfo.timeString}
              </div>
            )}
            {parsedInfo.leadTime && (
              <div className="text-muted-foreground">
                🔔 Notify {parsedInfo.leadTime} before
              </div>
            )}
            {parsedInfo.recurrence && (
              <div className="text-muted-foreground">
                🔄 {parsedInfo.recurrence}
              </div>
            )}
          </div>
        </Card>
      )}

      
    </div>
  );
}```

### client/src/components/reminder-settings.tsx
```typescript
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { Button } from "@/components/ui/button";
import { Settings, Save } from "lucide-react";
import { useToast } from "@/hooks/use-toast";

interface ReminderSettings {
  defaultLeadTimes: {
    general: number;
    pickup: number;
    appointment: number;
    medication: number;
    call: number;
    meeting: number;
    flight: number;
  };
  autoArchiveAfterDays: number;
  showOverdueReminders: boolean;
  enablePushNotifications: boolean;
}

const defaultSettings: ReminderSettings = {
  defaultLeadTimes: {
    general: 10,
    pickup: 10,
    appointment: 30,
    medication: 0,
    call: 5,
    meeting: 15,
    flight: 120
  },
  autoArchiveAfterDays: 1,
  showOverdueReminders: true,
  enablePushNotifications: true
};

export function ReminderSettings() {
  const [settings, setSettings] = useState<ReminderSettings>(defaultSettings);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const { toast } = useToast();

  useEffect(() => {
    loadSettings();
  }, []);

  const loadSettings = async () => {
    try {
      const response = await fetch('/api/user/reminder-settings');
      if (response.ok) {
        const data = await response.json();
        setSettings(data.reminderSettings || defaultSettings);
      }
    } catch (error) {
      console.error('Failed to load reminder settings:', error);
    } finally {
      setLoading(false);
    }
  };

  const saveSettings = async () => {
    setSaving(true);
    try {
      const response = await fetch('/api/user/reminder-settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ reminderSettings: settings })
      });

      if (response.ok) {
        toast({
          title: "Settings saved",
          description: "Your reminder preferences have been updated."
        });
      } else {
        throw new Error('Failed to save settings');
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to save reminder settings.",
        variant: "destructive"
      });
    } finally {
      setSaving(false);
    }
  };

  const updateLeadTime = (category: keyof ReminderSettings['defaultLeadTimes'], value: number) => {
    setSettings(prev => ({
      ...prev,
      defaultLeadTimes: {
        ...prev.defaultLeadTimes,
        [category]: value
      }
    }));
  };

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Settings className="h-5 w-5" />
            Reminder Settings
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-center py-4">Loading settings...</div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Settings className="h-5 w-5" />
          Reminder Settings
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Default Lead Times */}
        <div>
          <h3 className="font-medium mb-4">Default Notification Times (minutes before)</h3>
          <div className="grid grid-cols-2 gap-4">
            {Object.entries(settings.defaultLeadTimes).map(([category, minutes]) => (
              <div key={category} className="space-y-2">
                <Label className="capitalize">{category.replace(/([A-Z])/g, ' $1').trim()}</Label>
                <Input
                  type="number"
                  value={minutes}
                  onChange={(e) => updateLeadTime(category as any, parseInt(e.target.value) || 0)}
                  min="0"
                  max="1440"
                  className="w-full"
                />
              </div>
            ))}
          </div>
        </div>

        {/* Archive Settings */}
        <div className="space-y-4">
          <h3 className="font-medium">Archive Settings</h3>
          <div className="space-y-2">
            <Label>Auto-archive completed reminders after (days)</Label>
            <Input
              type="number"
              value={settings.autoArchiveAfterDays}
              onChange={(e) => setSettings(prev => ({
                ...prev,
                autoArchiveAfterDays: parseInt(e.target.value) || 1
              }))}
              min="0"
              max="30"
              className="w-32"
            />
          </div>
        </div>

        {/* Display Options */}
        <div className="space-y-4">
          <h3 className="font-medium">Display Options</h3>
          <div className="flex items-center justify-between">
            <Label>Show overdue reminders</Label>
            <Switch
              checked={settings.showOverdueReminders}
              onCheckedChange={(checked) => setSettings(prev => ({
                ...prev,
                showOverdueReminders: checked
              }))}
            />
          </div>
          <div className="flex items-center justify-between">
            <Label>Enable push notifications</Label>
            <Switch
              checked={settings.enablePushNotifications}
              onCheckedChange={(checked) => setSettings(prev => ({
                ...prev,
                enablePushNotifications: checked
              }))}
            />
          </div>
        </div>

        {/* Save Button */}
        <Button onClick={saveSettings} disabled={saving} className="w-full">
          <Save className="h-4 w-4 mr-2" />
          {saving ? 'Saving...' : 'Save Settings'}
        </Button>
      </CardContent>
    </Card>
  );
}```

### client/src/components/settings-modal.tsx
```typescript
import { ChevronLeft, Zap } from "lucide-react";
import { Switch } from "@/components/ui/switch";
import { useState } from "react";
import AIComparison from "./ai-comparison";
import BottomNavigation from "./bottom-navigation";


interface SettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
  activeTab: "activity" | "todos" | "collections";
  onTabChange: (tab: "activity" | "todos" | "collections") => void;
  onNewNote: () => void;
  onCloseCapture?: () => void;
}

export default function SettingsModal({ isOpen, onClose, activeTab, onTabChange, onNewNote, onCloseCapture }: SettingsModalProps) {
  const [showAIComparison, setShowAIComparison] = useState(false);

  if (showAIComparison) {
    return (
      <div className={`fixed inset-0 bg-white z-40 ${
        isOpen ? "block" : "hidden"
      }`}>
        <div className="mx-auto max-w-sm w-full h-full flex flex-col">
          <div className="safe-area-top"></div>
          
          <div className="flex items-center justify-between mb-4 px-4 pt-6">
            <h2 className="text-2xl font-serif font-medium">AI Comparison</h2>
            <button 
              onClick={() => setShowAIComparison(false)}
              className="p-2 hover:bg-[hsl(var(--muted))] rounded-lg"
            >
              <ChevronLeft className="w-5 h-5" />
            </button>
          </div>
          
          <div className="flex-1 overflow-y-auto pb-20">
            <AIComparison />
          </div>
          
          {/* Bottom Navigation */}
          <BottomNavigation 
            activeTab={activeTab} 
            onTabChange={(tab) => {
              onTabChange(tab);
              onClose();
            }}
            onNewNote={onNewNote}
            onSettings={onClose}
            onCloseCapture={onCloseCapture}
            hideAddButton={true}
          />
        </div>
      </div>
    );
  }

  return (
    <div className={`fixed inset-0 bg-white z-40 ${
      isOpen ? "block" : "hidden"
    }`}>
      {/* Mobile app container with max width */}
      <div className="mx-auto max-w-sm w-full h-full flex flex-col">
        <div className="safe-area-top"></div>
        
        <div className="flex items-center justify-between mb-4 px-4 pt-6">
          <h2 className="text-2xl font-serif font-medium">Settings</h2>
          <button 
            onClick={onClose}
            className="p-2 hover:bg-[hsl(var(--muted))] rounded-lg"
          >
            <ChevronLeft className="w-5 h-5" />
          </button>
        </div>
        
        <div className="flex-1 overflow-y-auto">
          <div className="p-4 space-y-6 pb-20">
            <div>
              <h3 className="text-lg font-semibold mb-4">AI & Voice</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">Auto-enhance notes</p>
                    <p className="text-sm text-[hsl(var(--ios-gray))]">Let AI improve your notes automatically</p>
                  </div>
                  <Switch defaultChecked />
                </div>
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">Emoji in titles</p>
                    <p className="text-sm text-[hsl(var(--ios-gray))]">Add emojis to note titles for visual clarity</p>
                  </div>
                  <Switch defaultChecked />
                </div>
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">Voice transcription</p>
                    <p className="text-sm text-[hsl(var(--ios-gray))]">Convert speech to text</p>
                  </div>
                  <Switch defaultChecked />
                </div>
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">Smart suggestions</p>
                    <p className="text-sm text-[hsl(var(--ios-gray))]">Get AI-powered follow-up suggestions</p>
                  </div>
                  <Switch defaultChecked />
                </div>
                
                <button 
                  onClick={() => setShowAIComparison(true)}
                  className="w-full flex items-center justify-between p-3 rounded-lg border border-gray-200 hover:bg-gray-50 transition-colors"
                >
                  <div className="flex items-center gap-3">
                    <Zap className="w-5 h-5 text-blue-500" />
                    <div className="text-left">
                      <p className="font-medium">AI Comparison Tool</p>
                      <p className="text-sm text-[hsl(var(--ios-gray))]">Compare OpenAI vs Claude results</p>
                    </div>
                  </div>
                  <ChevronLeft className="w-4 h-4 text-gray-400 rotate-180" />
                </button>
              </div>
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-4">Privacy</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">Local processing only</p>
                    <p className="text-sm text-[hsl(var(--ios-gray))]">Process data on device when possible</p>
                  </div>
                  <Switch />
                </div>
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">Analytics</p>
                    <p className="text-sm text-[hsl(var(--ios-gray))]">Help improve the app</p>
                  </div>
                  <Switch defaultChecked />
                </div>
              </div>
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-4">Storage</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">Auto-backup</p>
                    <p className="text-sm text-[hsl(var(--ios-gray))]">Backup your notes to cloud storage</p>
                  </div>
                  <Switch defaultChecked />
                </div>
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">Offline access</p>
                    <p className="text-sm text-[hsl(var(--ios-gray))]">Access notes without internet</p>
                  </div>
                  <Switch defaultChecked />
                </div>
              </div>
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-4">Account</h3>
              <div className="space-y-4">
                <div className="p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
                  <p className="font-medium mb-2">Not signed in</p>
                  <p className="text-sm text-[hsl(var(--ios-gray))] mb-4">
                    Sign in to sync your notes across devices and enable collaboration features.
                  </p>
                  <div className="flex gap-3">
                    <button 
                      onClick={() => window.location.href = '/api/login'}
                      className="flex-1 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors font-medium"
                    >
                      Sign In
                    </button>
                    <button 
                      onClick={() => window.location.href = '/api/logout'}
                      className="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
                    >
                      Sign Out
                    </button>
                  </div>
                </div>
              </div>
            </div>

            <div className="pt-8">
              <div className="text-center text-sm text-[hsl(var(--ios-gray))]">
                <p>Mira v1.0.0</p>
                <p className="mt-1">Your trusted memory companion</p>
              </div>
            </div>
          </div>
        </div>
        
        {/* Bottom Navigation */}
        <BottomNavigation 
          activeTab={activeTab} 
          onTabChange={(tab: "activity" | "todos" | "collections") => {
            console.log("Settings modal onTabChange called with:", tab);
            onTabChange(tab);
            console.log("Settings modal calling onClose");
            onClose();
          }}
          onNewNote={onNewNote}
          onSettings={onClose}
          onCloseCapture={onCloseCapture}
          hideAddButton={true}
        />

      </div>
    </div>
  );
}```

### client/src/components/todos-view-backup.tsx
```typescript
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import type { Todo } from "@shared/schema";
import { Check, Pin, Archive, Clock, AlertCircle, Star, Filter, ChevronDown, ChevronRight, Circle, Search, Mic, Copy, Trash2, MoreHorizontal, X, GripVertical } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { useLocation } from "wouter";

type FilterType = 'all' | 'urgent' | 'today' | 'pinned' | 'completed' | 'archived';

interface TodoItemProps {
  todo: Todo;
  onToggle: (todo: Todo) => void;
  onPin: (todo: Todo) => void;
  onArchive: (todo: Todo) => void;
  onDragStart?: (todo: Todo) => void;
  onDragEnd?: () => void;
  isDragging?: boolean;
  onClick?: (todo: Todo) => void;
}

function TodoItem({ todo, onToggle, onPin, onArchive, onDragStart, onDragEnd, isDragging: isExternalDragging, onClick }: TodoItemProps) {
  const [showSwipeMenu, setShowSwipeMenu] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStartY, setDragStartY] = useState(0);
  const [currentY, setCurrentY] = useState(0);
  const [isLongPress, setIsLongPress] = useState(false);
  const longPressTimer = useState<NodeJS.Timeout | null>(null);

  const handleDuplicate = () => {
    console.log('Duplicate todo:', todo.id);
    setShowSwipeMenu(false);
  };

  const handleDelete = () => {
    console.log('Delete todo:', todo.id);
    setShowSwipeMenu(false);
  };

  const handleClick = () => {
    if (onClick) {
      onClick(todo);
    }
  };

  return (
    <div className="relative">
      <div 
        className={`flex items-center gap-3 p-3 rounded-lg transition-all duration-200 cursor-pointer
          ${todo.completed 
            ? 'bg-gray-50 dark:bg-gray-900/50 text-gray-500 dark:text-gray-400' 
            : 'bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700'
          }
          ${isDragging || isExternalDragging ? 'shadow-lg scale-105' : 'shadow-sm'}
          ${todo.pinned ? 'ring-2 ring-blue-200 dark:ring-blue-800' : ''}
        `}
        onClick={handleClick}
      >
        <button
          onClick={(e) => {
            e.stopPropagation();
            onToggle(todo);
          }}
          className={`flex-shrink-0 w-5 h-5 rounded-full border-2 flex items-center justify-center transition-colors
            ${todo.completed 
              ? 'bg-green-500 border-green-500 text-white' 
              : 'border-gray-300 dark:border-gray-600 hover:border-blue-500 dark:hover:border-blue-400'
            }
          `}
        >
          {todo.completed && <Check size={12} />}
        </button>

        <div className="flex-grow min-w-0">
          <p className={`text-sm ${todo.completed ? 'line-through' : ''}`}>
            {todo.title}
          </p>
        </div>

        <div className="flex items-center gap-2">
          {todo.pinned && (
            <Pin size={14} className="text-blue-500 dark:text-blue-400" />
          )}
          
          {todo.priority === 'urgent' && !todo.completed && (
            <AlertCircle size={14} className="text-red-500 dark:text-red-400" />
          )}
        </div>
      </div>
    </div>
  );
}

export default function TodosView() {
  const [activeFilter, setActiveFilter] = useState<FilterType>('all');
  const [searchTerm, setSearchTerm] = useState("");
  const [showArchived, setShowArchived] = useState(false);
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  
  const { data: todos, isLoading } = useQuery<Todo[]>({
    queryKey: ["/api/todos"],
  });

  const toggleTodoMutation = useMutation({
    mutationFn: async ({ id, completed }: { id: number; completed: boolean }) => {
      const response = await apiRequest("PATCH", `/api/todos/${id}`, { completed });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  const pinTodoMutation = useMutation({
    mutationFn: async ({ id, pinned }: { id: number; pinned: boolean }) => {
      const response = await apiRequest("PATCH", `/api/todos/${id}`, { pinned });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  const archiveTodoMutation = useMutation({
    mutationFn: async ({ id, archived }: { id: number; archived: boolean }) => {
      const response = await apiRequest("PATCH", `/api/todos/${id}`, { archived });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  // Group todos by their related notes/projects
  const groupTodosByNote = (todos: Todo[]) => {
    const grouped: { [key: string]: { noteTitle: string; todos: Todo[] } } = {};
    
    todos.forEach(todo => {
      const noteTitle = (todo as any).noteTitle || 'Other Tasks';
      const groupKey = `note_${todo.noteId || 'orphaned'}`;
      
      if (!grouped[groupKey]) {
        grouped[groupKey] = {
          noteTitle: noteTitle,
          todos: []
        };
      }
      
      grouped[groupKey].todos.push(todo);
    });
    
    return grouped;
  };

  const getFilteredTodos = () => {
    if (!todos) return [];

    let filtered = todos.filter(t => {
      const matchesSearch = !searchTerm || t.title.toLowerCase().includes(searchTerm.toLowerCase());
      return matchesSearch;
    });

    switch (activeFilter) {
      case 'pinned':
        return filtered.filter(t => t.pinned && !t.completed && !t.archived);
      case 'urgent':
        return filtered.filter(t => t.priority === 'urgent' && !t.completed && !t.archived);
      case 'today':
        return filtered.filter(t => !t.completed && !t.archived);
      case 'completed':
        return filtered.filter(t => t.completed && !t.archived);
      case 'archived':
        return filtered.filter(t => t.archived);
      default:
        return showArchived ? filtered : filtered.filter(t => !t.archived);
    }
  };

  const handleToggleTodo = (todo: Todo) => {
    toggleTodoMutation.mutate({ id: todo.id, completed: !todo.completed });
  };

  const handlePinTodo = (todo: Todo) => {
    pinTodoMutation.mutate({ id: todo.id, pinned: !todo.pinned });
  };

  const handleArchiveTodo = (todo: Todo) => {
    archiveTodoMutation.mutate({ id: todo.id, archived: !todo.archived });
  };

  const handleTodoClick = (todo: Todo) => {
    setLocation(`/todos/${todo.id}`);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-8">
        <div className="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
      </div>
    );
  }

  const filteredTodos = getFilteredTodos();
  const activeTodos = todos?.filter(t => !t.completed && !t.archived) || [];
  const pinnedCount = todos?.filter(t => t.pinned && !t.completed && !t.archived).length || 0;
  const urgentCount = todos?.filter(t => t.priority === 'urgent' && !t.completed && !t.archived).length || 0;
  
  // Group todos by note for better organization
  const groupedTodos = groupTodosByNote(filteredTodos);

  const filterButtons = [
    { key: 'all', label: 'All', count: activeTodos.length, icon: null },
    { key: 'pinned', label: 'Pinned', count: pinnedCount, icon: Pin },
    { key: 'urgent', label: 'Urgent', count: urgentCount, icon: AlertCircle },
    { key: 'completed', label: 'Done', count: todos?.filter(t => t.completed && !t.archived).length || 0, icon: Check },
  ];

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
            Tasks
          </h2>
        </div>
        <div className="flex items-center gap-2">
          <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors">
            <Search size={18} />
          </button>
          <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors">
            <Filter size={18} />
          </button>
        </div>
      </div>

      <div className="flex gap-2 overflow-x-auto pb-2">
        {filterButtons.map(({ key, label, count, icon: Icon }) => (
          <button
            key={key}
            onClick={() => setActiveFilter(key as FilterType)}
            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors whitespace-nowrap
              ${activeFilter === key
                ? 'bg-blue-500 text-white'
                : 'bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700'
              }
            `}
          >
            {Icon && <Icon size={14} />}
            {label}
            {count > 0 && (
              <span className={`px-1.5 py-0.5 rounded-full text-xs
                ${activeFilter === key
                  ? 'bg-white/20 text-white'
                  : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300'
                }
              `}>
                {count}
              </span>
            )}
          </button>
        ))}
      </div>

      <div className="space-y-4">
        {Object.entries(groupedTodos).map(([groupKey, group]) => (
          <div key={groupKey} className="space-y-2">
            {Object.keys(groupedTodos).length > 1 && (
              <h3 className="text-sm font-medium text-gray-600 dark:text-gray-400 px-1">
                {group.noteTitle}
              </h3>
            )}
            <div className="space-y-2">
              {group.todos.map(todo => (
                <div key={todo.id} className={Object.keys(groupedTodos).length > 1 ? 'ml-4' : ''}>
                  <TodoItem
                    todo={todo}
                    onToggle={handleToggleTodo}
                    onPin={handlePinTodo}
                    onArchive={handleArchiveTodo}
                    onClick={handleTodoClick}
                  />
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>

      {filteredTodos.length === 0 && (
        <div className="text-center py-8">
          <div className="text-gray-400 dark:text-gray-500 mb-2">
            <Circle size={48} className="mx-auto mb-4 opacity-50" />
          </div>
          <p className="text-gray-500 dark:text-gray-400">
            {activeFilter === 'completed' ? 'No completed tasks yet' : 
             activeFilter === 'pinned' ? 'No pinned tasks' :
             activeFilter === 'urgent' ? 'No urgent tasks' :
             searchTerm ? 'No tasks found' : 'No tasks yet'}
          </p>
        </div>
      )}
    </div>
  );
}```

### client/src/components/todos-view.tsx
```typescript
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import type { Todo } from "@shared/schema";
import { Check, Pin, Archive, Clock, AlertCircle, Star, Filter, ChevronDown, ChevronRight, Circle, Search, Mic, Copy, Trash2, MoreHorizontal, X, GripVertical } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { useLocation } from "wouter";

type FilterType = 'all' | 'urgent' | 'today' | 'pinned' | 'completed' | 'archived';
type ReminderFilterType = 'today' | 'week' | 'month' | 'year';

interface TodoItemProps {
  todo: Todo;
  onToggle: (todo: Todo) => void;
  onPin: (todo: Todo) => void;
  onArchive: (todo: Todo) => void;
  onDragStart?: (todo: Todo) => void;
  onDragEnd?: () => void;
  isDragging?: boolean;
  onClick?: (todo: Todo) => void;
}

function TodoItem({ todo, onToggle, onPin, onArchive, onDragStart, onDragEnd, isDragging: isExternalDragging, onClick }: TodoItemProps) {
  const [showSwipeMenu, setShowSwipeMenu] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStartY, setDragStartY] = useState(0);
  const [currentY, setCurrentY] = useState(0);
  const [isLongPress, setIsLongPress] = useState(false);
  const longPressTimer = useState<NodeJS.Timeout | null>(null);

  const handleDuplicate = () => {
    console.log('Duplicate todo:', todo.id);
    setShowSwipeMenu(false);
  };

  const handleDelete = () => {
    console.log('Delete todo:', todo.id);
    setShowSwipeMenu(false);
  };

  const handleClick = () => {
    if (onClick) {
      onClick(todo);
    }
  };

  return (
    <div className="relative">
      <div 
        className={`flex items-center gap-2 py-0 px-4 border-b border-gray-100 dark:border-gray-800 transition-all duration-200 cursor-pointer relative
          ${todo.completed 
            ? 'text-gray-500 dark:text-gray-400' 
            : 'hover:bg-gray-50 dark:hover:bg-gray-700'
          }
          ${todo.pinned ? 'bg-blue-50 dark:bg-blue-900/20' : ''}
        `}
        onClick={handleClick}
      >
        {/* Vertical grouping line - positioned right of circle, before text */}
        <div className="absolute left-[56px] top-0 bottom-0 w-px bg-gray-200 dark:bg-gray-700"></div>
        <button
          onClick={(e) => {
            e.stopPropagation();
            onToggle(todo);
          }}
          className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center transition-colors touch-manipulation
            ${todo.completed 
              ? 'text-white' 
              : 'hover:bg-gray-100 dark:hover:bg-gray-600'
            }
          `}
        >
          <div className={`w-5 h-5 rounded-full border-2 flex items-center justify-center
            ${todo.completed 
              ? 'bg-green-500 border-green-500 text-white' 
              : 'border-gray-300 dark:border-gray-600'
            }
          `}>
            {todo.completed && <Check size={12} />}
          </div>
        </button>

        <div className="flex-grow min-w-0">
          <p className={`text-sm ${todo.completed ? 'line-through' : ''} truncate`}>
            {todo.title}
          </p>
        </div>

        <div className="flex items-center gap-2">
          {todo.pinned && (
            <Pin size={14} className="text-blue-500 dark:text-blue-400" />
          )}
          
          {todo.priority === 'urgent' && !todo.completed && (
            <AlertCircle size={14} className="text-red-500 dark:text-red-400" />
          )}
        </div>
      </div>
    </div>
  );
}

export default function TodosView() {
  const [activeFilter, setActiveFilter] = useState<FilterType>('all');
  const [activeReminderFilter, setActiveReminderFilter] = useState<ReminderFilterType>('today');
  const [searchTerm, setSearchTerm] = useState("");
  const [showArchived, setShowArchived] = useState(false);
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  
  const { data: todos, isLoading } = useQuery<Todo[]>({
    queryKey: ["/api/todos"],
  });

  const toggleTodoMutation = useMutation({
    mutationFn: async ({ id, completed }: { id: number; completed: boolean }) => {
      const response = await apiRequest("PATCH", `/api/todos/${id}`, { completed });
      return response.json();
    },
    onMutate: async ({ id, completed }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ["/api/todos"] });
      
      // Snapshot the previous value
      const previousTodos = queryClient.getQueryData<Todo[]>(["/api/todos"]);
      
      // Optimistically update to the new value
      queryClient.setQueryData<Todo[]>(["/api/todos"], (old) =>
        old?.map(todo => 
          todo.id === id ? { ...todo, completed } : todo
        ) || []
      );
      
      return { previousTodos };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      if (context?.previousTodos) {
        queryClient.setQueryData(["/api/todos"], context.previousTodos);
      }
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  const pinTodoMutation = useMutation({
    mutationFn: async ({ id, pinned }: { id: number; pinned: boolean }) => {
      const response = await apiRequest("PATCH", `/api/todos/${id}`, { pinned });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  const archiveTodoMutation = useMutation({
    mutationFn: async ({ id, archived }: { id: number; archived: boolean }) => {
      const response = await apiRequest("PATCH", `/api/todos/${id}`, { archived });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  // Group todos by their related notes/projects
  const groupTodosByNote = (todos: Todo[]) => {
    const grouped: { [key: string]: { noteTitle: string; todos: Todo[] } } = {};
    
    todos.forEach(todo => {
      const noteTitle = (todo as any).noteTitle || 'Other Tasks';
      const groupKey = `note_${todo.noteId || 'orphaned'}`;
      
      if (!grouped[groupKey]) {
        grouped[groupKey] = {
          noteTitle: noteTitle,
          todos: []
        };
      }
      
      grouped[groupKey].todos.push(todo);
    });
    
    return grouped;
  };

  const getFilteredTodos = () => {
    if (!todos) return [];

    let filtered = todos.filter(t => {
      const matchesSearch = !searchTerm || t.title.toLowerCase().includes(searchTerm.toLowerCase());
      return matchesSearch;
    });

    switch (activeFilter) {
      case 'pinned':
        return filtered.filter(t => t.pinned && !t.completed && !t.archived);
      case 'urgent':
        return filtered.filter(t => t.priority === 'urgent' && !t.completed && !t.archived);
      case 'today':
        return filtered.filter(t => !t.completed && !t.archived);
      case 'completed':
        return filtered.filter(t => t.completed && !t.archived);
      case 'archived':
        return filtered.filter(t => t.archived);
      default:
        return showArchived ? filtered : filtered.filter(t => !t.archived);
    }
  };

  const handleToggleTodo = (todo: Todo) => {
    toggleTodoMutation.mutate({ id: todo.id, completed: !todo.completed });
  };

  const handlePinTodo = (todo: Todo) => {
    pinTodoMutation.mutate({ id: todo.id, pinned: !todo.pinned });
  };

  const handleArchiveTodo = (todo: Todo) => {
    archiveTodoMutation.mutate({ id: todo.id, archived: !todo.archived });
  };

  const handleTodoClick = (todo: Todo) => {
    setLocation(`/todos/${todo.id}`);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-8">
        <div className="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
      </div>
    );
  }

  const filteredTodos = getFilteredTodos();
  const activeTodos = todos?.filter(t => !t.completed && !t.archived) || [];
  const pinnedCount = todos?.filter(t => t.pinned && !t.completed && !t.archived).length || 0;
  const urgentCount = todos?.filter(t => t.priority === 'urgent' && !t.completed && !t.archived).length || 0;
  
  // Group todos by note for better organization
  const groupedTodos = groupTodosByNote(filteredTodos);

  const filterButtons = [
    { key: 'all', label: 'All', count: activeTodos.length, icon: null },
    { key: 'pinned', label: 'Pins', count: pinnedCount, icon: Pin },
    { key: 'urgent', label: 'Urgent', count: urgentCount, icon: AlertCircle },
    { key: 'completed', label: 'Done', count: todos?.filter(t => t.completed && !t.archived).length || 0, icon: Check },
  ];

  // Separate reminders and todos
  const reminders = todos?.filter(t => t.isActiveReminder && !t.completed && !t.archived) || [];
  const regularTodos = todos?.filter(t => !t.isActiveReminder && !t.completed && !t.archived) || [];

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between px-4 pt-6">
        <div className="flex items-center gap-2">
          <h2 className="text-2xl font-serif font-medium text-gray-900 dark:text-gray-100">
            Remind
          </h2>
        </div>
        <div className="flex items-center gap-2">
          <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors">
            <Search size={18} />
          </button>
          <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors">
            <Filter size={18} />
          </button>
        </div>
      </div>

      {/* Reminders Section */}
      <div className="space-y-3">
        <div className="flex items-center justify-between px-4">
          <h3 className="text-sm font-medium text-gray-900 dark:text-gray-100">Reminders</h3>
          <div className="flex gap-1">
            {(['today', 'week', 'month', 'year'] as ReminderFilterType[]).map((filter) => (
              <button
                key={filter}
                onClick={() => setActiveReminderFilter(filter)}
                className={`px-2 py-1 text-xs rounded-md transition-colors ${
                  activeReminderFilter === filter
                    ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'
                    : 'bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400'
                }`}
              >
                {filter.charAt(0).toUpperCase() + filter.slice(1)}
              </button>
            ))}
          </div>
        </div>
        
        {reminders.length > 0 ? (
          <div className="space-y-2">
            {reminders.map(reminder => (
              <TodoItem
                key={reminder.id}
                todo={reminder}
                onToggle={handleToggleTodo}
                onPin={handlePinTodo}
                onArchive={handleArchiveTodo}
                onClick={handleTodoClick}
              />
            ))}
          </div>
        ) : (
          <div className="px-4">
            <p className="text-sm text-gray-500 dark:text-gray-400">
              None {activeReminderFilter === 'today' ? 'today' : 
                    activeReminderFilter === 'week' ? 'this week' :
                    activeReminderFilter === 'month' ? 'this month' :
                    'this year'}
            </p>
          </div>
        )}
      </div>

      {/* To-dos Section */}
      <div className="space-y-3">
        <div className="flex items-center justify-between px-4">
          <h3 className="text-sm font-medium text-gray-900 dark:text-gray-100">To-dos</h3>
          <div className="flex gap-1">
            {filterButtons.map(({ key, label, count, icon: Icon }) => (
              <button
                key={key}
                onClick={() => setActiveFilter(key as FilterType)}
                className={`px-2 py-1 text-xs rounded-md transition-colors whitespace-nowrap flex-shrink-0
                  ${activeFilter === key
                    ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'
                    : 'bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400'
                  }
                `}
              >
                {label}
              </button>
            ))}
          </div>
        </div>

        {filteredTodos.length > 0 ? (
          <div className="space-y-2">
            {filteredTodos.map(todo => (
              <TodoItem
                key={todo.id}
                todo={todo}
                onToggle={handleToggleTodo}
                onPin={handlePinTodo}
                onArchive={handleArchiveTodo}
                onClick={handleTodoClick}
              />
            ))}
          </div>
        ) : (
          <div className="text-center py-8">
            <div className="text-gray-400 dark:text-gray-500 mb-2">
              <Circle size={48} className="mx-auto mb-4 opacity-50" />
            </div>
            <p className="text-gray-500 dark:text-gray-400">
              {activeFilter === 'completed' ? 'No completed tasks yet' : 
               activeFilter === 'pinned' ? 'No pinned tasks' :
               activeFilter === 'urgent' ? 'No urgent tasks' :
               searchTerm ? 'No tasks found' : 'No tasks yet'}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}```

### client/src/components/ui/accordion.tsx
```typescript
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
```

### client/src/components/ui/alert-dialog.tsx
```typescript
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
```

### client/src/components/ui/alert.tsx
```typescript
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
```

### client/src/components/ui/aspect-ratio.tsx
```typescript
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }
```

### client/src/components/ui/avatar.tsx
```typescript
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
```

### client/src/components/ui/badge.tsx
```typescript
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }```

### client/src/components/ui/breadcrumb.tsx
```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
```

### client/src/components/ui/button.tsx
```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
```

### client/src/components/ui/calendar.tsx
```typescript
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
```

### client/src/components/ui/card.tsx
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```

### client/src/components/ui/carousel.tsx
```typescript
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
```

### client/src/components/ui/chart.tsx
```typescript
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
```

### client/src/components/ui/checkbox.tsx
```typescript
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
```

### client/src/components/ui/collapsible.tsx
```typescript
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
```

### client/src/components/ui/command.tsx
```typescript
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
```

### client/src/components/ui/context-menu.tsx
```typescript
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
```

### client/src/components/ui/dialog.tsx
```typescript
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
```

### client/src/components/ui/drawer.tsx
```typescript
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
```

### client/src/components/ui/dropdown-menu.tsx
```typescript
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
```

### client/src/components/ui/form.tsx
```typescript
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
```

### client/src/components/ui/hover-card.tsx
```typescript
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }
```

### client/src/components/ui/input-otp.tsx
```typescript
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
```

### client/src/components/ui/input.tsx
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
```

### client/src/components/ui/label.tsx
```typescript
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
```

### client/src/components/ui/menubar.tsx
```typescript
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
```

### client/src/components/ui/navigation-menu.tsx
```typescript
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
```

### client/src/components/ui/pagination.tsx
```typescript
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
```

### client/src/components/ui/popover.tsx
```typescript
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
```

### client/src/components/ui/progress.tsx
```typescript
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
```

### client/src/components/ui/radio-group.tsx
```typescript
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
```

### client/src/components/ui/resizable.tsx
```typescript
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
```

### client/src/components/ui/scroll-area.tsx
```typescript
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
```

### client/src/components/ui/select.tsx
```typescript
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
```

### client/src/components/ui/separator.tsx
```typescript
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
```

### client/src/components/ui/sheet.tsx
```typescript
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
```

### client/src/components/ui/sidebar.tsx
```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
```

### client/src/components/ui/skeleton.tsx
```typescript
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
```

### client/src/components/ui/slider.tsx
```typescript
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
```

### client/src/components/ui/switch.tsx
```typescript
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
```

### client/src/components/ui/table.tsx
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
```

### client/src/components/ui/tabs.tsx
```typescript
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
```

### client/src/components/ui/textarea.tsx
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }
```

### client/src/components/ui/toaster.tsx
```typescript
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
```

### client/src/components/ui/toast.tsx
```typescript
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, duration = 1000, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      duration={duration}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
```

### client/src/components/ui/toggle-group.tsx
```typescript
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
```

### client/src/components/ui/toggle.tsx
```typescript
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
```

### client/src/components/ui/tooltip.tsx
```typescript
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
```

### client/src/components/voice-modal.tsx
```typescript
import { useState, useEffect, useRef } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { X, Pause, Square } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { useSpeechRecognition } from "@/hooks/use-speech";

interface VoiceModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function VoiceModal({ isOpen, onClose }: VoiceModalProps) {
  const [recordingState, setRecordingState] = useState<'ready' | 'recording' | 'stopped' | 'processing'>('ready');
  const [recordingTime, setRecordingTime] = useState(0);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { transcript, isListening, startListening, stopListening, confidence } = useSpeechRecognition();

  const createVoiceNoteMutation = useMutation({
    mutationFn: async (audioBlob: Blob) => {
      const formData = new FormData();
      formData.append("audio", audioBlob, "recording.webm");
      formData.append("duration", recordingTime.toString());

      const response = await fetch("/api/notes/voice", {
        method: "POST",
        body: formData,
        credentials: "include",
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to create voice note");
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      setRecordingState('ready');
      setRecordingTime(0);
      setAudioBlob(null);
      onClose();
      toast({
        title: "Voice note saved",
        description: "Your voice note has been transcribed and enhanced by AI.",
      });
    },
    onError: () => {
      setRecordingState('stopped');
      toast({
        title: "Error",
        description: "Failed to process voice note. Please try again.",
        variant: "destructive",
      });
    },
  });

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
      mediaRecorderRef.current = mediaRecorder;

      const chunks: BlobPart[] = [];
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunks.push(event.data);
        }
      };

      mediaRecorder.onstop = () => {
        // Check minimum duration (1.5 seconds)
        if (recordingTime < 1.5) {
          console.log(`Voice recording too short: ${recordingTime}s, discarding`);
          setAudioBlob(null);
          setRecordingTime(0);
          setRecordingState('ready');
          stream.getTracks().forEach(track => track.stop());
          toast({
            title: "Recording too short",
            description: "Voice notes must be at least 1.5 seconds long.",
            variant: "destructive",
          });
          return;
        }

        const blob = new Blob(chunks, { type: "audio/webm" });
        setAudioBlob(blob);
        setRecordingState('stopped');
        stream.getTracks().forEach(track => track.stop());
      };

      mediaRecorder.start();
      startListening();
      setRecordingState('recording');
      setRecordingTime(0);

      intervalRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);

    } catch (error) {
      toast({
        title: "Microphone access needed",
        description: "Please allow microphone access to record voice notes.",
        variant: "destructive",
      });
      setRecordingState('ready');
    }
  };

  const pauseRecording = () => {
    if (recordingState === 'recording') {
      stopListening();
      setRecordingState('paused');
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }
  };

  const resumeRecording = () => {
    if (recordingState === 'paused') {
      startListening();
      setRecordingState('recording');
      intervalRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
    }
  };

  const stopRecording = () => {
    // Check duration BEFORE stopping
    if (recordingTime < 1.5) {
      console.log(`Voice recording too short: ${recordingTime}s, discarding`);
      setAudioBlob(null);
      setRecordingTime(0);
      setRecordingState('ready');
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      toast({
        title: "Recording too short",
        description: "Voice notes must be at least 1.5 seconds long.",
        variant: "destructive",
      });
      return;
    }

    if (mediaRecorderRef.current && recordingState === 'recording') {
      mediaRecorderRef.current.stop();
      stopListening();

      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }
  };

  const cancelRecording = () => {
    if (recordingState === 'recording') {
      stopRecording();
    }
    setAudioBlob(null);
    setRecordingTime(0);
    setRecordingState('ready');
    onClose();
  };

  const handleSave = () => {
    // Check minimum duration before saving
    if (recordingTime < 1.5) {
      console.log(`Voice recording too short: ${recordingTime}s, discarding`);
      setAudioBlob(null);
      setRecordingTime(0);
      setRecordingState('ready');
      toast({
        title: "Voice note too short", 
        description: "Please record for at least 1.5 seconds",
        variant: "destructive",
      });
      return;
    }

    if (audioBlob) {
      setRecordingState('processing');
      createVoiceNoteMutation.mutate(audioBlob);
    } else {
      toast({
        title: "No recording found",
        description: "Please record audio before saving",
        variant: "destructive",
      });
    }
  };

  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setRecordingState('ready');
      setRecordingTime(0);
      setAudioBlob(null);
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [isOpen]);

  const formatTime = (seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 animate-fadeIn">
      <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-full max-w-sm bg-white rounded-t-3xl p-6 safe-area-bottom animate-slideUp">
        <div className="w-12 h-1 bg-gray-300 rounded-full mx-auto mb-6"></div>

        <div className="text-center mb-8">
          <h3 className="text-xl font-semibold mb-2">
            {recordingState === 'ready' && 'Ready to Record'}
            {recordingState === 'recording' && 'Recording...'}
            {recordingState === 'stopped' && 'Recording Complete'}
            {recordingState === 'processing' && 'Saving...'}
          </h3>
          <p className="text-[hsl(var(--muted-foreground))]">
            {recordingState === 'ready' && 'Tap the record button to start'}
            {recordingState === 'recording' && 'Speak your thoughts'}
            {recordingState === 'stopped' && 'Tap save to create your note'}
            {recordingState === 'processing' && 'Processing your voice note...'}
          </p>
        </div>

        {/* Waveform Visualization */}
        <div className="flex items-center justify-center space-x-1 mb-8 h-16">
          {recordingState === 'recording' && (
            <>
              {[...Array(8)].map((_, i) => (
                <div
                  key={i}
                  className="w-1 bg-[hsl(var(--soft-sky-blue))] rounded-full recording-wave"
                  style={{ 
                    "--delay": `${i * 0.1}s`,
                    height: "20px"
                  } as React.CSSProperties}
                ></div>
              ))}
            </>
          )}
        </div>

        {/* Live Transcript */}
        {transcript && (
          <div className="mb-6 p-3 bg-[hsl(var(--muted))] rounded-xl">
            <div className="flex items-start justify-between mb-2">
              <p className="text-sm text-[hsl(var(--foreground))] flex-1">{transcript}</p>
              {confidence > 0 && (
                <div className="ml-2 flex items-center space-x-1">
                  <div className={`w-2 h-2 rounded-full ${confidence > 0.8 ? 'bg-green-500' : confidence > 0.6 ? 'bg-yellow-500' : 'bg-red-500'}`}></div>
                  <span className="text-xs text-[hsl(var(--muted-foreground))]">{Math.round(confidence * 100)}%</span>
                </div>
              )}
            </div>
            {isListening && (
              <div className="text-xs text-[hsl(var(--muted-foreground))] animate-pulse">Listening...</div>
            )}
          </div>
        )}

        {/* Recording Timer */}
        <div className="text-center mb-8">
          <span className="text-2xl font-mono text-[hsl(var(--foreground))]">{formatTime(recordingTime)}</span>
        </div>

        {/* Recording Controls */}
        <div className="flex items-center justify-center space-x-6">
          <button 
            onClick={cancelRecording}
            className="w-14 h-14 rounded-full bg-[hsl(var(--muted))] hover:bg-[hsl(var(--border))] flex items-center justify-center transition-colors"
            title="Cancel"
          >
            <X className="w-5 h-5 text-[hsl(var(--muted-foreground))]" />
          </button>

          {recordingState === 'ready' && (
            <button 
              onClick={startRecording}
              className="w-16 h-16 rounded-full bg-[hsl(var(--soft-sky-blue))] hover:bg-[hsl(var(--dusty-teal))] flex items-center justify-center transition-colors shadow-lg"
              title="Start Recording"
            >
              <div className="w-6 h-6 rounded-full bg-white"></div>
            </button>
          )}

          {recordingState === 'recording' && (
            <button 
              onClick={stopRecording}
              className="w-16 h-16 rounded-full bg-red-500 hover:bg-red-600 flex items-center justify-center animate-pulse transition-colors shadow-lg"
              title="Stop Recording"
            >
              <Square className="w-6 h-6 text-white" />
            </button>
          )}

          {recordingState === 'stopped' && (
            <button 
              onClick={handleSave}
              disabled={createVoiceNoteMutation.isPending}
              className="w-16 h-16 rounded-full bg-[hsl(var(--seafoam-green))] hover:bg-[hsl(var(--dusty-teal))] flex items-center justify-center disabled:opacity-50 transition-colors shadow-lg"
              title="Save Voice Note"
            >
              {createVoiceNoteMutation.isPending ? (
                <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
              ) : (
                <span className="text-white font-semibold text-sm">Save</span>
              )}
            </button>
          )}

          {recordingState === 'processing' && (
            <div className="w-16 h-16 rounded-full bg-[hsl(var(--muted))] flex items-center justify-center">
              <div className="w-5 h-5 border-2 border-[hsl(var(--soft-sky-blue))] border-t-transparent rounded-full animate-spin"></div>
            </div>
          )}

          <div className="w-14 h-14"></div> {/* Spacer for balance */}
        </div>
      </div>
    </div>
  );
}```

### client/src/hooks/useCriticalInfo.ts
```typescript
import { useState, useEffect } from 'react';

export const useCriticalInfo = (richContext: any) => {
  const [criticalQuestion, setCriticalQuestion] = useState<string | null>(null);
  const [isVisible, setIsVisible] = useState(false);

  const filterCriticalQuestions = (microQuestions: string[]) => {
    if (!microQuestions || microQuestions.length === 0) return [];
    
    const criticalPatterns = [
      // Highest priority - what/where
      /what (is|are) (this|that|it|these)/i,
      /where (is|are|can I find|do I get)/i,
      // Secondary - who (when not obvious)
      /who (makes|sells|provides|offers)/i,
    ];
    
    return microQuestions.filter(q => 
      criticalPatterns.some(pattern => pattern.test(q))
    ).slice(0, 1); // Only show 1 critical question
  };

  useEffect(() => {
    if (richContext && richContext.microQuestions) {
      const critical = filterCriticalQuestions(richContext.microQuestions);
      if (critical.length > 0) {
        setCriticalQuestion(critical[0]);
        setIsVisible(true);
      }
    }
  }, [richContext]);

  const dismissDialog = () => {
    setIsVisible(false);
    setCriticalQuestion(null);
  };

  const handleAnswer = (answer: string) => {
    // Here you could send the answer back to the server to update the note
    console.log('Critical info answer:', answer);
    dismissDialog();
  };

  return {
    criticalQuestion,
    isVisible,
    dismissDialog,
    handleAnswer
  };
};```

### client/src/hooks/use-mobile.tsx
```typescript
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
```

### client/src/hooks/use-notes.ts
```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import type { NoteWithTodos, InsertNote } from "@shared/schema";

export function useNotes() {
  const queryClient = useQueryClient();

  const {
    data: notes,
    isLoading,
    error,
  } = useQuery<NoteWithTodos[]>({
    queryKey: ["/api/notes"],
  });

  const createNoteMutation = useMutation({
    mutationFn: async (noteData: InsertNote) => {
      const response = await apiRequest("POST", "/api/notes", noteData);
      return response.json();
    },
    onSuccess: () => {
      // Force refresh all related data
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      queryClient.invalidateQueries({ queryKey: ["/api/collections"] });
      // Also refetch immediately
      queryClient.refetchQueries({ queryKey: ["/api/notes"] });
      queryClient.refetchQueries({ queryKey: ["/api/todos"] });
    },
    onError: (error) => {
      console.error("Failed to create note:", error);
    },
  });

  const createVoiceNoteMutation = useMutation({
    mutationFn: async (audioBlob: Blob) => {
      const formData = new FormData();
      formData.append("audio", audioBlob, "recording.webm");
      
      const response = await fetch("/api/notes/voice", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      
      if (!response.ok) {
        throw new Error("Failed to create voice note");
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      queryClient.invalidateQueries({ queryKey: ["/api/collections"] });
    },
  });

  return {
    notes,
    isLoading,
    error,
    createNote: createNoteMutation.mutate,
    createVoiceNote: createVoiceNoteMutation.mutate,
    isCreating: createNoteMutation.isPending || createVoiceNoteMutation.isPending,
  };
}
```

### client/src/hooks/use-permissions.ts
```typescript
import { useState, useEffect, useCallback, useRef } from 'react';

type PermissionStatus = 'granted' | 'denied' | 'prompt' | 'unknown';

interface MiraPermissionState {
  camera: PermissionStatus;
  microphone: PermissionStatus;
  mediaDevices: boolean;
}

interface PermissionCache {
  camera: {
    granted: boolean;
    timestamp: number;
    lastDenied: number;
  };
  microphone: {
    granted: boolean;
    timestamp: number;
    lastDenied: number;
  };
}

const PERMISSION_CACHE_KEY = 'mira-permissions-cache';
const CACHE_VALIDITY_HOURS = 8760; // 1 year - maximum long-term caching
const DENIAL_COOLDOWN_MINUTES = 5;

function loadPermissionCache(): PermissionCache {
  try {
    const cached = localStorage.getItem(PERMISSION_CACHE_KEY);
    if (cached) {
      return JSON.parse(cached);
    }
  } catch (error) {
    console.warn('Failed to load permission cache:', error);
  }
  
  return {
    camera: { granted: false, timestamp: 0, lastDenied: 0 },
    microphone: { granted: false, timestamp: 0, lastDenied: 0 }
  };
}

function savePermissionCache(cache: PermissionCache) {
  try {
    localStorage.setItem(PERMISSION_CACHE_KEY, JSON.stringify(cache));
  } catch (error) {
    console.warn('Failed to save permission cache:', error);
  }
}

function isCacheValid(timestamp: number): boolean {
  const now = Date.now();
  const hoursOld = (now - timestamp) / (1000 * 60 * 60);
  return hoursOld < CACHE_VALIDITY_HOURS;
}

function isInDenialCooldown(lastDenied: number): boolean {
  const now = Date.now();
  const minutesSinceDenial = (now - lastDenied) / (1000 * 60);
  return minutesSinceDenial < DENIAL_COOLDOWN_MINUTES;
}

export function usePermissions() {
  const [permissions, setPermissions] = useState<MiraPermissionState>({
    camera: 'unknown',
    microphone: 'unknown',
    mediaDevices: !!navigator.mediaDevices
  });

  const permissionCache = useRef<PermissionCache>(loadPermissionCache());

  // Check existing permissions on mount
  useEffect(() => {
    const checkPermissions = async () => {
      setPermissions(prev => ({ ...prev, mediaDevices: !!navigator.mediaDevices }));
      
      if (!navigator.permissions) {
        return;
      }

      try {
        const [cameraPermission, microphonePermission] = await Promise.all([
          navigator.permissions.query({ name: 'camera' as PermissionName }),
          navigator.permissions.query({ name: 'microphone' as PermissionName })
        ]);

        setPermissions({
          camera: cameraPermission.state as PermissionStatus,
          microphone: microphonePermission.state as PermissionStatus,
          mediaDevices: !!navigator.mediaDevices
        });

        // Update cache based on current permission state
        const cache = permissionCache.current;
        const now = Date.now();
        
        if (cameraPermission.state === 'granted') {
          cache.camera = { granted: true, timestamp: now, lastDenied: 0 };
        }
        if (microphonePermission.state === 'granted') {
          cache.microphone = { granted: true, timestamp: now, lastDenied: 0 };
        }
        
        savePermissionCache(cache);

        // Listen for permission changes
        cameraPermission.addEventListener('change', () => {
          const newState = cameraPermission.state as PermissionStatus;
          setPermissions(prev => ({ ...prev, camera: newState }));
          
          if (newState === 'granted') {
            cache.camera = { granted: true, timestamp: Date.now(), lastDenied: 0 };
            savePermissionCache(cache);
          } else if (newState === 'denied') {
            cache.camera = { granted: false, timestamp: 0, lastDenied: Date.now() };
            savePermissionCache(cache);
          }
        });

        microphonePermission.addEventListener('change', () => {
          const newState = microphonePermission.state as PermissionStatus;
          setPermissions(prev => ({ ...prev, microphone: newState }));
          
          if (newState === 'granted') {
            cache.microphone = { granted: true, timestamp: Date.now(), lastDenied: 0 };
            savePermissionCache(cache);
          } else if (newState === 'denied') {
            cache.microphone = { granted: false, timestamp: 0, lastDenied: Date.now() };
            savePermissionCache(cache);
          }
        });
      } catch (error) {
        console.log('Permission API not fully supported, will request as needed');
      }
    };

    checkPermissions();
  }, []);

  const requestCameraPermission = useCallback(async (): Promise<boolean> => {
    const cache = permissionCache.current;
    
    // Check persistent cache first
    if (cache.camera.granted && isCacheValid(cache.camera.timestamp)) {
      setPermissions(prev => ({ ...prev, camera: 'granted' }));
      return true;
    }

    // Check current browser permission state
    if (permissions.camera === 'granted') {
      // Update cache with fresh grant
      cache.camera = { granted: true, timestamp: Date.now(), lastDenied: 0 };
      savePermissionCache(cache);
      return true;
    }

    // Don't request if recently denied
    if (isInDenialCooldown(cache.camera.lastDenied)) {
      console.log('Camera permission in denial cooldown');
      return false;
    }

    try {
      // Request with progressive fallback
      let stream: MediaStream | null = null;
      
      try {
        // Try with ideal constraints first
        stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          } 
        });
      } catch (specificError) {
        console.log('Specific camera constraints failed, trying basic:', specificError);
        // Fallback to basic video constraints
        stream = await navigator.mediaDevices.getUserMedia({ video: true });
      }
      
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        
        // Update both state and persistent cache
        setPermissions(prev => ({ ...prev, camera: 'granted' }));
        cache.camera = { granted: true, timestamp: Date.now(), lastDenied: 0 };
        savePermissionCache(cache);
        
        return true;
      }
      
      return false;
    } catch (error: any) {
      console.error('Camera permission error details:', {
        name: error?.name,
        message: error?.message,
        constraint: error?.constraint
      });
      
      setPermissions(prev => ({ ...prev, camera: 'denied' }));
      cache.camera = { granted: false, timestamp: 0, lastDenied: Date.now() };
      savePermissionCache(cache);
      
      return false;
    }
  }, [permissions.camera]);

  const requestMicrophonePermission = useCallback(async (): Promise<boolean> => {
    const cache = permissionCache.current;
    
    // Check persistent cache first
    if (cache.microphone.granted && isCacheValid(cache.microphone.timestamp)) {
      setPermissions(prev => ({ ...prev, microphone: 'granted' }));
      return true;
    }

    // Check current browser permission state
    if (permissions.microphone === 'granted') {
      // Update cache with fresh grant
      cache.microphone = { granted: true, timestamp: Date.now(), lastDenied: 0 };
      savePermissionCache(cache);
      return true;
    }

    // Don't request if recently denied
    if (isInDenialCooldown(cache.microphone.lastDenied)) {
      console.log('Microphone permission in denial cooldown');
      return false;
    }

    try {
      // Detect best audio format and constraints
      const supportedFormats = [
        'audio/webm',
        'audio/webm;codecs=opus', 
        'audio/mp4',
        'audio/ogg;codecs=opus'
      ].filter(format => MediaRecorder.isTypeSupported(format));

      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 44100
        }
      });
      
      stream.getTracks().forEach(track => track.stop());
      
      // Update both state and persistent cache
      setPermissions(prev => ({ ...prev, microphone: 'granted' }));
      cache.microphone = { granted: true, timestamp: Date.now(), lastDenied: 0 };
      savePermissionCache(cache);
      
      return true;
    } catch (error: any) {
      console.error('Microphone permission error details:', {
        name: error?.name,
        message: error?.message,
        constraint: error?.constraint
      });
      
      setPermissions(prev => ({ ...prev, microphone: 'denied' }));
      cache.microphone = { granted: false, timestamp: 0, lastDenied: Date.now() };
      savePermissionCache(cache);
      
      return false;
    }
  }, [permissions.microphone]);

  const requestBothPermissions = useCallback(async (): Promise<{ camera: boolean; microphone: boolean }> => {
    const cache = permissionCache.current;
    
    // Check if we already have both permissions from cache
    const cameraValid = cache.camera.granted && isCacheValid(cache.camera.timestamp);
    const microphoneValid = cache.microphone.granted && isCacheValid(cache.microphone.timestamp);
    
    if (cameraValid && microphoneValid) {
      setPermissions(prev => ({ 
        ...prev, 
        camera: 'granted', 
        microphone: 'granted' 
      }));
      return { camera: true, microphone: true };
    }

    try {
      // Request both at once with fallbacks
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: 'environment' },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });
      
      stream.getTracks().forEach(track => track.stop());

      const now = Date.now();
      setPermissions(prev => ({ 
        ...prev, 
        camera: 'granted', 
        microphone: 'granted' 
      }));

      // Update cache for both
      cache.camera = { granted: true, timestamp: now, lastDenied: 0 };
      cache.microphone = { granted: true, timestamp: now, lastDenied: 0 };
      savePermissionCache(cache);

      return { camera: true, microphone: true };
    } catch (error) {
      console.error('Combined media permissions error:', error);
      
      // Try individual permissions with detailed error handling
      const cameraResult = await requestCameraPermission();
      const microphoneResult = await requestMicrophonePermission();
      
      return { camera: cameraResult, microphone: microphoneResult };
    }
  }, [permissions.camera, permissions.microphone, requestCameraPermission, requestMicrophonePermission]);

  const clearPermissionCache = useCallback(() => {
    localStorage.removeItem(PERMISSION_CACHE_KEY);
    permissionCache.current = loadPermissionCache();
    setPermissions({
      camera: 'unknown',
      microphone: 'unknown',
      mediaDevices: !!navigator.mediaDevices
    });
  }, []);

  // Initialize permissions from cache on mount
  useEffect(() => {
    const cache = permissionCache.current;
    if (cache.camera.granted && isCacheValid(cache.camera.timestamp)) {
      setPermissions(prev => ({ ...prev, camera: 'granted' }));
    }
    if (cache.microphone.granted && isCacheValid(cache.microphone.timestamp)) {
      setPermissions(prev => ({ ...prev, microphone: 'granted' }));
    }
  }, []);

  return {
    permissions,
    hasCamera: permissions.camera === 'granted' || (permissionCache.current.camera.granted && isCacheValid(permissionCache.current.camera.timestamp)),
    hasMicrophone: permissions.microphone === 'granted' || (permissionCache.current.microphone.granted && isCacheValid(permissionCache.current.microphone.timestamp)),
    canRequestPermissions: permissions.mediaDevices,
    requestCameraPermission,
    requestMicrophonePermission,
    requestBothPermissions,
    clearPermissionCache,
    needsCameraPermission: permissions.camera !== 'granted' && !isInDenialCooldown(permissionCache.current.camera.lastDenied),
    needsMicrophonePermission: permissions.microphone !== 'granted' && !isInDenialCooldown(permissionCache.current.microphone.lastDenied)
  };
}```

### client/src/hooks/use-speech.ts
```typescript
import { useState, useEffect, useRef } from "react";

// Add proper TypeScript declarations
declare global {
  interface Window {
    SpeechRecognition: any;
    webkitSpeechRecognition: any;
  }
}

export function useSpeechRecognition() {
  const [transcript, setTranscript] = useState("");
  const [isListening, setIsListening] = useState(false);
  const [isSupported, setIsSupported] = useState(false);
  const [confidence, setConfidence] = useState(0);
  const recognitionRef = useRef<any>(null);
  const finalTranscriptRef = useRef("");

  useEffect(() => {
    if (typeof window !== "undefined") {
      const SpeechRecognition = 
        window.SpeechRecognition || window.webkitSpeechRecognition;
      
      if (SpeechRecognition) {
        setIsSupported(true);
        const recognition = new SpeechRecognition();
        
        // Optimize settings for speed and accuracy
        recognition.continuous = false; // Better for mobile performance
        recognition.interimResults = true;
        recognition.lang = "en-US";
        recognition.maxAlternatives = 3; // Get multiple alternatives for better accuracy

        recognition.onstart = () => {
          setIsListening(true);
          finalTranscriptRef.current = "";
        };

        recognition.onresult = (event: any) => {
          let interimTranscript = "";
          let finalTranscript = finalTranscriptRef.current;

          for (let i = event.resultIndex; i < event.results.length; i++) {
            const result = event.results[i];
            const transcript = result[0].transcript;
            
            if (result.isFinal) {
              finalTranscript += transcript + " ";
              finalTranscriptRef.current = finalTranscript;
              setConfidence(result[0].confidence || 0.8);
            } else {
              interimTranscript += transcript;
            }
          }

          setTranscript((finalTranscript + interimTranscript).trim());
        };

        recognition.onerror = (event: any) => {
          console.error("Speech recognition error:", event.error);
          if (event.error === 'no-speech') {
            // Auto-restart on no speech for continuous experience
            setTimeout(() => {
              if (isListening) {
                recognition.start();
              }
            }, 100);
          } else {
            setIsListening(false);
          }
        };

        recognition.onend = () => {
          setIsListening(false);
        };

        recognitionRef.current = recognition;
      }
    }
  }, [isListening]);

  const startListening = () => {
    if (recognitionRef.current && isSupported && !isListening) {
      try {
        setTranscript("");
        finalTranscriptRef.current = "";
        setConfidence(0);
        recognitionRef.current.start();
      } catch (error) {
        console.error("Failed to start speech recognition:", error);
        setIsListening(false);
      }
    }
  };

  const stopListening = () => {
    if (recognitionRef.current && isListening) {
      recognitionRef.current.stop();
      setIsListening(false);
    }
  };

  const restartListening = () => {
    if (recognitionRef.current && isSupported) {
      stopListening();
      setTimeout(() => {
        startListening();
      }, 100);
    }
  };

  return {
    transcript,
    isListening,
    isSupported,
    confidence,
    startListening,
    stopListening,
    restartListening,
  };
}
```

### client/src/hooks/use-toast.ts
```typescript
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
```

### client/src/lib/calendarUtils.ts
```typescript
/**
 * Calendar Integration Utilities
 * Handles Google Calendar integration and time parsing
 */

export interface CalendarEvent {
  title: string;
  description?: string;
  startTime: Date;
  endTime: Date;
  location?: string;
}

/**
 * Parse time from text (e.g., "7p", "7pm", "7:30p", "19:00")
 */
export function parseTimeFromText(text: string): Date | null {
  const timePatterns = [
    // 7p, 7pm, 11p, 11pm
    /\b(\d{1,2})p(?:m)?\b/i,
    // 7a, 7am, 11a, 11am
    /\b(\d{1,2})a(?:m)?\b/i,
    // 7:30p, 7:30pm, 11:30p, 11:30pm
    /\b(\d{1,2}):(\d{2})p(?:m)?\b/i,
    // 7:30a, 7:30am, 11:30a, 11:30am
    /\b(\d{1,2}):(\d{2})a(?:m)?\b/i,
    // 19:00, 07:00 (24-hour format)
    /\b(\d{1,2}):(\d{2})\b/,
  ];

  const lowerText = text.toLowerCase();
  
  for (const pattern of timePatterns) {
    const match = lowerText.match(pattern);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = match[2] ? parseInt(match[2]) : 0;
      
      // Handle PM/AM conversion
      if (pattern.source.includes('p')) {
        // PM time
        if (hours !== 12) hours += 12;
      } else if (pattern.source.includes('a')) {
        // AM time
        if (hours === 12) hours = 0;
      }
      
      // Create date for today with the parsed time
      const date = new Date();
      date.setHours(hours, minutes, 0, 0);
      
      // If the time has already passed today, schedule for tomorrow
      if (date < new Date()) {
        date.setDate(date.getDate() + 1);
      }
      
      return date;
    }
  }
  
  return null;
}

/**
 * Extract location from text
 */
export function extractLocationFromText(text: string): string | null {
  const locationPatterns = [
    /\bat\s+([^,\n]+)/i,
    /\b(?:in|near|@)\s+([^,\n]+)/i,
  ];
  
  for (const pattern of locationPatterns) {
    const match = text.match(pattern);
    if (match) {
      return match[1].trim();
    }
  }
  
  return null;
}

/**
 * Create Google Calendar URL
 */
export function createGoogleCalendarUrl(event: CalendarEvent): string {
  const formatDate = (date: Date): string => {
    return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
  };
  
  const params = new URLSearchParams({
    action: 'TEMPLATE',
    text: event.title,
    dates: `${formatDate(event.startTime)}/${formatDate(event.endTime)}`,
    details: event.description || '',
    location: event.location || '',
  });
  
  return `https://calendar.google.com/calendar/render?${params.toString()}`;
}

/**
 * Parse todo/note content and create calendar event
 */
export function createCalendarEventFromContent(content: string, title?: string): CalendarEvent | null {
  const startTime = parseTimeFromText(content);
  if (!startTime) return null;
  
  // Default 1-hour duration
  const endTime = new Date(startTime);
  endTime.setHours(endTime.getHours() + 1);
  
  const location = extractLocationFromText(content);
  
  return {
    title: title || content.slice(0, 50),
    description: `Created from Mira note: ${content}`,
    startTime,
    endTime,
    location: location || undefined,
  };
}

/**
 * Open Google Calendar with event details
 */
export function addToGoogleCalendar(event: CalendarEvent): void {
  const url = createGoogleCalendarUrl(event);
  window.open(url, '_blank');
}```

### client/src/lib/collection-colors.ts
```typescript
export const getCollectionColor = (color: string) => {
  const colorMap = {
    orange: {
      bg: "bg-orange-500",
      text: "text-orange-600",
      light: "bg-orange-100",
      border: "border-orange-200"
    },
    purple: {
      bg: "bg-purple-500",
      text: "text-purple-600",
      light: "bg-purple-100",
      border: "border-purple-200"
    },
    green: {
      bg: "bg-green-500",
      text: "text-green-600",
      light: "bg-green-100",
      border: "border-green-200"
    },
    blue: {
      bg: "bg-blue-500",
      text: "text-blue-600",
      light: "bg-blue-100",
      border: "border-blue-200"
    },
    red: {
      bg: "bg-red-500",
      text: "text-red-600",
      light: "bg-red-100",
      border: "border-red-200"
    },
    yellow: {
      bg: "bg-yellow-500",
      text: "text-yellow-600",
      light: "bg-yellow-100",
      border: "border-yellow-200"
    },
    pink: {
      bg: "bg-pink-500",
      text: "text-pink-600",
      light: "bg-pink-100",
      border: "border-pink-200"
    },
    indigo: {
      bg: "bg-indigo-500",
      text: "text-indigo-600",
      light: "bg-indigo-100",
      border: "border-indigo-200"
    },
    teal: {
      bg: "bg-teal-500",
      text: "text-teal-600",
      light: "bg-teal-100",
      border: "border-teal-200"
    },
    gray: {
      bg: "bg-gray-500",
      text: "text-gray-600",
      light: "bg-gray-100",
      border: "border-gray-200"
    },
    cyan: {
      bg: "bg-cyan-500",
      text: "text-cyan-600",
      light: "bg-cyan-100",
      border: "border-cyan-200"
    },
    emerald: {
      bg: "bg-emerald-500",
      text: "text-emerald-600",
      light: "bg-emerald-100",
      border: "border-emerald-200"
    }
  };

  return colorMap[color as keyof typeof colorMap] || colorMap.gray;
};

export const getUniqueCollectionIcon = (collectionName: string) => {
  const name = collectionName.toLowerCase();
  
  // Highly specific icon mapping to ensure uniqueness
  if (name.includes('coffee') || name.includes('cafe')) {
    return { icon: 'coffee', color: 'orange' };
  }
  if (name.includes('food') || name.includes('restaurant') || name.includes('dining')) {
    return { icon: 'utensils', color: 'orange' };
  }
  if (name.includes('book') || name.includes('reading') || name.includes('library')) {
    return { icon: 'book-open', color: 'blue' };
  }
  if (name.includes('travel') || name.includes('trip') || name.includes('vacation')) {
    return { icon: 'plane', color: 'cyan' };
  }
  if (name.includes('work') || name.includes('office') || name.includes('business')) {
    return { icon: 'briefcase', color: 'gray' };
  }
  if (name.includes('project') || name.includes('task')) {
    return { icon: 'folder-open', color: 'blue' };
  }
  if (name.includes('home') || name.includes('house') || name.includes('apartment')) {
    return { icon: 'home', color: 'green' };
  }
  if (name.includes('garden') || name.includes('plant') || name.includes('grow')) {
    return { icon: 'leaf', color: 'green' };
  }
  if (name.includes('health') || name.includes('medical') || name.includes('doctor')) {
    return { icon: 'stethoscope', color: 'red' };
  }
  if (name.includes('fitness') || name.includes('gym') || name.includes('workout')) {
    return { icon: 'dumbbell', color: 'red' };
  }
  if (name.includes('shopping') || name.includes('buy') || name.includes('purchase')) {
    return { icon: 'shopping-cart', color: 'emerald' };
  }
  if (name.includes('store') || name.includes('market') || name.includes('retail')) {
    return { icon: 'store', color: 'emerald' };
  }
  if (name.includes('idea') || name.includes('thought') || name.includes('brainstorm')) {
    return { icon: 'lightbulb', color: 'yellow' };
  }
  if (name.includes('goal') || name.includes('target') || name.includes('achievement')) {
    return { icon: 'target', color: 'purple' };
  }
  if (name.includes('finance') || name.includes('money') || name.includes('budget')) {
    return { icon: 'dollar-sign', color: 'green' };
  }
  if (name.includes('bank') || name.includes('savings') || name.includes('investment')) {
    return { icon: 'piggy-bank', color: 'green' };
  }
  if (name.includes('recipe') || name.includes('cooking') || name.includes('kitchen')) {
    return { icon: 'chef-hat', color: 'orange' };
  }
  if (name.includes('car') || name.includes('vehicle') || name.includes('auto')) {
    return { icon: 'car', color: 'red' };
  }
  if (name.includes('bike') || name.includes('bicycle') || name.includes('cycling')) {
    return { icon: 'bike', color: 'blue' };
  }
  if (name.includes('music') || name.includes('song') || name.includes('playlist')) {
    return { icon: 'music', color: 'purple' };
  }
  if (name.includes('podcast') || name.includes('audio') || name.includes('listen')) {
    return { icon: 'headphones', color: 'purple' };
  }
  if (name.includes('school') || name.includes('university') || name.includes('college')) {
    return { icon: 'graduation-cap', color: 'blue' };
  }
  if (name.includes('learn') || name.includes('study') || name.includes('course')) {
    return { icon: 'graduation-cap', color: 'blue' };
  }
  if (name.includes('movie') || name.includes('film') || name.includes('cinema')) {
    return { icon: 'film', color: 'pink' };
  }
  if (name.includes('tv') || name.includes('show') || name.includes('series')) {
    return { icon: 'tv', color: 'pink' };
  }
  if (name.includes('game') || name.includes('gaming') || name.includes('play')) {
    return { icon: 'gamepad-2', color: 'purple' };
  }
  if (name.includes('gift') || name.includes('present') || name.includes('birthday')) {
    return { icon: 'gift', color: 'pink' };
  }
  if (name.includes('event') || name.includes('party') || name.includes('celebration')) {
    return { icon: 'calendar-days', color: 'indigo' };
  }
  if (name.includes('meeting') || name.includes('appointment') || name.includes('schedule')) {
    return { icon: 'clock', color: 'indigo' };
  }
  if (name.includes('photo') || name.includes('picture') || name.includes('photography')) {
    return { icon: 'camera', color: 'gray' };
  }
  if (name.includes('memory') || name.includes('memories') || name.includes('moment')) {
    return { icon: 'image', color: 'gray' };
  }
  if (name.includes('pet') || name.includes('dog') || name.includes('puppy')) {
    return { icon: 'dog', color: 'pink' };
  }
  if (name.includes('cat') || name.includes('kitten') || name.includes('feline')) {
    return { icon: 'cat', color: 'pink' };
  }
  if (name.includes('tech') || name.includes('computer') || name.includes('software')) {
    return { icon: 'laptop', color: 'gray' };
  }
  if (name.includes('phone') || name.includes('mobile') || name.includes('device')) {
    return { icon: 'smartphone', color: 'gray' };
  }
  if (name.includes('art') || name.includes('design') || name.includes('creative')) {
    return { icon: 'palette', color: 'pink' };
  }
  if (name.includes('writing') || name.includes('journal') || name.includes('blog')) {
    return { icon: 'pen-tool', color: 'blue' };
  }
  if (name.includes('news') || name.includes('article') || name.includes('media')) {
    return { icon: 'newspaper', color: 'gray' };
  }
  if (name.includes('weather') || name.includes('climate') || name.includes('forecast')) {
    return { icon: 'cloud', color: 'cyan' };
  }
  if (name.includes('baby') || name.includes('child') || name.includes('kid')) {
    return { icon: 'baby', color: 'pink' };
  }
  if (name.includes('wedding') || name.includes('marriage') || name.includes('ceremony')) {
    return { icon: 'heart', color: 'pink' };
  }
  if (name.includes('holiday') || name.includes('vacation') || name.includes('break')) {
    return { icon: 'palm-tree', color: 'green' };
  }
  if (name.includes('maintenance') || name.includes('repair') || name.includes('fix')) {
    return { icon: 'wrench', color: 'gray' };
  }
  if (name.includes('cleaning') || name.includes('chore') || name.includes('housework')) {
    return { icon: 'spray-can', color: 'cyan' };
  }
  
  // Default fallback icons for common collection types
  const fallbackIcons = [
    { icon: 'folder', color: 'blue' },
    { icon: 'star', color: 'yellow' },
    { icon: 'bookmark', color: 'purple' },
    { icon: 'tag', color: 'green' },
    { icon: 'archive', color: 'gray' },
    { icon: 'layers', color: 'teal' },
    { icon: 'paperclip', color: 'indigo' },
    { icon: 'flag', color: 'red' }
  ];
  
  // Use hash of collection name to get consistent icon
  const hash = name.split('').reduce((a, b) => {
    a = ((a << 5) - a) + b.charCodeAt(0);
    return a & a;
  }, 0);
  
  return fallbackIcons[Math.abs(hash) % fallbackIcons.length];
};

export const getIconColorByType = (iconName: string) => {
  const iconColorMap = {
    coffee: "orange",
    lightbulb: "yellow",
    book: "blue",
    heart: "pink",
    star: "yellow",
    briefcase: "gray",
    home: "green",
    car: "red",
    plane: "cyan",
    checklist: "purple",
    calendar: "indigo",
    location: "red",
    shopping: "emerald"
  };

  return iconColorMap[iconName as keyof typeof iconColorMap] || "gray";
};```

### client/src/lib/indexeddb.ts
```typescript
import { openDB, type DBSchema, type IDBPDatabase } from 'idb';
import type { NoteWithTodos, Todo, Collection } from '@shared/schema';

interface MiraDBSchema extends DBSchema {
  notes: {
    key: number;
    value: NoteWithTodos & {
      syncStatus: 'synced' | 'pending' | 'conflict';
      lastModified: number;
    };
    indexes: { 'by-sync-status': string; 'by-collection': number };
  };
  todos: {
    key: number;
    value: Todo & {
      syncStatus: 'synced' | 'pending' | 'conflict';
      lastModified: number;
    };
    indexes: { 'by-note': number; 'by-sync-status': string };
  };
  collections: {
    key: number;
    value: Collection & {
      syncStatus: 'synced' | 'pending' | 'conflict';
      lastModified: number;
    };
    indexes: { 'by-sync-status': string };
  };
  syncQueue: {
    key: string;
    value: {
      id: string;
      type: 'create' | 'update' | 'delete';
      table: 'notes' | 'todos' | 'collections';
      data: any;
      timestamp: number;
      retryCount: number;
    };
  };
}

class IndexedDBManager {
  private db: IDBPDatabase<MiraDBSchema> | null = null;
  private dbName = 'mira-offline-db';
  private version = 1;

  async initialize(): Promise<void> {
    this.db = await openDB<MiraDBSchema>(this.dbName, this.version, {
      upgrade(db) {
        // Notes store
        const notesStore = db.createObjectStore('notes', { keyPath: 'id' });
        notesStore.createIndex('by-sync-status', 'syncStatus');
        notesStore.createIndex('by-collection', 'collectionId');

        // Todos store
        const todosStore = db.createObjectStore('todos', { keyPath: 'id' });
        todosStore.createIndex('by-note', 'noteId');
        todosStore.createIndex('by-sync-status', 'syncStatus');

        // Collections store
        const collectionsStore = db.createObjectStore('collections', { keyPath: 'id' });
        collectionsStore.createIndex('by-sync-status', 'syncStatus');

        // Sync queue store
        db.createObjectStore('syncQueue', { keyPath: 'id' });
      },
    });
  }

  async addToSyncQueue(type: 'create' | 'update' | 'delete', table: 'notes' | 'todos' | 'collections', data: any): Promise<void> {
    if (!this.db) await this.initialize();
    
    const queueItem = {
      id: `${table}-${type}-${data.id || Date.now()}-${Math.random()}`,
      type,
      table,
      data,
      timestamp: Date.now(),
      retryCount: 0,
    };

    await this.db!.add('syncQueue', queueItem);
  }

  // Notes operations
  async saveNote(note: NoteWithTodos, syncStatus: 'synced' | 'pending' = 'pending'): Promise<void> {
    if (!this.db) await this.initialize();
    
    const noteWithMeta = {
      ...note,
      syncStatus,
      lastModified: Date.now(),
    };

    await this.db!.put('notes', noteWithMeta);
    
    if (syncStatus === 'pending') {
      await this.addToSyncQueue('update', 'notes', note);
    }
  }

  async getNotes(): Promise<NoteWithTodos[]> {
    if (!this.db) await this.initialize();
    
    const notes = await this.db!.getAll('notes');
    return notes.map(note => {
      const { syncStatus, lastModified, ...cleanNote } = note;
      return cleanNote as NoteWithTodos;
    });
  }

  async getNote(id: number): Promise<NoteWithTodos | undefined> {
    if (!this.db) await this.initialize();
    
    const note = await this.db!.get('notes', id);
    if (!note) return undefined;
    
    const { syncStatus, lastModified, ...cleanNote } = note;
    return cleanNote as NoteWithTodos;
  }

  async deleteNote(id: number): Promise<void> {
    if (!this.db) await this.initialize();
    
    await this.db!.delete('notes', id);
    await this.addToSyncQueue('delete', 'notes', { id });
  }

  // Collections operations
  async saveCollection(collection: Collection, syncStatus: 'synced' | 'pending' = 'pending'): Promise<void> {
    if (!this.db) await this.initialize();
    
    const collectionWithMeta = {
      ...collection,
      syncStatus,
      lastModified: Date.now(),
    };

    await this.db!.put('collections', collectionWithMeta);
    
    if (syncStatus === 'pending') {
      await this.addToSyncQueue('update', 'collections', collection);
    }
  }

  async getCollections(): Promise<Collection[]> {
    if (!this.db) await this.initialize();
    
    const collections = await this.db!.getAll('collections');
    return collections.map(collection => {
      const { syncStatus, lastModified, ...cleanCollection } = collection;
      return cleanCollection as Collection;
    });
  }

  // Todos operations
  async saveTodo(todo: Todo, syncStatus: 'synced' | 'pending' = 'pending'): Promise<void> {
    if (!this.db) await this.initialize();
    
    const todoWithMeta = {
      ...todo,
      syncStatus,
      lastModified: Date.now(),
    };

    await this.db!.put('todos', todoWithMeta);
    
    if (syncStatus === 'pending') {
      await this.addToSyncQueue('update', 'todos', todo);
    }
  }

  async getTodosByNoteId(noteId: number): Promise<Todo[]> {
    if (!this.db) await this.initialize();
    
    const todos = await this.db!.getAllFromIndex('todos', 'by-note', noteId);
    return todos.map(todo => {
      const { syncStatus, lastModified, ...cleanTodo } = todo;
      return cleanTodo as Todo;
    });
  }

  // Sync operations
  async getSyncQueue(): Promise<any[]> {
    if (!this.db) await this.initialize();
    return this.db!.getAll('syncQueue');
  }

  async removeSyncQueueItem(id: string): Promise<void> {
    if (!this.db) await this.initialize();
    await this.db!.delete('syncQueue', id);
  }

  async markAsSynced(table: 'notes' | 'todos' | 'collections', id: number): Promise<void> {
    if (!this.db) await this.initialize();
    
    const item = await this.db!.get(table, id);
    if (item) {
      item.syncStatus = 'synced';
      item.lastModified = Date.now();
      await this.db!.put(table, item);
    }
  }

  async clearAllData(): Promise<void> {
    if (!this.db) await this.initialize();
    
    const tx = this.db!.transaction(['notes', 'todos', 'collections', 'syncQueue'], 'readwrite');
    await Promise.all([
      tx.objectStore('notes').clear(),
      tx.objectStore('todos').clear(),
      tx.objectStore('collections').clear(),
      tx.objectStore('syncQueue').clear(),
    ]);
  }

  // Conflict resolution
  async getConflictItems(): Promise<any[]> {
    if (!this.db) await this.initialize();
    
    const notes = await this.db!.getAllFromIndex('notes', 'by-sync-status', 'conflict');
    const todos = await this.db!.getAllFromIndex('todos', 'by-sync-status', 'conflict');
    const collections = await this.db!.getAllFromIndex('collections', 'by-sync-status', 'conflict');
    
    return [...notes, ...todos, ...collections];
  }

  async resolveConflict(table: 'notes' | 'todos' | 'collections', id: number, resolution: 'local' | 'server'): Promise<void> {
    if (!this.db) await this.initialize();
    
    const item = await this.db!.get(table, id);
    if (item && item.syncStatus === 'conflict') {
      if (resolution === 'local') {
        item.syncStatus = 'pending';
        await this.addToSyncQueue('update', table, item);
      } else {
        item.syncStatus = 'synced';
      }
      await this.db!.put(table, item);
    }
  }
}

export const indexedDBManager = new IndexedDBManager();```

### client/src/lib/queryClient.ts
```typescript
import { QueryClient, QueryFunction } from "@tanstack/react-query";
import { offlineStorage } from "@/store/offline-storage";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  url: string,
  method: string = "GET",
  data?: unknown | undefined,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const url = queryKey[0] as string;
    
    // Try to get from offline storage first if offline
    if (!navigator.onLine) {
      try {
        const cachedData = await offlineStorage.retrieve(url, 'api');
        if (cachedData) {
          return cachedData;
        }
      } catch (error) {
        console.warn('Failed to retrieve from offline storage:', error);
      }
    }

    try {
      const res = await fetch(url, {
        credentials: "include",
      });

      if (unauthorizedBehavior === "returnNull" && res.status === 401) {
        return null;
      }

      await throwIfResNotOk(res);
      const data = await res.json();
      
      // Store successful API responses in offline storage
      if (res.ok && url.startsWith('/api/')) {
        try {
          await offlineStorage.store(url, data, 'api');
        } catch (error) {
          console.warn('Failed to store in offline storage:', error);
        }
      }
      
      return data;
    } catch (error) {
      // Network error - try offline storage as fallback
      try {
        const cachedData = await offlineStorage.retrieve(url, 'api');
        if (cachedData) {
          console.log('Using cached data due to network error:', url);
          return cachedData;
        }
      } catch (storageError) {
        console.warn('Failed to retrieve fallback data:', storageError);
      }
      
      throw error;
    }
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: 2 * 60 * 1000, // 2 minutes cache for faster navigation
      gcTime: 10 * 60 * 1000, // 10 minutes in memory
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});
```

### client/src/lib/sync-service.ts
```typescript
import { indexedDBManager } from './indexeddb';
import { apiRequest } from './queryClient';
import type { NoteWithTodos, Todo, Collection } from '@shared/schema';

interface SyncStatus {
  isOnline: boolean;
  isSyncing: boolean;
  lastSyncTime: number | null;
  pendingItems: number;
  conflictItems: number;
}

class SyncService {
  private isOnline = navigator.onLine;
  private isSyncing = false;
  private syncCallbacks: Set<(status: SyncStatus) => void> = new Set();
  private syncInterval: NodeJS.Timeout | null = null;

  constructor() {
    this.setupNetworkListeners();
    this.startPeriodicSync();
  }

  private setupNetworkListeners(): void {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.notifyStatusChange();
      this.syncWithServer();
    });

    window.addEventListener('offline', () => {
      this.isOnline = false;
      this.notifyStatusChange();
    });
  }

  private startPeriodicSync(): void {
    // Sync every 30 seconds when online
    this.syncInterval = setInterval(() => {
      if (this.isOnline && !this.isSyncing) {
        this.syncWithServer();
      }
    }, 30000);
  }

  onStatusChange(callback: (status: SyncStatus) => void): () => void {
    this.syncCallbacks.add(callback);
    // Return unsubscribe function
    return () => this.syncCallbacks.delete(callback);
  }

  private async notifyStatusChange(): Promise<void> {
    const status = await this.getStatus();
    this.syncCallbacks.forEach(callback => callback(status));
  }

  async getStatus(): Promise<SyncStatus> {
    const syncQueue = await indexedDBManager.getSyncQueue();
    const conflictItems = await indexedDBManager.getConflictItems();
    
    return {
      isOnline: this.isOnline,
      isSyncing: this.isSyncing,
      lastSyncTime: this.getLastSyncTime(),
      pendingItems: syncQueue.length,
      conflictItems: conflictItems.length,
    };
  }

  private getLastSyncTime(): number | null {
    const lastSync = localStorage.getItem('mira-last-sync');
    return lastSync ? parseInt(lastSync) : null;
  }

  private setLastSyncTime(): void {
    localStorage.setItem('mira-last-sync', Date.now().toString());
  }

  async syncWithServer(): Promise<void> {
    if (!this.isOnline || this.isSyncing) return;

    this.isSyncing = true;
    await this.notifyStatusChange();

    try {
      // Step 1: Pull changes from server
      await this.pullFromServer();
      
      // Step 2: Push local changes to server
      await this.pushToServer();
      
      this.setLastSyncTime();
    } catch (error) {
      console.error('Sync failed:', error);
    } finally {
      this.isSyncing = false;
      await this.notifyStatusChange();
    }
  }

  private async pullFromServer(): Promise<void> {
    try {
      // Fetch latest data from server
      const [notesResponse, collectionsResponse] = await Promise.all([
        fetch('/api/notes'),
        fetch('/api/collections')
      ]);

      if (notesResponse.ok && collectionsResponse.ok) {
        const serverNotes: NoteWithTodos[] = await notesResponse.json();
        const serverCollections: Collection[] = await collectionsResponse.json();

        // Save server data to IndexedDB with 'synced' status
        await Promise.all([
          ...serverNotes.map(note => indexedDBManager.saveNote(note, 'synced')),
          ...serverCollections.map(collection => indexedDBManager.saveCollection(collection, 'synced'))
        ]);
      }
    } catch (error) {
      console.error('Failed to pull from server:', error);
    }
  }

  private async pushToServer(): Promise<void> {
    const syncQueue = await indexedDBManager.getSyncQueue();

    for (const item of syncQueue) {
      try {
        await this.processSyncItem(item);
        await indexedDBManager.removeSyncQueueItem(item.id);
      } catch (error) {
        console.error('Failed to sync item:', item, error);
        // Increment retry count or handle conflict
        item.retryCount = (item.retryCount || 0) + 1;
        if (item.retryCount > 3) {
          // Mark as conflict for manual resolution
          await this.markAsConflict(item);
        }
      }
    }
  }

  private async processSyncItem(item: any): Promise<void> {
    const { type, table, data } = item;
    
    switch (table) {
      case 'notes':
        await this.syncNote(type, data);
        break;
      case 'todos':
        await this.syncTodo(type, data);
        break;
      case 'collections':
        await this.syncCollection(type, data);
        break;
    }
  }

  private async syncNote(type: string, data: any): Promise<void> {
    switch (type) {
      case 'create':
        await apiRequest('POST', '/api/notes', data);
        break;
      case 'update':
        await apiRequest('PATCH', `/api/notes/${data.id}`, data);
        break;
      case 'delete':
        await apiRequest('DELETE', `/api/notes/${data.id}`);
        break;
    }
    
    if (data.id) {
      await indexedDBManager.markAsSynced('notes', data.id);
    }
  }

  private async syncTodo(type: string, data: any): Promise<void> {
    switch (type) {
      case 'create':
        await apiRequest('POST', '/api/todos', data);
        break;
      case 'update':
        await apiRequest('PATCH', `/api/todos/${data.id}`, data);
        break;
      case 'delete':
        await apiRequest('DELETE', `/api/todos/${data.id}`);
        break;
    }
    
    if (data.id) {
      await indexedDBManager.markAsSynced('todos', data.id);
    }
  }

  private async syncCollection(type: string, data: any): Promise<void> {
    switch (type) {
      case 'create':
        await apiRequest('POST', '/api/collections', data);
        break;
      case 'update':
        await apiRequest('PATCH', `/api/collections/${data.id}`, data);
        break;
      case 'delete':
        await apiRequest('DELETE', `/api/collections/${data.id}`);
        break;
    }
    
    if (data.id) {
      await indexedDBManager.markAsSynced('collections', data.id);
    }
  }

  private async markAsConflict(item: any): Promise<void> {
    // Mark the item as having a conflict for manual resolution
    console.warn('Item marked as conflict:', item);
    // Implementation would depend on conflict resolution UI
  }

  // Manual operations for offline mode
  async createNoteOffline(note: Omit<NoteWithTodos, 'id'>): Promise<NoteWithTodos> {
    const offlineId = Date.now(); // Temporary ID for offline
    const noteWithId = { ...note, id: offlineId } as NoteWithTodos;
    
    await indexedDBManager.saveNote(noteWithId, 'pending');
    await indexedDBManager.addToSyncQueue('create', 'notes', noteWithId);
    
    return noteWithId;
  }

  async updateNoteOffline(id: number, updates: Partial<NoteWithTodos>): Promise<void> {
    const existingNote = await indexedDBManager.getNote(id);
    if (existingNote) {
      const updatedNote = { ...existingNote, ...updates };
      await indexedDBManager.saveNote(updatedNote, 'pending');
      await indexedDBManager.addToSyncQueue('update', 'notes', updatedNote);
    }
  }

  async deleteNoteOffline(id: number): Promise<void> {
    await indexedDBManager.deleteNote(id);
    // Sync queue item is added automatically in deleteNote method
  }

  async createTodoOffline(todo: Omit<Todo, 'id'>): Promise<Todo> {
    const offlineId = Date.now();
    const todoWithId = { ...todo, id: offlineId } as Todo;
    
    await indexedDBManager.saveTodo(todoWithId, 'pending');
    await indexedDBManager.addToSyncQueue('create', 'todos', todoWithId);
    
    return todoWithId;
  }

  async updateTodoOffline(id: number, updates: Partial<Todo>): Promise<void> {
    // Get existing todo from IndexedDB and update
    const todos = await indexedDBManager.getTodosByNoteId(updates.noteId || 0);
    const existingTodo = todos.find(t => t.id === id);
    
    if (existingTodo) {
      const updatedTodo = { ...existingTodo, ...updates };
      await indexedDBManager.saveTodo(updatedTodo, 'pending');
      await indexedDBManager.addToSyncQueue('update', 'todos', updatedTodo);
    }
  }

  async getNotesOffline(): Promise<NoteWithTodos[]> {
    return indexedDBManager.getNotes();
  }

  async getCollectionsOffline(): Promise<Collection[]> {
    return indexedDBManager.getCollections();
  }

  destroy(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
    this.syncCallbacks.clear();
  }
}

export const syncService = new SyncService();```

### client/src/lib/utils.ts
```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

### client/src/main.tsx
```typescript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);```

### client/src/pages/collection-detail.tsx
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { ChevronLeft, MessageSquare, Plus, Share, MoreVertical } from "lucide-react";
import { getQueryFn, apiRequest, queryClient } from "@/lib/queryClient";
import { getCollectionColor } from "@/lib/collection-colors";
import * as Icons from "lucide-react";
import { useState } from "react";
import type { NoteWithTodos, Collection } from "@shared/schema";

const getIconComponent = (iconName: string) => {
  const iconMap: Record<string, any> = {
    coffee: Icons.Coffee,
    lightbulb: Icons.Lightbulb,
    book: Icons.Book,
    heart: Icons.Heart,
    star: Icons.Star,
    briefcase: Icons.Briefcase,
    home: Icons.Home,
    car: Icons.Car,
    plane: Icons.Plane,
    checklist: Icons.CheckSquare,
    calendar: Icons.Calendar,
    location: Icons.MapPin,
    shopping: Icons.ShoppingBag,
    play: Icons.Play,
  };
  return iconMap[iconName] || Icons.Folder;
};

interface SuperNoteData {
  collection: Collection;
  aggregatedContent: string;
  description: string;
  insights: string[];
  structuredItems?: any;
  allTodos?: any[];
  items: any[];
  notes: NoteWithTodos[];
  itemCount: number;
  todoCount?: number;
}

export default function CollectionDetail() {
  const { id } = useParams();
  const [, setLocation] = useLocation();
  const [isGeneratingSuper, setIsGeneratingSuper] = useState(false);

  const { data: collection } = useQuery<Collection>({
    queryKey: ["/api/collections", id],
    queryFn: getQueryFn({ on401: "throw" }),
    enabled: !!id,
  });

  const { data: notes } = useQuery<NoteWithTodos[]>({
    queryKey: ["/api/collections", id, "notes"],
    queryFn: getQueryFn({ on401: "throw" }),
    enabled: !!id,
  });

  const generateSuperNoteMutation = useMutation({
    mutationFn: async () => {
      if (!id) throw new Error("No collection ID");
      const response = await apiRequest("POST", `/api/collections/${id}/super-note`);
      return response.json();
    },
    onSuccess: (data: SuperNoteData) => {
      queryClient.setQueryData(["/api/collections", id, "super-note"], data);
    },
  });

  const { data: superNote } = useQuery<SuperNoteData>({
    queryKey: ["/api/collections", id, "super-note"],
    queryFn: getQueryFn({ on401: "throw" }),
    enabled: !!collection && !!notes && !!id,
  });

  const handleGenerateSuper = () => {
    setIsGeneratingSuper(true);
    generateSuperNoteMutation.mutate();
  };

  if (!collection || !notes || !id || id === null) {
    return (
      <div className="mx-auto max-w-sm w-full h-full flex flex-col">
        <header className="bg-white px-4 py-3 border-b border-gray-100 flex-shrink-0">
          <div className="flex items-center justify-between">
            <button 
              onClick={() => setLocation("/")}
              className="flex items-center text-[hsl(var(--ios-blue))] touch-manipulation"
            >
              <ChevronLeft className="w-5 h-5 mr-1" />
              Back
            </button>
            <h1 className="text-lg font-semibold">Loading...</h1>
            <div className="w-12"></div>
          </div>
        </header>
        <div className="flex-1 flex items-center justify-center">
          <div className="animate-pulse text-center">
            <div className="w-16 h-16 bg-gray-200 rounded-full mx-auto mb-4"></div>
            <div className="h-4 bg-gray-200 rounded w-32 mx-auto"></div>
          </div>
        </div>
      </div>
    );
  }

  const IconComponent = getIconComponent(collection?.icon || 'folder');
  const colors = getCollectionColor(collection?.color || 'gray');

  return (
    <div className="w-full h-full flex flex-col bg-white">
      {/* Header */}
      <header className="bg-white px-4 py-3 border-b border-gray-100 flex-shrink-0">
        <div className="flex items-center justify-between">
          <button 
            onClick={() => {
              // Always go back to collections tab when coming from collection detail
              const referrer = document.referrer;
              if (referrer && referrer.includes('tab=collections')) {
                window.history.back();
              } else {
                setLocation("/?tab=collections");
              }
            }}
            className="flex items-center text-[hsl(var(--ios-blue))] touch-manipulation"
          >
            <ChevronLeft className="w-5 h-5 mr-1" />
            Back
          </button>
          <h1 className="text-lg font-semibold truncate">{collection.name}</h1>
          <button className="p-2 touch-manipulation">
            <MoreVertical className="w-5 h-5 text-gray-500" />
          </button>
        </div>
      </header>

      {/* Collection Header */}
      <div className="p-4 border-b border-gray-100 flex-shrink-0">
        <div className="flex items-center space-x-3 mb-2">
          <div className="w-10 h-10 flex items-center justify-center">
            <IconComponent className={`w-6 h-6 ${colors.text}`} />
          </div>
          <div>
            <h2 className="font-semibold text-lg">{collection.name}</h2>
            <p className="text-xs text-gray-500">
              {superNote ? `${superNote.itemCount} items` : `${notes.length} notes`}
            </p>
          </div>
        </div>

        {superNote && (
          <p className="text-sm text-gray-600 mb-3">{superNote.description}</p>
        )}

        {!superNote && (
          <button
            onClick={handleGenerateSuper}
            disabled={isGeneratingSuper || generateSuperNoteMutation.isPending}
            className="w-full bg-[hsl(var(--ios-blue))] text-white py-3 rounded-xl font-medium disabled:opacity-50 touch-manipulation"
          >
            {isGeneratingSuper || generateSuperNoteMutation.isPending 
              ? 'Creating Super Note...' 
              : 'Generate Super Note'
            }
          </button>
        )}
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        {superNote ? (
          /* Individual Items View */
          <div className="pb-4">
            {/* Items Subheading */}
            <div className="px-4 py-3 bg-gray-50 border-b border-gray-100">
              <h3 className="text-sm font-medium text-gray-700 uppercase tracking-wide">Items</h3>
            </div>

            {/* Individual Line Items */}
            <div className="divide-y divide-gray-100">
              {superNote.items && superNote.items.length > 0 ? (
                (() => {
                  // Separate completed and uncompleted items
                  const uncompleted = superNote.items.filter((item: any) => !item.isProcessed);
                  const completed = superNote.items.filter((item: any) => item.isProcessed);

                  return [...uncompleted, ...completed].map((item: any, index: number) => {
                    const timeAgo = (() => {
                      const now = new Date();
                      const itemDate = new Date(item.createdAt);
                      const diffInSeconds = Math.floor((now.getTime() - itemDate.getTime()) / 1000);

                      if (diffInSeconds < 60) return 'now';
                      if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
                      if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
                      return `${Math.floor(diffInSeconds / 86400)}d ago`;
                    })();

                    return (
                      <div 
                        key={item.id || index} 
                        className={`px-4 py-3 transition-colors ${item.isProcessed ? 'bg-gray-50' : 'hover:bg-gray-50'}`}
                      >
                        <div className="flex items-center justify-between">
                          <div 
                            className="flex-1 min-w-0 cursor-pointer"
                            onClick={() => {
                              if (item.sourceNoteId) {
                                setLocation(`/notes/${item.sourceNoteId}`);
                              }
                            }}
                          >
                            <h4 className={`text-sm font-medium truncate ${item.isProcessed ? 'text-gray-500' : 'text-gray-900'}`}>
                              {item.title}
                            </h4>
                            {item.description && (
                              <p className={`text-xs mt-1 line-clamp-1 ${item.isProcessed ? 'text-gray-400' : 'text-gray-500'}`}>
                                {item.description}
                              </p>
                            )}
                          </div>
                          <div className="flex items-center space-x-2 ml-3">
                            <span className="text-xs text-gray-400">{timeAgo}</span>
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                // TODO: Add API call to update item processed status
                                console.log('Toggle item processed:', item.id);
                              }}
                              className="w-4 h-4 border border-gray-300 rounded flex-shrink-0 flex items-center justify-center hover:border-blue-500 transition-colors"
                            >
                              {item.isProcessed && (
                                <Icons.Check className="w-3 h-3 text-blue-500" />
                              )}
                            </button>
                          </div>
                        </div>
                      </div>
                    );
                  });
                })()
              ) : (
                <div className="px-4 py-8 text-center">
                  <p className="text-sm text-gray-500">No items yet</p>
                </div>
              )}
            </div>

            {/* Source Notes Link */}
            {superNote.notes && superNote.notes.length > 0 && (
              <div className="border-t border-gray-100 mt-6 pt-4 px-4">
                <button
                  onClick={() => {
                    // Navigate to the first source note if only one, otherwise show a list
                    if (superNote.notes.length === 1) {
                      setLocation(`/notes/${superNote.notes[0].id}`);
                    } else {
                      // For now, navigate to the most recent note
                      const mostRecent = superNote.notes.sort((a, b) => 
                        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
                      )[0];
                      setLocation(`/notes/${mostRecent.id}`);
                    }
                  }}
                  className="text-sm text-blue-600 hover:text-blue-800 transition-colors"
                >
                  View original note{superNote.notes.length > 1 ? 's' : ''} →
                </button>
              </div>
            )}
          </div>
        ) : notes.length > 0 ? (
          /* Regular Notes List */
          <div className="p-4">
            <div className="space-y-2">
              {notes.map((note, index) => {
                const timeAgo = (() => {
                  const now = new Date();
                  const noteDate = new Date(note.createdAt);
                  const diffInSeconds = Math.floor((now.getTime() - noteDate.getTime()) / 1000);

                  if (diffInSeconds < 60) return 'now';
                  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
                  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
                  return `${Math.floor(diffInSeconds / 86400)}d ago`;
                })();

                return (
                  <div 
                    key={note.id} 
                    className="flex items-center py-2 px-3 hover:bg-gray-50 cursor-pointer border-b border-gray-100"
                    onClick={() => setLocation(`/notes/${note.id}`)}
                  >
                    <div className="flex-1 min-w-0">
                      <div className="text-sm text-gray-900 truncate">
                        {note.content ? note.content.split('\n')[0].replace(/^\[.*?\]\s*/, '').substring(0, 80) : 'Untitled Note'}
                        {note.content && note.content.length > 80 && '...'}
                      </div>
                    </div>

                    <div className="flex items-center space-x-3 ml-3 flex-shrink-0">
                      {note.todos && note.todos.length > 0 && (
                        <div className="flex items-center space-x-1">
                          <Icons.CheckSquare className="w-3 h-3 text-blue-500" />
                          <span className="text-xs text-gray-600">
                            {note.todos.filter(t => t.completed).length}/{note.todos.length}
                          </span>
                        </div>
                      )}

                      <div className="flex items-center space-x-1">
                        {note.mode === 'standard' && <Icons.MessageSquare className="w-3 h-3 text-gray-400" />}
                        {note.mode === 'voice' && <Icons.Mic className="w-3 h-3 text-blue-500" />}
                        {note.mode === 'camera' && <Icons.Camera className="w-3 h-3 text-green-500" />}
                        {note.mode === 'file' && <Icons.File className="w-3 h-3 text-purple-500" />}
                      </div>

                      <span className="text-xs text-gray-500 min-w-0">{timeAgo}</span>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ) : (
          <div className="p-4 text-center text-gray-500">
            <Icons.Folder className="w-12 h-12 mx-auto mb-4 text-gray-300" />
            <p>No notes in this collection yet</p>
          </div>
        )}
      </div>
    </div>
  );
}```

### client/src/pages/note-detail-broken.tsx
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { ArrowLeft, Clock, MessageSquare, CheckSquare, Folder, Share2, Edit3, Send, Shell, Fish, Anchor, Ship, Eye, GraduationCap, Sparkles, Zap, Gem, Circle, MoreHorizontal, Star, Archive, Trash2, Camera, Mic, Paperclip, Image, File, Copy, ArrowUpRight } from "lucide-react";
import { format, formatDistanceToNow } from "date-fns";
import { NoteWithTodos, Todo } from "@shared/schema";
import { useToast } from "@/hooks/use-toast";
import { useState, useEffect, useRef } from "react";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";


export default function NoteDetail() {
  const { id } = useParams();
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const [isEditing, setIsEditing] = useState(false);
  const [editedContent, setEditedContent] = useState('');
  const [contextInput, setContextInput] = useState('');
  const [showContextDialog, setShowContextDialog] = useState(false);
  const [updateInput, setUpdateInput] = useState('');
  const [showUpdateArea, setShowUpdateArea] = useState(true); // Always show floating chat bar
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const { data: noteData, isLoading, error } = useQuery<NoteWithTodos>({
    queryKey: [`/api/notes/${id}`],
    enabled: !!id,
    refetchInterval: (data) => {
      // Auto-refresh every 2 seconds if AI hasn't enhanced the note yet
      const note = Array.isArray(data) ? data[0] : data;
      return note && !note.aiEnhanced ? 2000 : false;
    },
  });

  // Handle both single object and array responses
  const note = Array.isArray(noteData) ? noteData[0] : noteData;

  // Debug logging
  console.log('Note Detail Debug:', { id, noteData, note, isLoading, error });

  // Mutation to update note with AI enhancement
  const updateNoteMutation = useMutation({
    mutationFn: async ({ content, newContext, updateInstruction }: { content: string; newContext?: string; updateInstruction?: string }) => {
      const response = await apiRequest("PATCH", `/api/notes/${id}`, {
        content,
        ...(newContext && { contextUpdate: newContext }),
        ...(updateInstruction && { updateInstruction })
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      setIsEditing(false);
      setContextInput('');
      setUpdateInput('');
      setShowUpdateArea(false);
      toast({
        description: "Note updated successfully!",
      });
    },
    onError: () => {
      toast({
        description: "Failed to update note",
        variant: "destructive",
      });
    },
  });

  // Mutation to delete note
  const deleteNoteMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("DELETE", `/api/notes/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      setLocation("/");
      toast({
        description: "Note deleted successfully!",
      });
    },
    onError: () => {
      toast({
        description: "Failed to delete note",
        variant: "destructive",
      });
    },
  });

  const handleDeleteNote = () => {
    console.log("Delete note clicked for note:", id);
    if (confirm("Are you sure you want to delete this note? This action cannot be undone.")) {
      console.log("User confirmed deletion, calling delete mutation");
      deleteNoteMutation.mutate();
    } else {
      console.log("User cancelled deletion");
    }
  };

  const handleUpdateNote = () => {
    if (!updateInput.trim() || !note) return;
    
    updateNoteMutation.mutate({
      content: note.content,
      updateInstruction: updateInput
    });
  };

  // Initialize editing content when note loads
  useEffect(() => {
    if (note && !editedContent) {
      setEditedContent(note.content || '');
    }
  }, [note, editedContent]);

  // Auto-show context dialog for urgent questions
  useEffect(() => {
    if (note?.aiSuggestion?.includes('🚨') && !showContextDialog) {
      setShowContextDialog(true);
    }
  }, [note?.aiSuggestion, showContextDialog]);

  const handleShare = () => {
    if (!note) return;
    
    const shareText = formatNoteForSharing(note);
    
    if (navigator.share) {
      navigator.share({
        title: `Note from ${note.createdAt ? formatDistanceToNow(new Date(note.createdAt), { addSuffix: true }) : 'recently'}`,
        text: shareText,
      }).catch(console.error);
    } else {
      navigator.clipboard.writeText(shareText).then(() => {
        toast({
          description: "Note copied to clipboard!",
        });
      }).catch(() => {
        toast({
          description: "Failed to copy note",
          variant: "destructive",
        });
      });
    }
  };

  const formatNoteForSharing = (note: NoteWithTodos) => {
    let shareText = `📝 Note from ${formatDistanceToNow(new Date(note.createdAt), { addSuffix: true })}\n\n`;
    
    shareText += `${note.content}\n\n`;
    
    if (note.aiContext) {
      shareText += `💡 Context:\n${note.aiContext}\n\n`;
    }
    
    if (note.aiSuggestion) {
      shareText += `🤔 Follow-up:\n${note.aiSuggestion}\n\n`;
    }
    
    if (note.todos && note.todos.length > 0) {
      shareText += `✅ Action Items:\n`;
      note.todos.forEach((todo) => {
        const status = todo.completed ? '✓' : '○';
        shareText += `${status} ${todo.title}\n`;
      });
      shareText += '\n';
    }
    
    if (note.collection) {
      shareText += `📁 Collection: ${note.collection.name}\n\n`;
    }
    
    shareText += `Shared from Mira`;
    
    return shareText;
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-[hsl(var(--background))] p-4">
        <div className="max-w-2xl mx-auto">
          <div className="flex items-center gap-3 mb-6">
            <div className="w-6 h-6 bg-gray-200 rounded animate-pulse"></div>
            <div className="h-6 bg-gray-200 rounded w-32 animate-pulse"></div>
          </div>
          <div className="space-y-4">
            <div className="h-4 bg-gray-200 rounded w-full animate-pulse"></div>
            <div className="h-4 bg-gray-200 rounded w-3/4 animate-pulse"></div>
            <div className="h-4 bg-gray-200 rounded w-1/2 animate-pulse"></div>
          </div>
        </div>
      </div>
    );
  }

  if (!note) {
    return (
      <div className="min-h-screen bg-[hsl(var(--background))] p-4">
        <div className="max-w-md mx-auto text-center py-12">
          <h1 className="text-xl font-semibold mb-2">Note not found</h1>
          <p className="text-[hsl(var(--muted-foreground))] mb-4">
            The note you're looking for doesn't exist or has been deleted.
          </p>
          <button
            onClick={() => setLocation("/")}
            className="text-[hsl(var(--ios-blue))] font-medium"
          >
            Go back to notes
          </button>
        </div>
      </div>
    );
  }

  // Enhanced content rendering with rich media
  const renderEnhancedContent = (content: string) => {
    // Split content by lines and process each line
    const lines = content.split('\n');
    const elements: JSX.Element[] = [];
    
    lines.forEach((line, index) => {
      // Check for image URLs
      const imageRegex = /https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp|svg)(\?[^\s]*)?/gi;
      const videoRegex = /https?:\/\/[^\s]+\.(mp4|webm|mov|avi|mkv)(\?[^\s]*)?/gi;
      const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]+)/gi;
      
      if (imageRegex.test(line)) {
        const imageUrls = line.match(imageRegex);
        imageUrls?.forEach((url, imgIndex) => {
          elements.push(
            <div key={`${index}-img-${imgIndex}`} className="my-3">
              <img 
                src={url} 
                alt="Inline image" 
                className="w-full rounded-lg border border-[hsl(var(--border))] max-h-80 object-cover"
                loading="lazy"
                onError={(e) => {
                  (e.target as HTMLImageElement).style.display = 'none';
                }}
              />
            </div>
          );
        });
      } else if (videoRegex.test(line)) {
        const videoUrls = line.match(videoRegex);
        videoUrls?.forEach((url, vidIndex) => {
          elements.push(
            <div key={`${index}-vid-${vidIndex}`} className="my-3">
              <video 
                src={url} 
                controls 
                className="w-full rounded-lg border border-[hsl(var(--border))] max-h-80"
                preload="metadata"
              >
                Your browser does not support the video tag.
              </video>
            </div>
          );
        });
      } else if (youtubeRegex.test(line)) {
        let match;
        let ytIndex = 0;
        youtubeRegex.lastIndex = 0; // Reset regex
        while ((match = youtubeRegex.exec(line)) !== null) {
          const videoId = match[1];
          elements.push(
            <div key={`${index}-yt-${ytIndex}`} className="my-3">
              <div className="relative w-full h-48 bg-gray-100 rounded-lg overflow-hidden">
                <iframe
                  src={`https://www.youtube.com/embed/${videoId}`}
                  title="YouTube video"
                  className="absolute inset-0 w-full h-full"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowFullScreen
                />
              </div>
            </div>
          );
          ytIndex++;
        }
      } else if (line.trim()) {
        // Regular text content
        elements.push(
          <p key={`${index}-text`} className="mb-2 leading-relaxed">
            {line}
          </p>
        );
      }
    });
    
    return elements;
  };

  return (
    <div className="min-h-screen bg-[hsl(var(--background))] pb-24">
      <div className="w-full">
        {/* Header */}
        <div className="flex items-center justify-between px-4 py-3 bg-[hsl(var(--card))] border-b border-[hsl(var(--border))]">
          <div className="flex items-center gap-3">
            <button
              onClick={() => setLocation("/")}
              className="w-8 h-8 flex items-center justify-center rounded-full bg-[hsl(var(--background))] border border-[hsl(var(--border))]"
            >
              <ArrowLeft className="w-4 h-4" />
            </button>
            <div className="flex items-center gap-2">
              <h1 className="text-lg font-semibold">Note Details</h1>
              {!note.aiEnhanced && (
                <div className="flex items-center gap-1">
                  <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                  <span className="text-xs text-gray-500">AI processing...</span>
                </div>
              )}
            </div>
          </div>
          <div className="flex items-center gap-2">
            <button
              onClick={handleShare}
              className="w-6 h-6 rounded-md bg-[hsl(var(--muted))] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
              title="Share note"
            >
              <ArrowUpRight className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
            </button>
            
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <button
                  className="w-6 h-6 rounded-md bg-[hsl(var(--muted))] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
                  title="More options"
                >
                  <MoreHorizontal className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
                </button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-48">
                <DropdownMenuItem>
                  <Star className="w-4 h-4 mr-2" />
                  Star Note
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Copy className="w-4 h-4 mr-2" />
                  Duplicate
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Archive className="w-4 h-4 mr-2" />
                  Archive
                </DropdownMenuItem>
                <DropdownMenuItem 
                  className="text-red-600"
                  onClick={handleDeleteNote}
                  disabled={deleteNoteMutation.isPending}
                >
                  <Trash2 className="w-4 h-4 mr-2" />
                  {deleteNoteMutation.isPending ? 'Deleting...' : 'Delete'}
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>

        {/* Note Content */}
        <div className="bg-[hsl(var(--card))] border-b border-[hsl(var(--border))]">
          <div className="px-4 py-6 space-y-4">
            {/* Main Content */}
            <div>
              {isEditing ? (
                <textarea
                  value={editedContent}
                  onChange={(e) => setEditedContent(e.target.value)}
                  className="w-full min-h-[120px] p-3 border border-[hsl(var(--border))] rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-[hsl(var(--sage-green))] bg-[hsl(var(--background))]"
                  placeholder="Edit your note..."
                />
              ) : (
                <div className="text-[hsl(var(--foreground))] leading-relaxed">
                  {renderEnhancedContent(note.content)}
                </div>
              )}
              
              {isEditing && (
                <div className="flex justify-end gap-2 mt-3">
                  <button
                    onClick={() => {
                      setIsEditing(false);
                      setEditedContent(note?.content || '');
                    }}
                    className="px-3 py-1 text-sm text-[hsl(var(--muted-foreground))] hover:text-[hsl(var(--foreground))]"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={() => {
                      updateNoteMutation.mutate({ content: editedContent });
                    }}
                    disabled={updateNoteMutation.isPending}
                    className="px-3 py-1 text-sm bg-[hsl(var(--sage-green))] text-white rounded-md hover:bg-[hsl(var(--sage-green))]/90 disabled:opacity-50"
                  >
                    {updateNoteMutation.isPending ? 'Saving...' : 'Save'}
                  </button>
                </div>
              )}
            </div>

            {/* Metadata */}
            <div className="flex items-center gap-4 text-sm text-[hsl(var(--muted-foreground))] pt-3 border-t border-[hsl(var(--border))]">
              <div className="flex items-center gap-1">
                <Clock className="w-4 h-4" />
                <span>{note.createdAt ? format(new Date(note.createdAt), "MMM d, yyyy 'at' h:mm a") : 'Unknown date'}</span>
              </div>
              {note.mode && (
                <div className="flex items-center gap-1">
                  {note.mode === 'standard' && <MessageSquare className="w-4 h-4" aria-label="Text input" />}
                  {note.mode === 'voice' && <Mic className="w-4 h-4" aria-label="Voice input" />}
                  {note.mode === 'camera' && <Camera className="w-4 h-4" aria-label="Camera input" />}
                  {note.mode === 'file' && <File className="w-4 h-4" aria-label="File upload" />}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* AI Research Results - Google-style */}
        {note.richContext && (
          <div className="space-y-4">
            {(() => {
              try {
                const richData = JSON.parse(note.richContext);
                return (
                  <>
                    {/* Recommended Actions */}
                    {richData.recommendedActions && richData.recommendedActions.length > 0 && (
                      <div className="bg-[hsl(var(--card))] border-b border-[hsl(var(--border))]">
                        <div className="px-4 py-6">
                          <div className="flex items-center gap-2 mb-3">
                          <div className="w-5 h-5 bg-blue-500 rounded flex items-center justify-center">
                            <span className="text-white text-xs font-bold">1</span>
                          </div>
                          <h3 className="font-medium text-[hsl(var(--foreground))]">Recommended Next Steps</h3>
                        </div>
                        <div className="space-y-2">
                          {richData.recommendedActions.map((action: any, index: number) => (
                            <div key={index} className="p-3 bg-blue-50 border border-blue-200 rounded-lg">
                              <div className="font-medium text-sm text-blue-900 mb-1">{action.title}</div>
                              <div className="text-sm text-blue-800 mb-2">{action.description}</div>
                              {action.links && action.links.length > 0 && (
                                <div className="space-y-1">
                                  {action.links.map((link: any, linkIndex: number) => (
                                    <a 
                                      key={linkIndex} 
                                      href={link.url} 
                                      target="_blank" 
                                      rel="noopener noreferrer"
                                      className="block text-xs text-blue-600 hover:text-blue-800 underline"
                                    >
                                      {link.title}
                                    </a>
                                  ))}
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                        </div>
                      </div>
                    )}

                    {/* Research Results */}
                    {richData.researchResults && richData.researchResults.length > 0 && (
                      <div className="bg-[hsl(var(--card))] border-b border-[hsl(var(--border))]">
                        <div className="px-4 py-6">
                          <div className="flex items-center gap-2 mb-3">
                            <div className="w-5 h-5 bg-green-500 rounded flex items-center justify-center">
                              <span className="text-white text-xs font-bold">2</span>
                            </div>
                            <h3 className="font-medium text-[hsl(var(--foreground))]">Research & Options</h3>
                          </div>
                          <div className="space-y-3">
                            {richData.researchResults.map((result: any, index: number) => (
                              <div key={index} className="border border-[hsl(var(--border))] rounded-lg p-3">
                                <div className="flex items-start justify-between mb-2">
                                  <h4 className="font-medium text-sm">{result.title}</h4>
                                  {result.rating && (
                                    <div className="text-xs text-yellow-600 flex items-center gap-1">
                                      <span>★</span>
                                      <span>{result.rating}</span>
                                    </div>
                                  )}
                                </div>
                                <p className="text-sm text-[hsl(var(--muted-foreground))] mb-2">{result.description}</p>
                                {result.keyPoints && (
                                  <ul className="space-y-1 mb-2">
                                    {result.keyPoints.map((point: string, pointIndex: number) => (
                                      <li key={pointIndex} className="text-xs text-[hsl(var(--muted-foreground))] flex items-start gap-1">
                                        <span className="text-green-500">•</span>
                                        {point}
                                      </li>
                                    ))}
                                  </ul>
                                )}
                                {result.contact && (
                                  <div className="text-xs text-blue-600 bg-blue-50 p-2 rounded">
                                    Contact: {result.contact}
                                  </div>
                                )}
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    )}

                    {/* Quick Insights */}
                    {richData.quickInsights && richData.quickInsights.length > 0 && (
                      <div className="bg-[hsl(var(--card))] border-b border-[hsl(var(--border))]">
                        <div className="px-4 py-6">
                          <div className="flex items-center gap-2 mb-3">
                            <div className="w-5 h-5 bg-purple-500 rounded flex items-center justify-center">
                              <span className="text-white text-xs font-bold">3</span>
                            </div>
                            <h3 className="font-medium text-[hsl(var(--foreground))]">Key Considerations</h3>
                          </div>
                          <div className="grid gap-2">
                            {richData.quickInsights.map((insight: string, index: number) => (
                              <div key={index} className="text-sm p-2 bg-purple-50 border-l-2 border-purple-400 rounded-r">
                                {insight}
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    )}
                  </>
                );
              } catch (e) {
                return null;
              }
            })()}
          </div>
        )}

        {/* Todos */}
        {note.todos && note.todos.length > 0 && (
          <div className="bg-[hsl(var(--card))] border-b border-[hsl(var(--border))]">
            <div className="px-4 py-6">
              <div className="flex items-start gap-3">
                <div className="w-8 h-8 bg-[hsl(var(--coral-accent))] rounded-lg flex items-center justify-center flex-shrink-0">
                  <CheckSquare className="w-4 h-4 text-white" />
                </div>
                <div className="flex-1">
                  <h3 className="font-medium mb-3">Action Items</h3>
                  <div className="space-y-2">
                    {note.todos.map((todo: Todo) => (
                    <div key={todo.id} className="flex items-center gap-3">
                      <div className={`w-4 h-4 rounded border-2 flex items-center justify-center ${
                        todo.completed 
                          ? 'bg-[hsl(var(--sage-green))] border-[hsl(var(--sage-green))]' 
                          : 'border-[hsl(var(--border))]'
                      }`}>
                        {todo.completed && (
                          <CheckSquare className="w-3 h-3 text-white" />
                        )}
                      </div>
                      <span className={`flex-1 ${
                        todo.completed ? 'line-through text-[hsl(var(--muted-foreground))]' : ''
                      }`}>
                        {todo.title}
                      </span>
                      {todo.priority === 'urgent' && (
                        <span className="text-xs bg-red-100 text-red-700 px-2 py-0.5 rounded-full">
                          Urgent
                        </span>
                      )}
                      {todo.pinned && (
                        <span className="text-xs bg-yellow-100 text-yellow-700 px-2 py-0.5 rounded-full">
                          Pinned
                        </span>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Collection */}
        {note.collection && (
          <div className="note-card">
            <div className="flex items-center gap-3">
              <div className="w-8 h-8 bg-[hsl(var(--soft-gray))] rounded-lg flex items-center justify-center">
                <Folder className="w-4 h-4 text-white" />
              </div>
              <div>
                <h3 className="font-medium">Collection</h3>
                <p className="text-sm text-[hsl(var(--muted-foreground))]">
                  {note.collection.name}
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Floating Chat Bubble */}
        {showUpdateArea && (
          <div className="fixed bottom-4 left-4 right-4 z-50">
            <div className="max-w-md mx-auto">
              <div className="bg-[hsl(var(--card))] border border-[hsl(var(--border))] rounded-3xl shadow-lg overflow-hidden min-h-[60px]">
                <div className="flex items-center h-full px-2 py-2 bg-[#ffffffdb]">
                  {/* Add Media Button */}
                  <button
                    onClick={() => {
                      toast({ description: "Media capture coming soon!" });
                    }}
                    className="w-12 h-12 flex items-center justify-center rounded-full hover:bg-[hsl(var(--dusty-teal))] transition-colors flex-shrink-0 bg-[#f1efe8]"
                    title="Add media"
                  >
                    <span className="text-[#7d7d7d] text-[30px] font-light">+</span>
                  </button>
                  
                  {/* Text Input */}
                  <textarea
                    value={updateInput}
                    onChange={(e) => setUpdateInput(e.target.value)}
                    placeholder="update anything here..."
                    className="flex-1 min-h-[44px] max-h-[120px] px-3 py-3 text-sm resize-none focus:outline-none bg-transparent"
                    style={{ lineHeight: '1.4' }}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey && updateInput.trim()) {
                        e.preventDefault();
                        handleUpdateNote();
                      }
                    }}
                  />
                  
                  {/* Right side buttons */}
                  <div className="flex items-center pr-1">
                    <button
                      onClick={() => {
                        toast({ description: "Voice recording coming soon!" });
                      }}
                      className="w-12 h-12 flex items-center justify-center rounded-full hover:bg-[hsl(var(--dusty-teal))] transition-colors bg-[#a2cddc]"
                      title="Voice note"
                    >
                      <Mic className="w-5 h-5 text-white" />
                    </button>
                    
                    {/* Send Button - only show when there's content */}
                    {updateInput.trim() && (
                      <button
                        onClick={handleUpdateNote}
                        disabled={updateNoteMutation.isPending}
                        className="w-8 h-8 flex items-center justify-center rounded-full bg-[hsl(var(--sage-green))] text-white hover:bg-[hsl(var(--sage-green))]/90 disabled:opacity-50 transition-all ml-1"
                        title="Send update"
                      >
                        {updateNoteMutation.isPending ? (
                          <div className="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                        ) : (
                          <Send className="w-3 h-3" />
                        )}
                      </button>
                    )}
                  </div>
                </div>
              </div>
              
              {/* Hidden file input */}
              <input
                ref={fileInputRef}
                type="file"
                accept="image/*,video/*,.pdf,.doc,.docx,.txt"
                className="hidden"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) {
                    toast({ description: `File "${file.name}" selected. Upload functionality coming soon!` });
                  }
                }}
              />
            </div>
          </div>
        )}

        {/* Context Dialog (kept for backward compatibility) */}
        {showContextDialog && (
          <div className="fixed bottom-4 left-4 right-4 max-w-md mx-auto bg-[hsl(var(--card))] border border-[hsl(var(--border))] rounded-xl shadow-lg p-4 z-50">
            <div className="flex items-start gap-3">
              <div className="w-8 h-8 bg-[hsl(var(--sage-green))] rounded-lg flex items-center justify-center flex-shrink-0">
                <span className="text-white font-bold italic text-sm">M</span>
              </div>
              <div className="flex-1">
                <h4 className="text-sm font-medium mb-2 text-[hsl(var(--sage-green))]">Add Context</h4>
                {note?.aiSuggestion?.includes('🚨') && (
                  <p className="text-xs text-[hsl(var(--muted-foreground))] mb-2">
                    Mira needs more information to help with urgent planning
                  </p>
                )}
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={contextInput}
                    onChange={(e) => setContextInput(e.target.value)}
                    placeholder="e.g., March 15th, or any additional details..."
                    className="flex-1 px-3 py-2 text-sm border border-[hsl(var(--border))] rounded-md focus:outline-none focus:ring-2 focus:ring-[hsl(var(--sage-green))] bg-[hsl(var(--background))]"
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        if (contextInput.trim()) {
                          updateNoteMutation.mutate({ 
                            content: editedContent || note?.content || '', 
                            newContext: contextInput 
                          });
                        }
                      }
                    }}
                  />
                  <button
                    onClick={() => {
                      if (contextInput.trim()) {
                        updateNoteMutation.mutate({ 
                          content: editedContent || note?.content || '', 
                          newContext: contextInput 
                        });
                      }
                    }}
                    disabled={updateNoteMutation.isPending || !contextInput.trim()}
                    className="px-3 py-2 bg-[hsl(var(--sage-green))] text-white rounded-md hover:bg-[hsl(var(--sage-green))]/90 disabled:opacity-50 flex items-center justify-center"
                  >
                    <Send className="w-4 h-4" />
                  </button>
                </div>
                <button
                  onClick={() => setShowContextDialog(false)}
                  className="text-xs text-[hsl(var(--muted-foreground))] hover:text-[hsl(var(--foreground))] mt-2"
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}```

### client/src/pages/note-detail-new.tsx
```typescript
import { useState, useEffect, useRef } from "react";
import { useParams, useLocation as useRouterLocation } from "wouter";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { ArrowLeft, ArrowUpRight, MoreHorizontal, Trash2, History, Star, Copy, Zap, Calendar, Bell, CheckSquare, Plus } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { MediaDisplay } from "@/components/MediaDisplay";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { apiRequest } from "@/lib/queryClient";

interface Note {
  id: number;
  content: string;
  mode: string;
  mediaUrl?: string;
  aiEnhanced: boolean;
  aiSuggestion?: string;
  aiContext?: string;
  richContext?: string;
  originalContent?: string;
  todos?: Todo[];
  collectionId?: number;
}

interface Todo {
  id: number;
  title: string;
  completed: boolean;
  priority?: string;
}

export default function NoteDetailNew() {
  const { id } = useParams<{ id: string }>();
  const [, setLocation] = useRouterLocation();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [editedTitle, setEditedTitle] = useState("");
  const [editedContent, setEditedContent] = useState("");
  const [showVersionHistory, setShowVersionHistory] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const { data: note, isLoading } = useQuery<Note>({
    queryKey: [`/api/notes/${id}`],
    enabled: !!id,
  });

  const updateNoteMutation = useMutation({
    mutationFn: async (data: { content: string }) => {
      return apiRequest(`/api/notes/${id}`, "PATCH", data);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
    },
  });

  const deleteNoteMutation = useMutation({
    mutationFn: async () => {
      return apiRequest(`/api/notes/${id}`, "DELETE");
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      setLocation("/");
      toast({ description: "Note deleted successfully" });
    },
  });

  const toggleTodoMutation = useMutation({
    mutationFn: async ({ todoId, completed }: { todoId: number; completed: boolean }) => {
      return apiRequest(`/api/todos/${todoId}`, "PATCH", { completed });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
    },
  });

  useEffect(() => {
    if (note) {
      setEditedTitle(note.content);
      setEditedContent(note.content);
    }
  }, [note]);

  const handleShare = async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: note?.content || "Note",
          text: note?.content || "",
        });
      } catch (error) {
        console.log("Share cancelled");
      }
    } else {
      await navigator.clipboard.writeText(note?.content || "");
      toast({ description: "Note copied to clipboard" });
    }
  };

  if (isLoading || !note) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-500">Loading note...</p>
        </div>
      </div>
    );
  }

  const originalUserContent = note.originalContent || (note.aiEnhanced ? extractOriginalFromContent(note.content) : note.content);

  function extractOriginalFromContent(content: string): string {
    const lines = content.split('\n');
    return lines[0] || content;
  }

  return (
    <div className="flex flex-col h-screen bg-[#f5f5f5]">
      {/* Header */}
      <div className="sticky top-0 z-10 flex items-center justify-between px-4 py-3 border-b border-[hsl(var(--border))] bg-[#f5f5f5]">
        <div className="flex items-center gap-3">
          <button
            onClick={() => setLocation("/")}
            className="w-8 h-8 flex items-center justify-center rounded-full bg-[hsl(var(--background))] border border-[hsl(var(--border))]"
          >
            <ArrowLeft className="w-4 h-4" />
          </button>
          <div className="flex items-center gap-2">
            <input
              type="text"
              value={editedTitle}
              onChange={(e) => setEditedTitle(e.target.value)}
              onBlur={() => {
                if (editedTitle !== note.content) {
                  updateNoteMutation.mutate({ content: editedTitle });
                }
              }}
              className="text-lg font-semibold bg-transparent border-none outline-none focus:bg-white focus:border focus:border-blue-300 rounded px-2 py-1"
              placeholder="Note Title"
            />
            {!note.aiEnhanced && (
              <div className="flex items-center gap-1">
                <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                <span className="text-xs text-gray-500">AI processing...</span>
              </div>
            )}
          </div>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={handleShare}
            className="w-6 h-6 rounded-md bg-[hsl(var(--muted))] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
            title="Share note"
          >
            <ArrowUpRight className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
          </button>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <button
                className="w-6 h-6 rounded-md bg-[hsl(var(--muted))] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
                title="More options"
              >
                <MoreHorizontal className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-48">
              <DropdownMenuItem>
                <Star className="w-4 h-4 mr-2" />
                Star Note
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Copy className="w-4 h-4 mr-2" />
                Duplicate
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => setShowVersionHistory(true)}>
                <History className="w-4 h-4 mr-2" />
                Version History
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() => deleteNoteMutation.mutate()}
                className="text-red-600 focus:text-red-600"
              >
                <Trash2 className="w-4 h-4 mr-2" />
                {deleteNoteMutation.isPending ? 'Deleting...' : 'Delete'}
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      {/* Main Content - ChatGPT Style */}
      <div className="flex-1 bg-white overflow-y-auto">
        <div className="max-w-4xl mx-auto px-6 py-8 space-y-6">
          {/* Media Display */}
          {note.mediaUrl && (
            <div className="mb-6">
              <MediaDisplay 
                mediaUrl={note.mediaUrl} 
                filename={note.mediaUrl.split('/').pop()} 
                showControls={true}
              />
            </div>
          )}

          {/* Original User Input */}
          <div className="bg-gray-50 rounded-lg p-4 border-l-4 border-blue-500">
            <div className="text-sm text-gray-600 mb-2 font-medium">Your request:</div>
            <div className="text-gray-900 text-base leading-relaxed">
              {originalUserContent}
            </div>
          </div>

          {/* AI Response Content */}
          {note.aiEnhanced && note.aiContext && note.aiContext !== "Note processed" && (
            <div className="bg-white">
              <div className="prose prose-gray max-w-none">
                <div className="text-gray-800 text-base leading-relaxed whitespace-pre-wrap">
                  {note.aiContext}
                </div>
              </div>
            </div>
          )}

          {/* Todos Section - Clean & Minimal */}
          {note.todos && note.todos.length > 0 && (
            <div className="bg-white border border-gray-200 rounded-lg p-6">
              <div className="flex items-center gap-2 mb-4">
                <CheckSquare className="w-5 h-5 text-blue-600" />
                <h3 className="text-lg font-semibold text-gray-900">Action Items</h3>
              </div>
              <div className="space-y-3">
                {note.todos.map((todo) => (
                  <div key={todo.id} className="flex items-center gap-3 p-3 bg-gray-50 rounded-lg">
                    <button
                      onClick={() => toggleTodoMutation.mutate({
                        todoId: todo.id,
                        completed: !todo.completed
                      })}
                      className={`w-5 h-5 rounded border-2 flex items-center justify-center transition-colors ${
                        todo.completed
                          ? 'bg-green-500 border-green-500 text-white'
                          : 'border-gray-300 hover:border-blue-500'
                      }`}
                    >
                      {todo.completed && <CheckSquare className="w-3 h-3" />}
                    </button>
                    <span className={`flex-1 text-base ${
                      todo.completed ? 'line-through text-gray-500' : 'text-gray-900'
                    }`}>
                      {todo.title}
                    </span>
                    {todo.priority === 'high' && (
                      <span className="text-xs bg-red-100 text-red-700 px-2 py-1 rounded-full">
                        High Priority
                      </span>
                    )}
                  </div>
                ))}
              </div>
              <button className="mt-4 flex items-center gap-2 text-blue-600 hover:text-blue-700 text-sm font-medium">
                <Plus className="w-4 h-4" />
                Add todo
              </button>
            </div>
          )}

          {/* Quick Actions */}
          {note.aiSuggestion && (
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
              <div className="flex items-center gap-2 mb-3">
                <Zap className="w-4 h-4 text-blue-600" />
                <span className="text-sm font-medium text-blue-900">Quick Actions</span>
              </div>
              <div className="flex flex-wrap gap-2">
                {note.aiSuggestion.includes('calendar') && (
                  <button className="flex items-center gap-2 px-3 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition-colors">
                    <Calendar className="w-4 h-4" />
                    Add to Calendar
                  </button>
                )}
                {note.aiSuggestion.includes('reminder') && (
                  <button className="flex items-center gap-2 px-3 py-2 bg-orange-600 text-white rounded-lg text-sm font-medium hover:bg-orange-700 transition-colors">
                    <Bell className="w-4 h-4" />
                    Set Reminder
                  </button>
                )}
              </div>
            </div>
          )}

          {/* Collection Assignment */}
          {note.collectionId && (
            <div className="text-sm text-gray-600">
              <span className="font-medium">Collection:</span> Auto-assigned based on content
            </div>
          )}

          {/* Editable Notes Area */}
          <div className="border-t border-gray-200 pt-6">
            <textarea
              ref={textareaRef}
              value={editedContent}
              onChange={(e) => {
                setEditedContent(e.target.value);
                const target = e.target as HTMLTextAreaElement;
                target.style.height = 'auto';
                target.style.height = target.scrollHeight + 'px';
              }}
              onBlur={() => {
                if (editedContent !== note.content) {
                  updateNoteMutation.mutate({ content: editedContent });
                }
              }}
              className="w-full min-h-[100px] text-base leading-relaxed bg-transparent border-none outline-none resize-none text-gray-800 placeholder-gray-400"
              placeholder="Add your own notes or modifications..."
              style={{ 
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                overflow: 'hidden'
              }}
            />
          </div>
        </div>
      </div>
    </div>
  );
}```

### client/src/pages/note-detail.tsx
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { ArrowLeft, Clock, MessageSquare, CheckSquare, Folder, Share2, Edit3, Send, Shell, Fish, Anchor, Ship, Eye, GraduationCap, Sparkles, Zap, Gem, Circle, MoreHorizontal, Star, Archive, Trash2, Camera, Mic, Paperclip, Image, File, Copy, ArrowUpRight, Plus, Bell, Calendar, ExternalLink, Info, ArrowRight, Undo2, AlertTriangle, CheckCircle, X, Play, Pause } from "lucide-react";
import InputBar from "@/components/input-bar";
import { format, formatDistanceToNow } from "date-fns";
import { NoteWithTodos, Todo } from "@shared/schema";
import { useToast } from "@/hooks/use-toast";
import { useState, useEffect, useRef } from "react";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { CriticalInfoDialog } from "@/components/CriticalInfoDialog";
import { useCriticalInfo } from "@/hooks/useCriticalInfo";

// Voice Note Detail Player Component
interface VoiceNoteDetailPlayerProps {
  note: NoteWithTodos;
}

function VoiceNoteDetailPlayer({ note }: VoiceNoteDetailPlayerProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const audioRef = useRef<HTMLAudioElement>(null);

  const togglePlayback = () => {
    if (!audioRef.current || !note.audioUrl) return;

    if (isPlaying) {
      audioRef.current.pause();
      setIsPlaying(false);
    } else {
      audioRef.current.play();
      setIsPlaying(true);
    }
  };

  const handleTimeUpdate = () => {
    if (audioRef.current) {
      setCurrentTime(audioRef.current.currentTime);
    }
  };

  const handleLoadedMetadata = () => {
    if (audioRef.current) {
      setDuration(audioRef.current.duration);
    }
  };

  const handleSeek = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!audioRef.current || duration === 0) return;

    const rect = e.currentTarget.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const percentage = clickX / rect.width;
    const newTime = percentage * duration;

    audioRef.current.currentTime = newTime;
    setCurrentTime(newTime);
  };

  // Generate waveform based on content
  const generateWaveform = () => {
    const text = note.transcription || note.content;
    const chars = text.split('');
    return Array.from({ length: 64 }, (_, i) => {
      const charCode = chars[i % chars.length]?.charCodeAt(0) || 65;
      const amplitude = (charCode % 100) / 100 * 0.6 + 0.4;
      return amplitude;
    });
  };

  const waveformData = generateWaveform();
  const formatTime = (time: number) => {
    if (!time || !isFinite(time) || isNaN(time)) {
      return '0:00';
    }
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return (
    <div className="mb-6 bg-white">
      {note.audioUrl && (
        <audio
          ref={audioRef}
          src={note.audioUrl}
          onTimeUpdate={handleTimeUpdate}
          onLoadedMetadata={handleLoadedMetadata}
          onEnded={() => setIsPlaying(false)}
          preload="metadata"
        />
      )}
      <div className="flex items-center space-x-4">
        <button 
          onClick={togglePlayback}
          disabled={!note.audioUrl}
          className="w-12 h-12 rounded-full bg-blue-500 flex items-center justify-center hover:bg-blue-600 transition-colors shadow-lg disabled:opacity-50"
        >
          {isPlaying ? (
            <Pause className="w-5 h-5 text-white" />
          ) : (
            <Play className="w-5 h-5 text-white ml-0.5" />
          )}
        </button>
        <div 
          className="flex-1 h-8 flex items-end justify-start space-x-0.5 cursor-pointer overflow-hidden"
          onClick={handleSeek}
          style={{ maxWidth: 'calc(100vw - 200px)' }}
        >
          {waveformData.map((amplitude, i) => {
            const progress = (duration > 0 && isFinite(duration) && !isNaN(duration) && isFinite(currentTime) && !isNaN(currentTime)) ? currentTime / duration : 0;
            const isActive = i / waveformData.length <= progress;
            return (
              <div
                key={i}
                className={`w-1 rounded-full transition-all duration-200 ${
                  isActive 
                    ? 'bg-gradient-to-t from-blue-700 to-blue-500' 
                    : 'bg-gradient-to-t from-blue-600 to-blue-400 opacity-70 hover:opacity-90'
                }`}
                style={{
                  height: `${Math.max(4, amplitude * 28)}px`
                }}
              />
            );
          })}
        </div>
        <div className="flex flex-col items-end">
          <div className="text-sm font-mono text-blue-600 font-medium">
            {duration > 0 && isFinite(duration) && !isNaN(duration) ? formatTime(duration) : '0:00'}
          </div>
          <div className="text-xs text-blue-500">
            {currentTime > 0 && duration > 0 && isFinite(currentTime) && !isNaN(currentTime) ? formatTime(currentTime) : 'Voice Note'}
          </div>
        </div>
      </div>
      
      {/* Fixed input bar at bottom */}
      <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 p-4">
        <InputBar />
      </div>
    </div>
  );
}
import { createCalendarEventFromContent, addToGoogleCalendar } from "@/lib/calendarUtils";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import AIProcessingIndicator from "@/components/ai-processing-indicator";
import MediaDisplay from "@/components/media-display";
import { MarkdownRenderer } from "@/components/MarkdownRenderer";
import { ReminderDialog } from "@/components/reminder-dialog";

export default function NoteDetail() {
  const { id } = useParams();
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const [isEditing, setIsEditing] = useState(false);
  const [editedContent, setEditedContent] = useState('');
  const [editedTitle, setEditedTitle] = useState('');
  const [contextInput, setContextInput] = useState('');
  const [showContextDialog, setShowContextDialog] = useState(false);
  const [showVersionHistory, setShowVersionHistory] = useState(false);
  const [showApprovalDialog, setShowApprovalDialog] = useState(false);
  const [pendingChanges, setPendingChanges] = useState<any>(null);
  const [clarificationInput, setClarificationInput] = useState('');
  const [showReminderDialog, setShowReminderDialog] = useState(false);

  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Parse rich context data if available
  let richContextData = null;
  try {
    if (note?.richContext) {
      richContextData = JSON.parse(note.richContext);
    }
  } catch (e) {
    console.error("Failed to parse richContext:", e);
  }

  // Use critical info hook
  const { criticalQuestion, isVisible, dismissDialog, handleAnswer } = useCriticalInfo(richContextData);

  const { data: note, isLoading, error } = useQuery<NoteWithTodos>({
    queryKey: [`/api/notes/${id}`],
    enabled: !!id,
    refetchInterval: (data) => {
      return data && !data.aiEnhanced ? 2000 : false;
    },
  });

  // Get version history
  const { data: versionHistory } = useQuery({
    queryKey: [`/api/notes/${id}/versions`],
    enabled: !!id && showVersionHistory,
  });

  // Mutations
  const updateNoteMutation = useMutation({
    mutationFn: async ({ content, newContext, updateInstruction }: { content: string; newContext?: string; updateInstruction?: string }) => {
      const response = await fetch(`/api/notes/${id}`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          content,
          ...(newContext && { contextUpdate: newContext }),
          ...(updateInstruction && { updateInstruction })
        }),
      });

      if (!response.ok) {
        const errorData = await response.text();
        throw new Error(`Failed to update note: ${response.status} - ${errorData}`);
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
      // Only show success toast for AI updates, not direct edits
      if (arguments[1]?.updateInstruction) {
        toast({ description: "Note updated successfully" });
      }
      setIsEditing(false);
      setShowContextDialog(false);
    },
    onError: (error) => {
      console.error("Note update error:", error);
      toast({ 
        title: "Failed to save note", 
        description: error instanceof Error ? error.message : "Unknown error",
        variant: "destructive" 
      });
    }
  });

  const deleteNoteMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("DELETE", `/api/notes/${id}`);
    },
    onSuccess: () => {
      toast({ title: "Note deleted successfully" });
      setLocation("/");
    },
    onError: () => {
      toast({ title: "Failed to delete note", variant: "destructive" });
    }
  });

  const toggleTodoMutation = useMutation({
    mutationFn: async (todo: Todo) => {
      await apiRequest("PATCH", `/api/todos/${todo.id}`, {
        completed: !todo.completed
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
    }
  });

  // Rollback mutation
  const rollbackMutation = useMutation({
    mutationFn: async (targetVersion: number) => {
      const response = await apiRequest("POST", `/api/notes/${id}/rollback`, { targetVersion });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
      setShowVersionHistory(false);
      toast({
        title: "Rollback Successful",
        description: "Note has been restored to the previous version",
      });
    },
    onError: () => {
      toast({
        title: "Rollback Failed",
        description: "Could not restore previous version",
        variant: "destructive"
      });
    }
  });

  // Approve changes mutation
  const approveChangesMutation = useMutation({
    mutationFn: async ({ suggestedChanges, userApproved }: { suggestedChanges: string; userApproved: boolean }) => {
      const response = await apiRequest("POST", `/api/notes/${id}/approve-changes`, { suggestedChanges, userApproved });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
      setShowApprovalDialog(false);
      setPendingChanges(null);
      toast({
        title: "Changes Applied",
        description: "AI suggestions have been applied to your note",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Could not apply changes",
        variant: "destructive"
      });
    }
  });

  // Clarification mutation  
  const clarifyMutation = useMutation({
    mutationFn: async ({ originalInstruction, clarification }: { originalInstruction: string; clarification: string }) => {
      const response = await apiRequest("POST", `/api/notes/${id}/clarify`, { originalInstruction, clarification });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
      setClarificationInput('');
      toast({
        title: "Clarification Applied",
        description: "AI has updated the note based on your clarification",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Could not apply clarification",
        variant: "destructive"
      });
    }
  });



  useEffect(() => {
    if (note) {
      setEditedContent(note.content);
      setEditedTitle(note.content.split('\n')[0] || 'Untitled Note');
    }
  }, [note]);

  // Auto-resize textarea when content changes
  useEffect(() => {
    if (textareaRef.current) {
      const textarea = textareaRef.current;
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight + 'px';
    }
  }, [editedContent]);

  const handleQuestionClick = (question: string) => {
    setInputValue(question);
    setIsTyping(true);
  };

  const handleShare = async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: 'Mira Note',
          text: formatNoteForSharing(note),
        });
      } catch (err) {
        console.log('Error sharing:', err);
      }
    } else {
      navigator.clipboard.writeText(formatNoteForSharing(note));
      toast({ title: "Note copied to clipboard" });
    }
  };

  const handleDeleteNote = () => {
    if (window.confirm('Are you sure you want to delete this note?')) {
      deleteNoteMutation.mutate();
    }
  };

  const handleSendMessage = async (text: string) => {
    console.log("Sending AI instruction for note evolution:", text);

    try {
      // Use the evolution endpoint for AI-assisted updates that considers existing content
      const response = await fetch(`/api/notes/${id}/evolve`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          instruction: text.trim(),
          existingContent: note?.content || "",
          existingContext: note?.aiContext || "",
          existingTodos: note?.todos || [],
          existingRichContext: note?.richContext
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: "Unknown error" }));
        console.error("Evolution endpoint error:", errorData);
        throw new Error(errorData.message || `Server error: ${response.status}`);
      }

      const result = await response.json();
      console.log("AI evolution result:", result);

      // Refresh the note data
      queryClient.invalidateQueries({ queryKey: [`/api/notes/${id}`] });
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });

      toast({
        description: "Note enhanced with AI assistance",
      });
    } catch (error) {
      console.error("Failed to enhance note with AI:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      toast({
        title: "Failed to enhance note",
        description: errorMessage,
        variant: "destructive"
      });
    }
  };

  const formatNoteForSharing = (note: NoteWithTodos) => {
    let shareText = `📝 ${note.content}\n\n`;

    if (note.aiContext) {
      shareText += `💡 Context:\n${note.aiContext}\n\n`;
    }

    if (note.aiSuggestion) {
      shareText += `🤔 Follow-up:\n${note.aiSuggestion}\n\n`;
    }

    if (note.todos && note.todos.length > 0) {
      shareText += `✅ Action Items:\n`;
      note.todos.forEach((todo) => {
        const status = todo.completed ? '✓' : '○';
        shareText += `${status} ${todo.title}\n`;
      });
      shareText += '\n';
    }

    if (note.collection) {
      shareText += `📁 Collection: ${note.collection.name}\n\n`;
    }

    shareText += `Shared from Mira`;

    return shareText;
  };

  // Enhanced content rendering with rich media
  const renderEnhancedContent = (content: string) => {
    const lines = content.split('\n');
    const elements: JSX.Element[] = [];

    lines.forEach((line, index) => {
      const imageRegex = /https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp|svg)(\?[^\s]*)?/gi;
      const videoRegex = /https?:\/\/[^\s]+\.(mp4|webm|mov|avi|mkv)(\?[^\s]*)?/gi;
      const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]+)/gi;

      if (imageRegex.test(line)) {
        const imageUrls = line.match(imageRegex);
        imageUrls?.forEach((url, imgIndex) => {
          elements.push(
            <div key={`${index}-img-${imgIndex}`} className="my-3">
              <img 
                src={url} 
                alt="Inline image" 
                className="w-full rounded-lg border border-[hsl(var(--border))] max-h-80 object-cover"
                loading="lazy"
                onError={(e) => {
                  (e.target as HTMLImageElement).style.display = 'none';
                }}
              />
            </div>
          );
        });
      } else if (videoRegex.test(line)) {
        const videoUrls = line.match(videoRegex);
        videoUrls?.forEach((url, vidIndex) => {
          elements.push(
            <div key={`${index}-vid-${vidIndex}`} className="my-3">
              <video 
                src={url} 
                controls 
                className="w-full rounded-lg border border-[hsl(var(--border))] max-h-80"
                preload="metadata"
              >
                Your browser does not support the video tag.
              </video>
            </div>
          );
        });
      } else if (youtubeRegex.test(line)) {
        let match;
        let ytIndex = 0;
        youtubeRegex.lastIndex = 0;
        while ((match = youtubeRegex.exec(line)) !== null) {
          const videoId = match[1];
          elements.push(
            <div key={`${index}-yt-${ytIndex}`} className="my-3">
              <div className="relative w-full h-48 bg-gray-100 rounded-lg overflow-hidden">
                <iframe
                  src={`https://www.youtube.com/embed/${videoId}`}
                  title="YouTube video"
                  className="absolute inset-0 w-full h-full"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowFullScreen
                />
              </div>
            </div>
          );
          ytIndex++;
        }
      } else if (line.trim()) {
        elements.push(
          <p key={`${index}-text`} className="mb-2 leading-relaxed">
            {line}
          </p>
        );
      }
    });

    return elements;
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-[hsl(var(--background))] pb-24">
        <div className="flex items-center gap-3 p-4">
          <div className="w-6 h-6 bg-gray-200 rounded animate-pulse"></div>
          <div className="h-6 bg-gray-200 rounded w-32 animate-pulse"></div>
        </div>
        <div className="px-4 space-y-4">
          <div className="h-4 bg-gray-200 rounded w-full animate-pulse"></div>
          <div className="h-4 bg-gray-200 rounded w-3/4 animate-pulse"></div>
          <div className="h-4 bg-gray-200 rounded w-1/2 animate-pulse"></div>
        </div>
      </div>
    );
  }

  if (!note) {
    return (
      <div className="min-h-screen bg-[hsl(var(--background))] pb-24">
        <div className="text-center py-12 px-4">
          <h1 className="text-xl font-semibold mb-2">Note not found</h1>
          <p className="text-[hsl(var(--muted-foreground))] mb-4">
            This note may have been deleted or moved.
          </p>
          <button
            onClick={() => {
              // Check referrer to return to appropriate page
              const referrer = document.referrer;
              if (referrer && referrer.includes('/remind')) {
                setLocation("/remind");
              } else if (referrer && referrer.includes('/collections')) {
                setLocation("/?tab=collections");
              } else if (window.history.length > 1) {
                window.history.back();
              } else {
                setLocation("/");
              }
            }}
            className="px-4 py-2 bg-[hsl(var(--sage-green))] text-white rounded-md"
          >
            Back to Notes
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[hsl(var(--background))] pb-24">
      <div className="w-full">
        {/* Header */}
        <div className="sticky top-0 z-10 flex items-center justify-between py-3 border-b border-[hsl(var(--border))] bg-[#f5f5f5]">
          <div className="flex items-center gap-3 pl-4">
            <button
              onClick={() => {
                // Check if we came from a specific page
                const referrer = document.referrer;
                if (referrer && (referrer.includes('/remind') || referrer.includes('/collections'))) {
                  window.history.back();
                } else if (window.history.length > 1) {
                  window.history.back();
                } else {
                  setLocation("/");
                }
              }}
              className="w-8 h-8 flex items-center justify-center rounded-full bg-[hsl(var(--background))] border border-[hsl(var(--border))]"
            >
              <ArrowLeft className="w-4 h-4" />
            </button>
            <div className="flex items-center gap-2">
              <div className="text-lg font-semibold px-2 py-1">
                {note.aiGeneratedTitle || note.content.split('\n')[0] || 'Untitled Note'}
              </div>
              {!note.aiEnhanced && (
                <div className="flex items-center gap-1">
                  <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                  <span className="text-xs text-gray-500">AI processing...</span>
                </div>
              )}
            </div>
          </div>
          <div className="flex items-center gap-2 pr-4">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <button
                  className="w-6 h-6 rounded-md bg-[hsl(var(--muted))] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
                  title="More options"
                >
                  <MoreHorizontal className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
                </button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-48">
                <DropdownMenuItem>
                  <Star className="w-4 h-4 mr-2" />
                  Star Note
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Copy className="w-4 h-4 mr-2" />
                  Duplicate
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => setShowVersionHistory(true)}>
                  <Undo2 className="w-4 h-4 mr-2" />
                  Version History
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Archive className="w-4 h-4 mr-2" />
                  Archive
                </DropdownMenuItem>
                <DropdownMenuItem 
                  className="text-red-600"
                  onClick={handleDeleteNote}
                  disabled={deleteNoteMutation.isPending}
                >
                  <Trash2 className="w-4 h-4 mr-2" />
                  {deleteNoteMutation.isPending ? 'Deleting...' : 'Delete'}
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
            <button
              onClick={handleShare}
              className="w-6 h-6 rounded-md bg-[hsl(var(--muted))] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
              title="Share note"
            >
              <ArrowUpRight className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
            </button>
            <button
              onClick={() => setShowReminderDialog(true)}
              className="w-6 h-6 rounded-full bg-[hsl(var(--muted))] active:bg-[hsl(var(--accent))] flex items-center justify-center transition-colors"
              title="Set reminder"
            >
              <Clock className="w-3 h-3 text-[hsl(var(--muted-foreground))]" />
            </button>
          </div>
        </div>

        {/* Document Body - Editable like iOS Notes */}
        <div className="flex-1 bg-white">
          <div className="px-4 py-3 space-y-2">
            {/* Media Display - Full functionality with sharing and download */}
            {note.mediaUrl && (
              <div className="mb-6">
                <MediaDisplay 
                  mediaUrl={note.mediaUrl} 
                  filename={note.mediaUrl.split('/').pop()} 
                  showControls={true}
                />
              </div>
            )}

            {/* Enhanced Voice Note Player */}
            {note.mode === "voice" && note.transcription && (
              <VoiceNoteDetailPlayer note={note} />
            )}

            {/* What You Wrote Section - only show if AI generated a different title */}
            {note.aiGeneratedTitle && note.aiGeneratedTitle !== note.content && (
              <div className="mb-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                <h4 className="font-medium text-gray-900 mb-2 text-sm">What you wrote:</h4>
                <div className="text-gray-700 text-sm leading-relaxed">{note.content}</div>
              </div>
            )}

            <textarea
              ref={textareaRef}
              value={editedContent}
              onChange={(e) => {
                setEditedContent(e.target.value);
                const target = e.target as HTMLTextAreaElement;
                target.style.height = 'auto';
                target.style.height = target.scrollHeight + 'px';
              }}
              onBlur={() => {
                if (editedContent !== note.content) {
                  updateNoteMutation.mutate({ content: editedContent });
                }
              }}
              onInput={(e) => {
                const target = e.target as HTMLTextAreaElement;
                target.style.height = 'auto';
                target.style.height = target.scrollHeight + 'px';
              }}
              className="w-full min-h-[120px] text-base leading-relaxed bg-transparent border-none outline-none resize-none font-normal text-gray-800 placeholder-gray-400 mb-4"
              placeholder={note.aiGeneratedTitle ? "AI analysis and enhanced content..." : "Start writing..."}
              style={{ 
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                overflow: 'hidden'
              }}
            />

            {/* AI Enhanced Content - ChatGPT Style with Rich Formatting */}
            {note.aiEnhanced && note.aiContext && note.aiContext !== "Note processed" && (
              <div className="border-t border-gray-200 pt-4 mb-4">
                <div className="text-sm text-gray-500 mb-3 font-medium">AI Response:</div>
                <MarkdownRenderer 
                  content={note.aiContext}
                  className="text-gray-800"
                />
              </div>
            )}
          </div>
        </div>

        

        {/* Research Results - V2 Intelligence Data */}
        {richContextData && (
          <div className="px-4 mb-4">
            {/* Research Results from suggestedLinks + entities */}
            {((richContextData.suggestedLinks && richContextData.suggestedLinks.length > 0) || 
              (richContextData.entities && richContextData.entities.length > 0)) && (
              <div className="border-t border-gray-200 pt-4">
                <div className="text-sm text-gray-500 mb-3 font-medium">Research Results:</div>
                <div className="space-y-2">
                  {/* Display suggested links */}
                  {richContextData.suggestedLinks?.slice(0, 3).map((item: any, index: number) => (
                    <div 
                      key={`link-${index}`} 
                      className="p-3 bg-gray-50 rounded-lg border border-gray-200 hover:bg-gray-100 cursor-pointer transition-colors"
                      onClick={() => item.url && window.open(item.url, '_blank')}
                    >
                      <h4 className="font-medium text-gray-900 text-sm mb-1">{item.title}</h4>
                      <p className="text-xs text-gray-600 line-clamp-2">{item.description}</p>
                    </div>
                  ))}
                  
                  {/* Display entities as research items */}
                  {richContextData.entities?.slice(0, 2).map((entity: any, index: number) => (
                    <div 
                      key={`entity-${index}`} 
                      className="p-3 bg-blue-50 rounded-lg border border-blue-200"
                    >
                      <h4 className="font-medium text-gray-900 text-sm mb-1">
                        {entity.name?.name || entity.name}
                      </h4>
                      <p className="text-xs text-gray-600">
                        {entity.type} - Relevance: {entity.name?.relevance ? (entity.name.relevance * 100).toFixed(0) + '%' : 'N/A'}
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Consolidated Todos with Optional Additions */}
        {note.todos && note.todos.length > 0 && (
          <div className="bg-yellow-50 mx-4 mb-4 rounded-lg border border-yellow-200">
            <div className="p-4">
              <h4 className="font-medium text-gray-900 mb-3 text-base">Action Items</h4>
              <div className="space-y-3">
                {note.todos.map((todo: Todo) => (
                  <div key={todo.id} className="flex items-center gap-3">
                    <button
                      onClick={() => toggleTodoMutation.mutate(todo)}
                      className={`w-4 h-4 rounded border-2 flex items-center justify-center ${
                        todo.completed 
                          ? 'bg-green-500 border-green-500' 
                          : 'border-gray-300'
                      }`}
                    >
                      {todo.completed && <div className="w-2 h-2 bg-white rounded-full"></div>}
                    </button>
                    <span className={`text-sm flex-1 ${todo.completed ? 'line-through text-gray-500' : 'text-gray-800'}`}>
                      {todo.title}
                    </span>
                    <button
                      onClick={() => {
                        const calendarEvent = createCalendarEventFromContent(todo.title, todo.title);
                        if (calendarEvent) {
                          addToGoogleCalendar(calendarEvent);
                          toast({
                            description: "Opening Google Calendar with event details",
                          });
                        } else {
                          const calendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(todo.title)}&details=${encodeURIComponent(`From note: ${note.content}`)}`;
                          window.open(calendarUrl, '_blank');
                          toast({
                            description: "Opening Google Calendar",
                          });
                        }
                      }}
                      className="p-1 text-gray-400 hover:text-blue-600 transition-colors"
                      title="Add to Google Calendar"
                    >
                      <Calendar className="w-4 h-4" />
                    </button>
                  </div>
                ))}
              </div>

              {/* Optional Todo Suggestions */}
              {note.richContext && (() => {
                try {
                  const richData = JSON.parse(note.richContext);
                  const nextSteps = richData.nextSteps || [];

                  // Show next steps as optional todos if they exist and aren't already todos
                  const existingTodoTitles = note.todos.map((t: Todo) => t.title.toLowerCase());
                  const optionalTodos = nextSteps.filter((step: string) => 
                    !existingTodoTitles.some((todoTitle: string) => 
                      todoTitle.includes(step.toLowerCase().slice(0, 15)) ||
                      step.toLowerCase().includes(todoTitle.slice(0, 15))
                    )
                  );

                  return optionalTodos.length > 0 ? (
                    <div className="mt-4 pt-3 border-t border-yellow-200">
                      <h5 className="text-xs font-medium text-gray-600 mb-2 uppercase tracking-wide">Suggested</h5>
                      <div className="space-y-2">
                        {optionalTodos.slice(0, 3).map((step: string, index: number) => (
                          <div key={`optional-${index}`} className="flex items-center gap-3 p-2 bg-yellow-25 rounded border border-yellow-100">
                            <div className="w-4 h-4 border border-gray-300 rounded opacity-50"></div>
                            <span className="text-sm text-gray-700 flex-1">{step}</span>
                            <div className="flex gap-1">
                              <button
                                onClick={async () => {
                                  try {
                                    await apiRequest('/api/todos/add-optional', 'POST', {
                                      title: step,
                                      noteId: note.id
                                    });

                                    // Refresh the note to show the new todo
                                    queryClient.invalidateQueries({ queryKey: ['/api/notes', note.id] });

                                    toast({
                                      description: "Added to todos",
                                    });
                                  } catch (error) {
                                    toast({
                                      description: "Failed to add todo",
                                      variant: "destructive"
                                    });
                                  }
                                }}
                                className="p-1 text-gray-400 hover:text-green-600 transition-colors"
                                title="Add to todos"
                              >
                                <Plus className="w-4 h-4" />
                              </button>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  ) : null;
                } catch (e) {
                  return null;
                }
              })()}
            </div>
          </div>
        )}

        {/* Extracted Items Display */}
        {note.items && note.items.length > 0 && (
          <div className="bg-green-50 mx-4 mb-4 rounded-lg border border-green-200">
            <div className="p-4">
              <h4 className="font-medium text-gray-900 mb-3 text-base flex items-center gap-2">
                <div className="w-4 h-4 bg-green-500 rounded-full flex items-center justify-center">
                  <span className="text-white text-xs">✓</span>
                </div>
                Items Added to Collection
              </h4>
              <div className="space-y-3">
                {note.items.map((item: any, index: number) => (
                  <div key={item.id || index} className="bg-white rounded-lg p-3 border border-green-100">
                    <div className="flex items-start justify-between">
                      <div className="flex-1">
                        <div className="font-medium text-sm text-gray-900">{item.title}</div>
                        {item.description && (
                          <div className="text-xs text-gray-600 mt-1">{item.description}</div>
                        )}
                        {item.category && (
                          <div className="text-xs text-green-600 bg-green-100 px-2 py-1 rounded inline-block mt-2">
                            {item.category}
                          </div>
                        )}
                      </div>
                    </div>
                    {/* Shopping Links Display */}
                    {item.detailedContent && (() => {
                      try {
                        const details = typeof item.detailedContent === 'string' ? JSON.parse(item.detailedContent) : item.detailedContent;
                        return details.shoppingLinks && details.shoppingLinks.length > 0 && (
                          <div className="mt-2 pt-2 border-t border-green-100">
                            <div className="text-xs text-gray-600 mb-2">🛒 Shopping Links:</div>
                            <div className="space-y-1">
                              {details.shoppingLinks.slice(0, 3).map((link: any, linkIndex: number) => (
                                <a
                                  key={linkIndex}
                                  href={link.url}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="block text-xs text-blue-600 hover:text-blue-800 bg-blue-50 hover:bg-blue-100 px-2 py-1 rounded border border-blue-200 transition-colors"
                                >
                                  <div className="font-medium truncate">{link.title}</div>                                  {link.description && (
                                    <div className="text-gray-500 truncate mt-1">{link.description.slice(0, 80)}...</div>
                                  )}
                                </a>
                              ))}
                            </div>
                          </div>
                        );
                      } catch {
                        return null;
                      }
                    })()}

                    {item.metadata && (() => {
                      try {
                        const metadata = typeof item.metadata === 'string' ? JSON.parse(item.metadata) : item.metadata;
                        return Object.keys(metadata).length > 0 && (
                          <div className="mt-2 pt-2 border-t border-green-100">
                            <div className="flex flex-wrap gap-2">
                              {Object.entries(metadata).map(([key, value]: [string, any]) => (
                                value && (
                                  <span key={key} className="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">
                                    {key}: {String(value)}
                                  </span>
                                )
                              ))}
                            </div>
                          </div>
                        );
                      } catch {
                        return null;
                      }
                    })()}
                  </div>
                ))}
              </div>
              {note.collection && (
                <div className="mt-3 pt-3 border-t border-green-200">
                  <div className="text-sm text-green-700">
                    📚 Added to "{note.collection.name}" collection
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Subtle Entities Section at Bottom */}
        {note.richContext && (() => {
          try {
            const richData = JSON.parse(note.richContext);
            return richData.entities && richData.entities.length > 0 ? (
              <div className="px-4 py-2 border-t border-gray-100 bg-gray-50">
                <div className="flex flex-wrap gap-1">
                  {richData.entities.map((entity: any, index: number) => (
                    <span key={index} className="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">
                      {entity.value}
                    </span>
                  ))}
                </div>
              </div>
            ) : null;
          } catch {
            return null;
          }
        })()}

        {/* Document Metadata - Bottom of page */}
        <div className="px-4 py-4 pb-28 border-t border-gray-200 bg-gray-50 text-xs text-gray-500 space-y-1">
          <div>Last modified {note.createdAt ? formatDistanceToNow(new Date(note.createdAt)) + ' ago' : 'Unknown'}</div>
          <div>Created {note.createdAt ? format(new Date(note.createdAt), "MMM d, yyyy 'at' h:mm a") : 'Unknown date'}</div>
          <div className="text-gray-400">Note ID: #{note.id}</div>
        </div>


      </div>
      {/* Input Bar - Context Aware */}
      <InputBar
        onTextSubmit={handleSendMessage}
        onCameraCapture={() => {
          console.log('Camera capture triggered from note detail');
        }}
        onNewNote={() => {
          console.log('New note triggered from note detail');
        }}
      />

      {/* Version History Dialog */}
      {showVersionHistory && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-md w-full max-h-[80vh] overflow-hidden">
            <div className="flex items-center justify-between p-4 border-b">
              <h3 className="text-lg font-semibold">Version History</h3>
              <button
                onClick={() => setShowVersionHistory(false)}
                className="w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100"
              >
                <X className="w-4 h-4" />
              </button>
            </div>

            <div className="p-4 space-y-3 overflow-y-auto max-h-96">
              <div className="flex items-center gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200">
                <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
                <div className="flex-1">
                  <div className="text-sm font-medium">Current Version</div>
                  <div className="text-xs text-gray-500">
                    {note?.content?.substring(0, 100)}...
                  </div>
                </div>
              </div>

              {versionHistory && Array.isArray(versionHistory) && versionHistory.map((version: any, index: number) => (
                <div key={version.id} className="flex items-center gap-2 p-3 bg-gray-50 rounded-lg">
                  <div className="w-2 h-2 bg-gray-400 rounded-full"></div>
                  <div className="flex-1">
                    <div className="text-sm font-medium">
                      Version {version.version} - {version.changeType}
                    </div>
                    <div className="text-xs text-gray-500 mb-2">
                      {version.changeDescription} | {format(new Date(version.createdAt), 'MMM d, h:mm a')}
                    </div>
                    <div className="text-xs text-gray-600 mb-2">
                      {version.content?.substring(0, 80)}...
                    </div>
                    <button
                      onClick={() => rollbackMutation.mutate(version.version)}
                      disabled={rollbackMutation.isPending}
                      className="text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700 disabled:opacity-50"
                    >
                      {rollbackMutation.isPending ? 'Rolling back...' : 'Restore'}
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Approval Dialog for High-Risk Changes */}
      {showApprovalDialog && pendingChanges && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-lg w-full max-h-[80vh] overflow-hidden">
            <div className="flex items-center justify-between p-4 border-b">
              <div className="flex items-center gap-2">
                <AlertTriangle className="w-5 h-5 text-orange-500" />
                <h3 className="text-lg font-semibold">AI Wants to Make Changes</h3>
              </div>
              <button
                onClick={() => {
                  setShowApprovalDialog(false);
                  setPendingChanges(null);
                }}
                className="w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100"
              >
                <X className="w-4 h-4" />
              </button>
            </div>

            <div className="p-4 space-y-4 overflow-y-auto max-h-96">
              <div className="text-sm text-gray-600">
                AI detected valuable content that could be affected by these changes. Please review before proceeding.
              </div>

              {pendingChanges.warnings && (
                <div className="bg-orange-50 border border-orange-200 rounded-lg p-3">
                  <div className="text-sm font-medium text-orange-800 mb-2">Protected Content:</div>
                  <ul className="space-y-1">
                    {pendingChanges.warnings.map((warning: string, index: number) => (
                      <li key={index} className="text-xs text-orange-700">• {warning}</li>
                    ))}
                  </ul>
                </div>
              )}

              <div className="border rounded-lg p-3">
                <div className="text-sm font-medium mb-2">Suggested Changes:</div>
                <div className="text-sm text-gray-600 bg-gray-50 p-2 rounded max-h-32 overflow-y-auto">
                  {pendingChanges.suggestedChanges}
                </div>
              </div>

              <div className="space-y-2">
                <div className="text-sm font-medium">Or clarify your instruction:</div>
                <textarea
                  value={clarificationInput}
                  onChange={(e) => setClarificationInput(e.target.value)}
                  placeholder="Explain what you meant in more detail..."
                  className="w-full p-2 border rounded-lg text-sm resize-none"
                  rows={3}
                />
              </div>
            </div>

            <div className="flex gap-2 p-4 border-t">
              <button
                onClick={() => {
                  setShowApprovalDialog(false);
                  setPendingChanges(null);
                }}
                className="flex-1 px-4 py-2 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50"
              >
                Cancel
              </button>

              {clarificationInput && (
                <button
                  onClick={() => {
                    clarifyMutation.mutate({
                      originalInstruction: pendingChanges.originalInstruction || '',
                      clarification: clarificationInput
                    });
                    setShowApprovalDialog(false);
                    setPendingChanges(null);
                  }}
                  disabled={clarifyMutation.isPending}
                  className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
                >
                  {clarifyMutation.isPending ? 'Clarifying...' : 'Clarify & Apply'}
                </button>
              )}

              <button
                onClick={() => {
                  approveChangesMutation.mutate({
                    suggestedChanges: pendingChanges.suggestedChanges,
                    userApproved: true
                  });
                }}
                disabled={approveChangesMutation.isPending}
                className="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50"
              >
                <CheckCircle className="w-4 h-4 mr-1 inline" />
                {approveChangesMutation.isPending ? 'Applying...' : 'Approve Changes'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Reminder Dialog */}
      <ReminderDialog
        open={showReminderDialog}
        onOpenChange={setShowReminderDialog}
        prePopulatedText={`Reminder: ${note?.content?.split('\n')[0] || 'Untitled Note'}`}
        onReminderUpdated={() => {
          queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
          toast({
            description: "Reminder created successfully!",
          });
        }}
      />
    </div>
  );
}```

### client/src/pages/notes.tsx
```typescript

import { useState, useEffect } from "react";
import { useMutation, useQueryClient, useQuery } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";
import ActivityFeed from "@/components/activity-feed";
import IOSVoiceRecorder from "@/components/ios-voice-recorder";
import BottomNavigation from "@/components/bottom-navigation";
import InputBar from "@/components/input-bar";
import FullScreenCapture from "@/components/full-screen-capture";
import AIProcessingIndicator from "@/components/ai-processing-indicator";
import type { NoteWithTodos } from "@shared/schema";

export default function Notes() {
  const [isFullScreenCaptureOpen, setIsFullScreenCaptureOpen] = useState(false);
  const [isVoiceModalOpen, setIsVoiceModalOpen] = useState(false);
  
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Check for any notes currently being processed with optimized caching
  const { data: notes } = useQuery<NoteWithTodos[]>({
    queryKey: ["/api/notes"],
    staleTime: 120000, // Cache for 2 minutes for faster navigation
    gcTime: 600000, // Keep in cache for 10 minutes
    refetchOnMount: false, // Don't refetch when component mounts if data is fresh
  });
  
  const hasProcessingNotes = notes?.some(note => note.isProcessing) || false;

  // Text note creation mutation
  const createTextNoteMutation = useMutation({
    mutationFn: async (text: string) => {
      const response = await fetch("/api/notes", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          content: text,
          mode: "text",
          context: "note_creation" // Context for AI to know this is note-focused
        }),
        credentials: "include",
      });
      
      if (!response.ok) {
        throw new Error("Failed to create text note");
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      toast({
        title: "Note saved",
        description: "Your note has been created successfully.",
        duration: 3000,
      });
    },
    onError: (error) => {
      console.error("Text note error:", error);
      toast({
        title: "Error",
        description: "Failed to save note. Please try again.",
        variant: "destructive",
      });
    },
  });

  const handleTextSubmit = (text: string) => {
    console.log('📝 NOTES handleTextSubmit called with:', text);
    createTextNoteMutation.mutate(text);
  };

  return (
    <div className="w-full bg-[hsl(var(--background))] min-h-screen relative">
      {/* Status Bar */}
      <div className="safe-area-top bg-[hsl(var(--background))]"></div>
      
      {/* Main Content */}
      <div className="pb-24">
        <ActivityFeed />
      </div>

      {/* Context-specific Input Bar for Notes */}
      <InputBar 
        onCameraCapture={() => setIsFullScreenCaptureOpen(true)}
        onNewNote={() => setIsVoiceModalOpen(true)}
        onTextSubmit={handleTextSubmit}
      />

      {/* Bottom Navigation */}
      <BottomNavigation />

      {/* Modals */}
      <IOSVoiceRecorder 
        isOpen={isVoiceModalOpen} 
        onClose={() => setIsVoiceModalOpen(false)} 
      />

      {/* Full Screen Capture */}
      <FullScreenCapture
        isOpen={isFullScreenCaptureOpen}
        onClose={() => setIsFullScreenCaptureOpen(false)}
      />

      {/* Global AI Processing Indicator */}
      <AIProcessingIndicator isProcessing={hasProcessingNotes} position="fixed" />
    </div>
  );
}
```

### client/src/pages/not-found.tsx
```typescript
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
```

### client/src/pages/profile.tsx
```typescript
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Palette, Info, Moon, Sun, Monitor, Trash2, Trophy, Zap, GraduationCap, Target, Crown, Star, TrendingUp, User, Edit3, LogIn, LogOut, X, Wifi, WifiOff, CheckCircle, Clock, AlertCircle, Folder, Search, Database, Bell } from "lucide-react";
import type { NoteWithTodos, Collection } from "@shared/schema";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useOfflineStore } from "@/store/offline-store";
import { useLocation } from "wouter";
import BottomNavigation from "@/components/bottom-navigation";
import CollectionsView from "@/components/collections-view";
import DevCacheDebugger from "@/components/dev-cache-debugger";
import { ReminderSettings } from "@/components/reminder-settings";

export default function Profile() {
  const [theme, setTheme] = useState<'light' | 'dark' | 'system'>('system');
  const [aiModel, setAiModel] = useState<'openai' | 'claude'>('claude');
  const [showEmojis, setShowEmojis] = useState(true);
  const [showOnboarding, setShowOnboarding] = useState(false);
  const [showQuickProfile, setShowQuickProfile] = useState(false);
  const [showBioPreview, setShowBioPreview] = useState(false);
  const [profileText, setProfileText] = useState('');
  const [onboardingAnswers, setOnboardingAnswers] = useState<Record<string, string>>({});
  const [showCollections, setShowCollections] = useState(false);
  const [showDebugger, setShowDebugger] = useState(false);
  const [showReminderSettings, setShowReminderSettings] = useState(false);

  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [location, navigate] = useLocation();

  // Sync status from offline store
  const {
    isOnline,
    isSyncing,
    lastSyncTime,
    pendingItems,
    conflictItems,
    syncWithServer
  } = useOfflineStore();

  const { data: notes } = useQuery<NoteWithTodos[]>({
    queryKey: ["/api/notes"],
  });

  const { data: collections } = useQuery<Collection[]>({
    queryKey: ["/api/collections"],
  });

  const { data: apiStats } = useQuery<{
    openai: { requests: number; tokens: number; cost: number };
    claude: { requests: number; tokens: number; cost: number };
    totalRequests: number;
  }>({
    queryKey: ["/api/stats/api-usage"],
  });



  const { data: userProfile } = useQuery<{
    personalBio?: string;
    preferences?: any;
    onboardingCompleted?: boolean;
  }>({
    queryKey: ["/api/profile", "demo"],
  });

  const onboardingMutation = useMutation({
    mutationFn: async (answers: Record<string, string>) => {
      return await apiRequest("/api/profile/onboarding", "POST", {
        onboardingData: answers,
        userId: "demo"
      });
    },
    onSuccess: (result) => {
      queryClient.invalidateQueries({ queryKey: ["/api/profile"] });
      toast({
        title: "Profile Created",
        description: "Your AI assistant profile has been generated and saved!",
      });
      setShowOnboarding(false);
      setOnboardingAnswers({});
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to create profile from onboarding",
        variant: "destructive"
      });
    }
  });

  const quickProfileMutation = useMutation({
    mutationFn: async (profileData: string) => {
      console.log('Submitting quick profile:', profileData.substring(0, 100) + '...');
      const response = await apiRequest("/api/profile/quick", "POST", {
        profileData,
        userId: "demo"
      });
      console.log('Quick profile response:', response);
      return response;
    },
    onSuccess: (result) => {
      console.log('Quick profile mutation success:', result);
      queryClient.invalidateQueries({ queryKey: ["/api/profile"] });
      queryClient.invalidateQueries({ queryKey: ["/api/profile", "demo"] });
      toast({
        title: "Profile Created Successfully",
        description: "Your personal bio has been generated and saved!",
      });
      setShowQuickProfile(false);
      setProfileText('');
    },
    onError: (error) => {
      console.error('Quick profile mutation error:', error);
      toast({
        title: "Error Creating Profile",
        description: "Failed to create profile. Please try again.",
        variant: "destructive"
      });
    }
  });

  const handleQuickProfile = () => {
    console.log('Handle quick profile clicked, text length:', profileText.length);
    if (profileText.trim()) {
      console.log('Triggering quick profile mutation...');
      quickProfileMutation.mutate(profileText.trim());
    } else {
      toast({
        title: "Empty Profile",
        description: "Please enter some information about yourself first.",
        variant: "destructive"
      });
    }
  };

  const onboardingQuestions = [
    { id: 'name', question: 'What should I call you?', placeholder: 'Your preferred name...' },
    { id: 'role', question: 'What do you do for work or study?', placeholder: 'Your profession, role, or field of study...' },
    { id: 'goals', question: 'What are your main goals or priorities right now?', placeholder: 'Personal goals, work projects, life aspirations...' },
    { id: 'challenges', question: 'What challenges are you currently facing?', placeholder: 'Work challenges, personal obstacles, areas for improvement...' },
    { id: 'interests', question: 'What are your main interests and hobbies?', placeholder: 'Activities you enjoy, topics you are passionate about...' },
    { id: 'communication', question: 'How do you prefer to communicate and receive information?', placeholder: 'Direct, detailed, casual, formal, with examples, bullet points...' },
    { id: 'schedule', question: 'What does your typical day or week look like?', placeholder: 'Daily routine, work schedule, peak productivity times...' },
    { id: 'values', question: 'What values or principles are important to you?', placeholder: 'Core beliefs, what matters most in decisions...' },
    { id: 'learning', question: 'How do you prefer to learn new things?', placeholder: 'Visual, hands-on, reading, videos, practice, examples...' },
    { id: 'support', question: 'What kind of support or assistance would be most helpful?', placeholder: 'Organization, reminders, research, planning, brainstorming...' }
  ];

  const handleSubmitOnboarding = () => {
    const answeredQuestions = Object.keys(onboardingAnswers).length;
    if (answeredQuestions < 3) {
      toast({
        title: "Please answer more questions",
        description: "Answer at least 3 questions to create your profile.",
        variant: "destructive"
      });
      return;
    }
    onboardingMutation.mutate(onboardingAnswers);
  };

  const handleClearData = async () => {
    if (confirm('Are you sure you want to delete all notes? This cannot be undone.')) {
      console.log('Clear all data requested');
    }
  };

  const noteCount = notes?.length || 0;
  const todoCount = notes?.reduce((acc, note) => acc + note.todos.length, 0) || 0;
  const completedTodos = notes?.reduce((acc, note) => acc + note.todos.filter(t => t.completed).length, 0) || 0;

  // Achievement calculations
  const achievements = [
    { 
      id: 'first_note', 
      name: 'Getting Started', 
      description: 'Create your first note', 
      icon: '🌱', 
      unlocked: noteCount >= 1,
      progress: Math.min(noteCount, 1),
      target: 1
    },
    { 
      id: 'prolific_writer', 
      name: 'Prolific Writer', 
      description: 'Create 50 notes', 
      icon: '📝', 
      unlocked: noteCount >= 50,
      progress: Math.min(noteCount, 50),
      target: 50
    },
    { 
      id: 'task_master', 
      name: 'Task Master', 
      description: 'Complete 100 tasks', 
      icon: '✅', 
      unlocked: completedTodos >= 100,
      progress: Math.min(completedTodos, 100),
      target: 100
    },
    { 
      id: 'ai_enthusiast', 
      name: 'AI Enthusiast', 
      description: 'Process 25 notes with AI', 
      icon: '🤖', 
      unlocked: (apiStats?.totalRequests || 0) >= 25,
      progress: Math.min(apiStats?.totalRequests || 0, 25),
      target: 25
    }
  ];

  const streakDays = 7; // Mock streak data
  const productivityScore = Math.round(((completedTodos / Math.max(todoCount, 1)) * 100));

  return (
    <div className="w-full bg-[hsl(var(--background))] min-h-screen relative">
      {/* Status Bar */}
      <div className="safe-area-top bg-[hsl(var(--background))]"></div>

      {/* Main Content */}
      <div className="pb-24">
        <div className="space-y-3">
          {/* Header */}
          <div className="flex items-center justify-between px-4 pt-6">
            <div className="flex items-center gap-2">
              <h2 className="text-2xl font-serif font-medium text-gray-900 dark:text-gray-100">
                Profile
              </h2>
            </div>

            {/* Tiny Sync Status Bubble */}
            <div className="flex items-center gap-2">
              <div className="flex items-center gap-1.5">
                <div className={`w-2 h-2 rounded-full ${
                  isSyncing ? 'bg-yellow-500' : 
                  !isOnline && pendingItems > 0 ? 'bg-red-500' : 
                  !isOnline ? 'bg-orange-500' : 
                  'bg-green-500'
                }`} />
                <span className="text-xs text-gray-500">
                  {isSyncing ? 'syncing' : 
                   !isOnline && pendingItems > 0 ? 'offline' : 
                   !isOnline ? 'offline' : 
                   'synced'}
                </span>
              </div>
              
              {/* Subtle Development Cache Debug Button */}
              {import.meta.env.DEV && (
                <button
                  onClick={() => setShowDebugger(!showDebugger)}
                  className="opacity-30 hover:opacity-70 transition-opacity"
                  title="Cache Debug (Dev)"
                >
                  <Database className="w-3 h-3 text-gray-400" />
                </button>
              )}
            </div>
          </div>

          {/* Profile Content */}
          <div className="p-4 space-y-6">

            {/* Profile Info Section */}
            <div className="bg-white rounded-lg border border-gray-200">
              <div className="p-4 border-b border-gray-100">
                <h2 className="text-base font-medium text-gray-900 flex items-center gap-2">
                  <User className="w-5 h-5 text-blue-500" />
                  Your Profile
                </h2>
              </div>
              <div className="p-4 space-y-4">
                <div className="flex items-center gap-4">
                  <div className="w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center">
                    <User className="w-8 h-8 text-blue-600" />
                  </div>
                  <div>
                    <div className="text-lg font-medium text-gray-900">Demo User</div>
                    <div className="text-sm text-gray-500">AI-powered productivity assistant</div>
                  </div>
                </div>

                {userProfile?.personalBio ? (
                  <div className="p-3 bg-green-50 rounded-lg border border-green-200">
                    <div className="flex items-center gap-2 mb-2">
                      <CheckCircle className="w-4 h-4 text-green-600" />
                      <span className="text-sm font-medium text-green-900">AI Assistant Bio Added</span>
                      <span className="text-xs text-green-600 ml-auto">
                        {new Date().toLocaleDateString()}
                      </span>
                    </div>
                    <div className="text-xs text-green-700 mb-3 leading-relaxed">
                      {userProfile.personalBio.length > 200 
                        ? userProfile.personalBio.slice(0, 200) + '...' 
                        : userProfile.personalBio
                      }
                    </div>
                    <div className="flex gap-2">
                      <button 
                        onClick={() => setShowBioPreview(true)}
                        className="text-xs text-green-600 hover:text-green-700 flex items-center gap-1 px-2 py-1 rounded bg-green-100 hover:bg-green-200"
                      >
                        <Info className="w-3 h-3" />
                        View Full Bio
                      </button>
                      <button 
                        onClick={() => setShowQuickProfile(true)}
                        className="text-xs text-green-600 hover:text-green-700 flex items-center gap-1 px-2 py-1 rounded bg-green-100 hover:bg-green-200"
                      >
                        <Edit3 className="w-3 h-3" />
                        Update Bio
                      </button>
                    </div>
                  </div>
                ) : (
                  <div className="space-y-3">
                    <button 
                      onClick={() => setShowOnboarding(true)}
                      className="w-full flex items-center justify-between p-3 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors"
                    >
                      <div className="flex items-center gap-3">
                        <div className="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
                          <span className="text-blue-600 font-medium">?</span>
                        </div>
                        <div className="text-left">
                          <div className="text-sm font-medium text-blue-900">Complete Onboarding</div>
                          <div className="text-xs text-blue-600">Answer questions to personalize Mira</div>
                        </div>
                      </div>
                      <div className="text-blue-600 text-sm">Start</div>
                    </button>
                    <button 
                      onClick={() => setShowQuickProfile(true)}
                      className="w-full flex items-center justify-between p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors"
                    >
                      <div className="flex items-center gap-3">
                        <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center">
                          <span className="text-gray-600">📋</span>
                        </div>
                        <div className="text-left">
                          <div className="text-sm font-medium text-gray-900">Quick Profile</div>
                          <div className="text-xs text-gray-500">Paste info about yourself</div>
                        </div>
                      </div>
                      <div className="text-gray-600 text-sm">Add</div>
                    </button>
                  </div>
                )}
              </div>
            </div>

            {/* Collections Section */}
            <div className="bg-white rounded-lg border border-gray-200">
              <div 
                className="p-4 border-b border-gray-100 cursor-pointer hover:bg-gray-50 transition-colors"
                onClick={() => setShowCollections(!showCollections)}
              >
                <div className="flex items-center justify-between">
                  <h2 className="text-base font-medium text-gray-900 flex items-center gap-2">
                    <Folder className="w-5 h-5 text-purple-500" />
                    Collections
                    <span className="text-sm text-gray-500">({collections?.length || 0})</span>
                  </h2>
                  <div className="flex items-center gap-2">
                    <Search className="w-4 h-4 text-gray-400" />
                  </div>
                </div>
              </div>

              {showCollections && (
                <div className="p-0">
                  <CollectionsView embedded={true} />
                </div>
              )}

              {!showCollections && (
                <div className="p-4">
                  <div className="grid grid-cols-2 gap-3">
                    {collections?.slice(0, 4).map((collection) => (
                      <div 
                        key={collection.id}
                        className="p-3 bg-gray-50 rounded-lg cursor-pointer hover:bg-gray-100 transition-colors"
                        onClick={() => navigate(`/collection/${collection.id}`)}
                      >
                        <div className="flex items-center gap-2 mb-1">
                          <span className="text-lg">{collection.icon}</span>
                          <span className="text-sm font-medium text-gray-900 truncate">{collection.name}</span>
                        </div>
                        <div className="text-xs text-gray-500">
                          {notes?.filter(note => note.collectionId === collection.id).length || 0} items
                        </div>
                      </div>
                    ))}
                  </div>
                  {collections && collections.length > 4 && (
                    <button 
                      onClick={() => setShowCollections(true)}
                      className="w-full mt-3 text-sm text-blue-600 hover:text-blue-700"
                    >
                      View all {collections.length} collections
                    </button>
                  )}
                </div>
              )}
            </div>

            {/* Stats & Achievements */}
            <div className="bg-white rounded-lg border border-gray-200">
              <div className="p-3 border-b border-gray-100">
                <h2 className="text-sm font-medium text-gray-900 flex items-center gap-2">
                  <Trophy className="w-4 h-4 text-yellow-500" />
                  Your Journey
                </h2>
              </div>
              <div className="p-3 space-y-3">
                {/* Stats Grid - 2 Rows by 2 Columns */}
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridTemplateRows: '1fr 1fr', gap: '8px' }}>
                  <div className="text-center p-2 bg-blue-50 rounded">
                    <div className="text-lg font-bold text-blue-600">{noteCount}</div>
                    <div className="text-xs text-blue-600">Notes</div>
                  </div>
                  <div className="text-center p-2 bg-purple-50 rounded">
                    <div className="text-lg font-bold text-purple-600">{todoCount}</div>
                    <div className="text-xs text-purple-600">To-do's</div>
                  </div>
                  <div className="text-center p-2 bg-green-50 rounded">
                    <div className="text-lg font-bold text-green-600">{productivityScore}%</div>
                    <div className="text-xs text-green-600">Done</div>
                  </div>
                  <div className="text-center p-2 bg-orange-50 rounded">
                    <div className="text-lg font-bold text-orange-600">{streakDays}</div>
                    <div className="text-xs text-orange-600">Streak days</div>
                  </div>
                </div>

                {/* Achievements */}
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <span className="text-xs font-medium text-gray-700">Achievements</span>
                    <span className="text-xs text-gray-500">{achievements.filter(a => a.unlocked).length}/{achievements.length}</span>
                  </div>
                  <div className="space-y-1">
                    {achievements.slice(0, 3).map((achievement) => (
                      <div 
                        key={achievement.id} 
                        className={`flex items-center gap-2 p-1 rounded ${
                          achievement.unlocked 
                            ? 'bg-yellow-50 border border-yellow-200' 
                            : 'bg-gray-50 border border-gray-200'
                        }`}
                      >
                        <span className={`text-sm ${achievement.unlocked ? '' : 'grayscale opacity-50'}`}>
                          {achievement.icon}
                        </span>
                        <div className="flex-1 min-w-0">
                          <div className={`text-xs font-medium truncate ${achievement.unlocked ? 'text-gray-900' : 'text-gray-500'}`}>
                            {achievement.name}
                          </div>
                          <div className="flex items-center gap-1 mt-0.5">
                            <div className="flex-1 bg-gray-200 rounded-full h-1">
                              <div 
                                className={`h-1 rounded-full ${achievement.unlocked ? 'bg-yellow-500' : 'bg-gray-400'}`}
                                style={{ width: `${(achievement.progress / achievement.target) * 100}%` }}
                              />
                            </div>
                            <span className="text-xs text-gray-500 font-medium">
                              {achievement.progress}/{achievement.target}
                            </span>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>

            {/* Reminder Settings */}
            <div className="bg-white rounded-lg border border-gray-200">
              <div className="p-4 border-b border-gray-100">
                <h2 className="text-base font-medium text-gray-900 flex items-center gap-2">
                  <Bell className="w-5 h-5 text-purple-500" />
                  Reminder Settings
                </h2>
              </div>
              <div className="p-4">
                <button
                  onClick={() => setShowReminderSettings(true)}
                  className="w-full flex items-center justify-between p-3 bg-purple-50 rounded-lg hover:bg-purple-100 transition-colors"
                >
                  <div className="flex items-center gap-3">
                    <div className="w-8 h-8 bg-purple-100 rounded-full flex items-center justify-center">
                      <Bell className="w-4 h-4 text-purple-600" />
                    </div>
                    <div className="text-left">
                      <div className="text-sm font-medium text-gray-900">Configure Notifications</div>
                      <div className="text-xs text-gray-500">Lead times, auto-archive, and display options</div>
                    </div>
                  </div>
                  <span className="text-purple-600">→</span>
                </button>
              </div>
            </div>

            {/* Reminder Settings Section */}
            <div className="bg-white rounded-lg border border-gray-200">
              <div className="p-4 border-b border-gray-100">
                <h2 className="text-base font-medium text-gray-900 flex items-center gap-2">
                  <Bell className="w-5 h-5 text-orange-500" />
                  Reminder Settings
                </h2>
              </div>
              <div className="p-4">
                <button 
                  onClick={() => setShowReminderSettings(true)}
                  className="w-full flex items-center justify-between p-3 bg-orange-50 rounded-lg hover:bg-orange-100 transition-colors"
                >
                  <div className="flex items-center gap-3">
                    <div className="w-8 h-8 bg-orange-100 rounded-full flex items-center justify-center">
                      <Bell className="w-4 h-4 text-orange-600" />
                    </div>
                    <div>
                      <div className="text-sm font-medium text-gray-900">Configure Notifications</div>
                      <div className="text-xs text-gray-500">Default lead times and preferences</div>
                    </div>
                  </div>
                  <span className="text-orange-600">→</span>
                </button>
              </div>
            </div>

            {/* Rest of the settings sections... */}
            {/* AI Usage, AI Settings, Appearance, Data Management, About, Account sections remain the same */}

          </div>
        </div>
      </div>

      {/* Bottom Navigation */}
      <BottomNavigation />

      {/* Development Cache Debugger - conditionally rendered */}
      {showDebugger && (
        <DevCacheDebugger 
          isOpen={showDebugger} 
          onClose={() => setShowDebugger(false)} 
        />
      )}

      {/* Reminder Settings Modal */}
      {showReminderSettings && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg w-full max-w-md max-h-[90vh] overflow-y-auto">
            <div className="flex items-center justify-between p-4 border-b">
              <h3 className="text-lg font-medium">Reminder Settings</h3>
              <button
                onClick={() => setShowReminderSettings(false)}
                className="text-gray-400 hover:text-gray-600"
              >
                <X className="h-6 w-6" />
              </button>
            </div>
            <div className="p-4">
              <ReminderSettings />
            </div>
          </div>
        </div>
      )}

      {/* Reminder Settings Modal */}
      {showReminderSettings && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-md w-full max-h-[80vh] overflow-y-auto">
            <div className="p-4 border-b border-gray-200 flex items-center justify-between">
              <h3 className="text-lg font-semibold">Reminder Settings</h3>
              <button
                onClick={() => setShowReminderSettings(false)}
                className="text-gray-400 hover:text-gray-600"
              >
                <X className="w-5 h-5" />
              </button>
            </div>
            <div className="p-4">
              <ReminderSettings />
            </div>
          </div>
        </div>
      )}

      {/* Quick Profile Modal */}
      {showQuickProfile && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-lg w-full">
            <div className="p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-lg font-semibold">Quick Profile</h2>
                <button 
                  onClick={() => {
                    setShowQuickProfile(false);
                    setProfileText('');
                  }}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>
              
              <div className="space-y-4">
                <p className="text-sm text-gray-600">
                  Paste information about yourself - bio, resume, personality test results, or anything that helps Mira understand you better.
                </p>
                
                <textarea
                  value={profileText}
                  onChange={(e) => setProfileText(e.target.value)}
                  placeholder="Tell me about yourself... your role, interests, goals, work style, or anything else that would help an AI assistant understand you better."
                  className="w-full p-3 border border-gray-200 rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  rows={8}
                />
                
                <div className="flex gap-3 justify-end">
                  <button 
                    onClick={() => {
                      setShowQuickProfile(false);
                      setProfileText('');
                    }}
                    className="px-4 py-2 text-gray-600 hover:text-gray-800"
                  >
                    Cancel
                  </button>
                  <button 
                    onClick={handleQuickProfile}
                    disabled={!profileText.trim() || quickProfileMutation.isPending}
                    className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {quickProfileMutation.isPending ? 'Generating Profile...' : 'Add Profile'}
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Bio Preview Modal */}
      {showBioPreview && userProfile?.personalBio && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
            <div className="p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-lg font-semibold">Your AI Assistant Profile</h2>
                <button 
                  onClick={() => setShowBioPreview(false)}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>
              
              <div className="prose prose-sm max-w-none">
                <div className="whitespace-pre-line text-gray-700">
                  {userProfile.personalBio}
                </div>
              </div>
              
              <div className="flex justify-end mt-6 pt-4 border-t">
                <button 
                  onClick={() => setShowBioPreview(false)}
                  className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200"
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}```

### client/src/pages/remind-original.tsx
```typescript
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Clock, Plus, CheckCircle, X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import BottomNavigation from "@/components/bottom-navigation";
import { useToast } from "@/hooks/use-toast";

interface Reminder {
  id: number;
  title: string;
  dueDate?: Date;
  reminderState: 'active' | 'overdue' | 'completed' | 'dismissed' | 'archived';
  priority?: string;
  reminderType?: string;
}

export default function Remind() {
  const [filter, setFilter] = useState<'all' | 'active' | 'overdue' | 'completed'>('all');
  const [newReminder, setNewReminder] = useState('');
  
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Fetch reminders
  const { data: reminders = [], isLoading } = useQuery<Reminder[]>({
    queryKey: ["/api/reminders"],
  });

  // Create reminder mutation
  const createReminderMutation = useMutation({
    mutationFn: async (content: string) => {
      const response = await fetch('/api/reminders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
      });
      if (!response.ok) throw new Error('Failed to create reminder');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/reminders"] });
      setNewReminder('');
      toast({
        title: "Reminder created",
        description: "Your reminder has been created successfully."
      });
    }
  });

  // Complete reminder mutation
  const completeReminderMutation = useMutation({
    mutationFn: async (id: number) => {
      const response = await fetch(`/api/reminders/${id}/complete`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' }
      });
      if (!response.ok) throw new Error('Failed to complete reminder');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/reminders"] });
      toast({
        title: "Reminder completed",
        description: "The reminder has been marked as complete."
      });
    }
  });

  // Dismiss reminder mutation
  const dismissReminderMutation = useMutation({
    mutationFn: async (id: number) => {
      const response = await fetch(`/api/reminders/${id}/dismiss`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' }
      });
      if (!response.ok) throw new Error('Failed to dismiss reminder');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/reminders"] });
      toast({
        title: "Reminder dismissed",
        description: "The reminder has been dismissed."
      });
    }
  });

  const handleCreateReminder = (e: React.FormEvent) => {
    e.preventDefault();
    if (newReminder.trim()) {
      createReminderMutation.mutate(newReminder.trim());
    }
  };

  const formatDueTime = (dueDate?: Date) => {
    if (!dueDate) return null;
    
    const date = new Date(dueDate);
    const now = new Date();
    const isToday = date.toDateString() === now.toDateString();
    const isTomorrow = date.toDateString() === new Date(now.getTime() + 24 * 60 * 60 * 1000).toDateString();
    
    const timeString = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
    
    if (isToday) return `Today at ${timeString}`;
    if (isTomorrow) return `Tomorrow at ${timeString}`;
    return date.toLocaleDateString([], { 
      month: 'short', 
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  };

  const filteredReminders = reminders?.filter(reminder => {
    if (filter === 'all') return true;
    if (filter === 'active') return reminder.reminderState === 'active';
    if (filter === 'overdue') return reminder.reminderState === 'overdue';
    if (filter === 'completed') return reminder.reminderState === 'completed';
    return true;
  }) || [];

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white border-b">
        <div className="px-4 py-4">
          <h1 className="text-xl font-semibold text-gray-900">Reminders</h1>
        </div>
      </div>

      {/* Input Section */}
      <div className="bg-white border-b px-4 py-3">
        <form onSubmit={handleCreateReminder} className="flex gap-2">
          <Input
            value={newReminder}
            onChange={(e) => setNewReminder(e.target.value)}
            placeholder="Add a reminder..."
            className="flex-1"
          />
          <Button 
            type="submit" 
            size="sm"
            disabled={!newReminder.trim() || createReminderMutation.isPending}
          >
            <Plus className="h-4 w-4" />
          </Button>
        </form>
      </div>

      {/* Filter Tabs */}
      <div className="bg-white border-b px-4 py-2">
        <div className="flex space-x-1">
          {[
            { key: 'all', label: 'All' },
            { key: 'active', label: 'Active' },
            { key: 'overdue', label: 'Overdue' },
            { key: 'completed', label: 'Completed' }
          ].map(({ key, label }) => (
            <button
              key={key}
              onClick={() => setFilter(key as any)}
              className={`px-3 py-1.5 text-sm font-medium rounded-md transition-colors ${
                filter === key
                  ? 'bg-blue-100 text-blue-800'
                  : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100'
              }`}
            >
              {label}
            </button>
          ))}
        </div>
      </div>

      {/* Content */}
      <div className="pb-20">
        {isLoading ? (
          <div className="p-4 space-y-2">
            {[1, 2, 3].map(i => (
              <div key={i} className="animate-pulse bg-white rounded-lg border p-3">
                <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
                <div className="h-3 bg-gray-200 rounded w-1/2"></div>
              </div>
            ))}
          </div>
        ) : filteredReminders.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-64 px-4">
            <Clock className="h-12 w-12 text-gray-400 mb-4" />
            <h3 className="text-lg font-medium text-gray-900 mb-2">No reminders</h3>
            <p className="text-gray-500 text-center">
              {filter === 'all' ? 'Add your first reminder above' : `No ${filter} reminders to show`}
            </p>
          </div>
        ) : (
          <div className="p-4 space-y-2">
            {filteredReminders.map((reminder) => (
              <div 
                key={reminder.id} 
                className="bg-white rounded-lg border p-3"
              >
                <div className="flex items-center justify-between">
                  <div className="flex-1 min-w-0">
                    <div className="font-medium text-gray-900 mb-1">{reminder.title}</div>
                    {reminder.dueDate && (
                      <div className="text-sm text-gray-500">
                        {formatDueTime(reminder.dueDate)}
                      </div>
                    )}
                    <div className="mt-1">
                      <span className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${
                        reminder.reminderState === 'active' ? 'bg-blue-100 text-blue-800' :
                        reminder.reminderState === 'overdue' ? 'bg-red-100 text-red-800' :
                        reminder.reminderState === 'completed' ? 'bg-green-100 text-green-800' :
                        'bg-gray-100 text-gray-800'
                      }`}>
                        {reminder.reminderState}
                      </span>
                    </div>
                  </div>
                  
                  {reminder.reminderState === 'active' && (
                    <div className="flex gap-1 ml-3">
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => completeReminderMutation.mutate(reminder.id)}
                        disabled={completeReminderMutation.isPending}
                      >
                        <CheckCircle className="h-4 w-4 text-green-600" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => dismissReminderMutation.mutate(reminder.id)}
                        disabled={dismissReminderMutation.isPending}
                      >
                        <X className="h-4 w-4 text-gray-400" />
                      </Button>
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      <BottomNavigation />
    </div>
  );
}```

### client/src/pages/remind.tsx
```typescript
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Clock, Check, Plus, Edit2, Calendar, AlertCircle } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import BottomNavigation from "@/components/bottom-navigation";
import InputBar from "@/components/input-bar";
import SimpleTextInput from "@/components/simple-text-input";
import { ReminderDialog } from "@/components/reminder-dialog";
import { formatDistanceToNow } from "date-fns";
import type { Todo } from "@shared/schema";

export default function Remind() {
  const [reminderFilter, setReminderFilter] = useState<'today' | 'week' | 'month' | 'year'>('today');
  const [todoFilter, setTodoFilter] = useState<'all' | 'urgent' | 'pinned'>('all');
  const [inputText, setInputText] = useState('');
  const [reminderDialogOpen, setReminderDialogOpen] = useState(false);
  const [editingReminder, setEditingReminder] = useState<Todo | null>(null);

  const queryClient = useQueryClient();

  // Fetch all todos - we'll filter client-side
  const { data: allTodos = [], isLoading } = useQuery<Todo[]>({
    queryKey: ["/api/todos"],
  });

  // Intelligent input processing - creates note and extracts todos/reminders with AI
  const processInputMutation = useMutation({
    mutationFn: async (content: string) => {
      const response = await fetch('/api/notes', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          content,
          mode: 'text',
          context: 'remind_page_input'
        })
      });
      if (!response.ok) throw new Error('Failed to process input');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      queryClient.invalidateQueries({ queryKey: ["/api/notes"] });
      setInputText('');
    }
  });

  // Toggle completion for any todo/reminder
  const toggleCompletionMutation = useMutation({
    mutationFn: async (todo: Todo) => {
      const response = await fetch(`/api/todos/${todo.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          completed: !todo.completed,
          reminderState: !todo.completed ? 'completed' : 'active'
        })
      });
      if (!response.ok) throw new Error('Failed to update todo');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    }
  });

  // Navigate to source note
  const handleItemClick = (todo: Todo) => {
    if (todo.noteId) {
      window.location.href = `/notes/${todo.noteId}`;
    }
  };

  // Dialog handlers
  const handleClockClick = (reminder: Todo) => {
    setEditingReminder(reminder);
    setReminderDialogOpen(true);
  };

  const handleReminderUpdated = () => {
    queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    setEditingReminder(null);
  };

  // Client-side filtering
  const reminders = allTodos.filter(todo => todo.isActiveReminder === true && !todo.archived);
  const todos = allTodos.filter(todo => todo.isActiveReminder === false && !todo.archived);

  // Apply additional filters
  const filteredReminders = reminders.filter(reminder => {
    // For now, show all reminders regardless of time filter
    // Future: implement proper time-based filtering
    return true;
  });

  const filteredTodos = todos.filter(todo => {
    if (todoFilter === 'all') return true;
    if (todoFilter === 'urgent') return todo.priority === 'urgent';
    if (todoFilter === 'pinned') return todo.pinned;
    return true;
  });

  // Work-day-aware smart urgency system
  const getSmartTimeDisplay = (date: Date | string | null, filterContext: 'today' | 'week' | 'month' | 'year') => {
    if (!date) return null;

    const now = new Date();
    const targetDate = new Date(date);
    const diffMs = targetDate.getTime() - now.getTime();

    const diffMinutes = Math.floor(Math.abs(diffMs) / (1000 * 60));
    const diffHours = Math.floor(Math.abs(diffMs) / (1000 * 60 * 60));
    const diffDays = Math.floor(Math.abs(diffMs) / (1000 * 60 * 60 * 24));

    // Helper: Get work days between dates (excludes weekends)
    const getWorkDaysBetween = (start: Date, end: Date): number => {
      let count = 0;
      const current = new Date(start);
      while (current <= end) {
        const dayOfWeek = current.getDay();
        if (dayOfWeek !== 0 && dayOfWeek !== 6) count++; // Not Sunday or Saturday
        current.setDate(current.getDate() + 1);
      }
      return count;
    };

    // Helper: Is same work day?
    const isSameWorkDay = (date1: Date, date2: Date): boolean => {
      return date1.toDateString() === date2.toDateString();
    };

    // If time has passed (overdue)
    if (diffMs < 0) {
      // Still same work day - show as overdue with red styling
      if (isSameWorkDay(now, targetDate)) {
        if (diffMinutes < 60) {
          return { text: `${diffMinutes}m ago`, color: 'text-red-600', bgColor: 'bg-red-50' };
        } else {
          return { text: `${diffHours}h ago`, color: 'text-red-600', bgColor: 'bg-red-50' };
        }
      }
      // Past work day - will be filtered to overdue section
      return null;
    }

    // Future items - work-day-aware urgency thresholds
    const workDaysAway = getWorkDaysBetween(now, targetDate);

    // Smart thresholds based on filter context and work days
    const urgencyThresholds = {
      today: diffHours < 2,                    // Show if < 2 hours
      week: workDaysAway <= 1,                 // Show if within 1 work day
      month: workDaysAway <= 4,                // Show if within 4 work days  
      year: workDaysAway <= 10                 // Show if within 2 work weeks
    };

    if (!urgencyThresholds[filterContext]) return null;

    // Format the urgent time display
    if (diffMinutes < 60) {
      return { text: `in ${diffMinutes}m`, color: 'text-orange-600', bgColor: 'bg-orange-50' };
    } else if (diffHours < 24) {
      return { text: `in ${diffHours}h`, color: 'text-orange-600', bgColor: 'bg-orange-50' };
    } else if (workDaysAway <= 1) {
      return { text: `in 1d`, color: 'text-orange-600', bgColor: 'bg-orange-50' };
    } else {
      return { text: `in ${workDaysAway}d`, color: 'text-orange-600', bgColor: 'bg-orange-50' };
    }
  };

  const handleSubmitInput = () => {
    if (inputText.trim()) {
      processInputMutation.mutate(inputText.trim());
    }
  };

  return (
    <div className="min-h-screen bg-[#f1efe8]">
      <div className="w-full bg-[hsl(var(--background))] min-h-screen relative">
        <div className="safe-area-top bg-[hsl(var(--background))]"></div>
        <div className="pb-24 px-4">
          {/* Header */}
          <div className="pt-6 mb-6">
            <h2 className="text-2xl font-serif font-medium text-gray-900 dark:text-gray-100">Remind</h2>
          </div>

          

          {/* Reminders Section */}
          <div className="mb-8">
            <div className="flex items-center justify-between px-0 mb-3">
              <div className="flex items-center gap-2">
                <Clock className="w-5 h-5 text-orange-500" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-gray-100">Reminders</h3>
                <span className="text-sm text-gray-500">({filteredReminders.length})</span>
              </div>
              <div className="flex gap-1">
                {(['today', 'week', 'month', 'year'] as const).map((filter) => (
                  <button
                    key={filter}
                    onClick={() => setReminderFilter(filter)}
                    className={`px-2 py-1 text-xs rounded-md transition-colors ${
                      reminderFilter === filter
                        ? 'bg-orange-100 dark:bg-orange-900 text-orange-700 dark:text-orange-300'
                        : 'bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400'
                    }`}
                  >
                    {filter.charAt(0).toUpperCase() + filter.slice(1)}
                  </button>
                ))}
              </div>
            </div>

            {/* Reminders List */}
            <div className="space-y-1">
              {isLoading ? (
                <div className="text-center py-4 text-gray-500">Loading reminders...</div>
              ) : filteredReminders.length === 0 ? (
                <div className="text-center py-4 text-gray-500">No reminders found</div>
              ) : (
                filteredReminders.map((reminder) => (
                  <div key={reminder.id} className="flex items-center gap-3 py-1">
                    <button 
                      onClick={() => toggleCompletionMutation.mutate(reminder)}
                      className={`w-5 h-5 rounded-full border-2 flex items-center justify-center transition-colors ${
                        reminder.completed
                          ? 'bg-orange-500 border-orange-500 text-white'
                          : 'border-gray-300 hover:border-orange-400'
                      }`}
                    >
                      {reminder.completed && <Check className="w-3 h-3" />}
                    </button>
                    <div 
                      className="flex-1 min-w-0 cursor-pointer"
                      onClick={() => handleItemClick(reminder)}
                    >
                      <div className="flex items-center justify-between">
                        <span className={`text-sm font-medium truncate ${
                          reminder.completed 
                            ? 'line-through text-gray-500' 
                            : 'text-gray-900 dark:text-gray-100'
                        }`}>
                          {reminder.title}
                        </span>
                        <div className="flex items-center gap-1 text-xs ml-2">
                          {reminder.timeDue && (() => {
                            const timeDisplay = getSmartTimeDisplay(reminder.timeDue, reminderFilter);
                            return timeDisplay && (
                              <span className={`${timeDisplay.color} font-medium px-1 py-0.5 ${timeDisplay.bgColor} rounded`}>
                                {timeDisplay.text}
                              </span>
                            );
                          })()}
                        </div>
                      </div>
                    </div>
                    <button 
                      onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handleClockClick(reminder);
                      }}
                      className="p-1 text-orange-500 hover:text-orange-700 transition-colors"
                    >
                      <Clock className="w-4 h-4" />
                    </button>
                  </div>
                ))
              )}
            </div>
          </div>

          {/* To-do's Section */}
          <div className="mb-8">
            <div className="flex items-center justify-between px-0 mb-3">
              <div className="flex items-center gap-2">
                <Check className="w-5 h-5 text-blue-500" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-gray-100">To-do's</h3>
                <span className="text-sm text-gray-500">({filteredTodos.length})</span>
              </div>
              <div className="flex gap-1">
                {(['all', 'urgent', 'pinned'] as const).map((filter) => (
                  <button
                    key={filter}
                    onClick={() => setTodoFilter(filter)}
                    className={`px-2 py-1 text-xs rounded-md transition-colors ${
                      todoFilter === filter
                        ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'
                        : 'bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400'
                    }`}
                  >
                    {filter.charAt(0).toUpperCase() + filter.slice(1)}
                  </button>
                ))}
              </div>
            </div>

            {/* Todos List */}
            <div className="space-y-1">
              {isLoading ? (
                <div className="text-center py-4 text-gray-500">Loading todos...</div>
              ) : filteredTodos.length === 0 ? (
                <div className="text-center py-4 text-gray-500">No todos found</div>
              ) : (
                filteredTodos.map((todo) => (
                  <div key={todo.id} className="flex items-center gap-3 py-1">
                    <button 
                      onClick={() => toggleCompletionMutation.mutate(todo)}
                      className={`w-5 h-5 rounded-full border-2 flex items-center justify-center transition-colors ${
                        todo.completed
                          ? 'bg-blue-500 border-blue-500 text-white'
                          : 'border-gray-300 hover:border-blue-400'
                      }`}
                    >
                      {todo.completed && <Check className="w-3 h-3" />}
                    </button>
                    <div 
                      className="flex-1 min-w-0 cursor-pointer"
                      onClick={() => handleItemClick(todo)}
                    >
                      <div className="flex items-center justify-between">
                        <span className={`text-sm font-medium truncate ${
                          todo.completed 
                            ? 'line-through text-gray-500' 
                            : 'text-gray-900 dark:text-gray-100'
                        }`}>
                          {todo.title}
                        </span>
                        <div className="flex items-center gap-1 text-xs ml-2">
                          {todo.timeDue && (() => {
                            const timeDisplay = getSmartTimeDisplay(todo.timeDue, 'today');
                            return timeDisplay && (
                              <span className={`${timeDisplay.color} font-medium px-1 py-0.5 ${timeDisplay.bgColor} rounded`}>
                                {timeDisplay.text}
                              </span>
                            );
                          })()}
                        </div>
                      </div>
                    </div>
                    <button 
                      onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handleClockClick(todo);
                      }}
                      className={`p-1 transition-colors ${
                        todo.timeDue || todo.isActiveReminder 
                          ? 'text-blue-500 hover:text-blue-700' 
                          : 'text-gray-300 hover:text-gray-400 opacity-50'
                      }`}
                    >
                      <Clock className="w-4 h-4" />
                    </button>
                  </div>
                ))
              )}
            </div>
          </div>
        </div>

        {/* Floating Input Bar - Context Aware */}
        <InputBar 
          onTextSubmit={(text) => processInputMutation.mutate(text)}
        />

        <BottomNavigation />

        {/* Reminder Dialog */}
        <ReminderDialog
          open={reminderDialogOpen}
          onOpenChange={setReminderDialogOpen}
          existingReminder={editingReminder}
          onReminderUpdated={handleReminderUpdated}
        />
      </div>
    </div>
  );
}```

### client/src/pages/settings.tsx
```typescript
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Palette, Info, Moon, Sun, Monitor, Trash2, Trophy, Zap, GraduationCap, Target, Crown, Star, TrendingUp, User, Edit3, LogIn, LogOut, X, Wifi, WifiOff, CheckCircle, Clock, AlertCircle } from "lucide-react";
import type { NoteWithTodos } from "@shared/schema";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useOfflineStore } from "@/store/offline-store";

export default function Settings() {
  const [theme, setTheme] = useState<'light' | 'dark' | 'system'>('system');
  const [aiModel, setAiModel] = useState<'openai' | 'claude'>('claude');
  const [showEmojis, setShowEmojis] = useState(true);
  const [showOnboarding, setShowOnboarding] = useState(false);
  const [showQuickProfile, setShowQuickProfile] = useState(false);
  const [showBioPreview, setShowBioPreview] = useState(false);
  const [profileText, setProfileText] = useState('');
  const [onboardingAnswers, setOnboardingAnswers] = useState<Record<string, string>>({});
  
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  // Sync status from offline store
  const {
    isOnline,
    isSyncing,
    lastSyncTime,
    pendingItems,
    conflictItems,
    syncWithServer
  } = useOfflineStore();

  const { data: notes } = useQuery<NoteWithTodos[]>({
    queryKey: ["/api/notes"],
  });

  const { data: apiStats } = useQuery<{
    openai: { requests: number; tokens: number; cost: number };
    claude: { requests: number; tokens: number; cost: number };
    totalRequests: number;
  }>({
    queryKey: ["/api/stats/api-usage"],
  });

  const { data: userProfile } = useQuery<{
    personalBio?: string;
    preferences?: any;
    onboardingCompleted?: boolean;
  }>({
    queryKey: ["/api/profile", "demo"],
  });

  const onboardingMutation = useMutation({
    mutationFn: async (answers: Record<string, string>) => {
      return await apiRequest("/api/profile/onboarding", "POST", {
        onboardingData: answers,
        userId: "demo"
      });
    },
    onSuccess: (result) => {
      queryClient.invalidateQueries({ queryKey: ["/api/profile"] });
      toast({
        title: "Profile Created",
        description: "Your AI assistant profile has been generated and saved!",
      });
      setShowOnboarding(false);
      setOnboardingAnswers({});
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to create profile from onboarding",
        variant: "destructive"
      });
    }
  });

  const quickProfileMutation = useMutation({
    mutationFn: async (profileData: string) => {
      console.log('Submitting quick profile:', profileData.substring(0, 100) + '...');
      const response = await apiRequest("/api/profile/quick", "POST", {
        profileData,
        userId: "demo"
      });
      console.log('Quick profile response:', response);
      return response;
    },
    onSuccess: (result) => {
      console.log('Quick profile mutation success:', result);
      queryClient.invalidateQueries({ queryKey: ["/api/profile"] });
      queryClient.invalidateQueries({ queryKey: ["/api/profile", "demo"] });
      toast({
        title: "Profile Created Successfully",
        description: "Your personal bio has been generated and saved!",
      });
      setShowQuickProfile(false);
      setProfileText('');
    },
    onError: (error) => {
      console.error('Quick profile mutation error:', error);
      toast({
        title: "Error Creating Profile",
        description: "Failed to create profile. Please try again.",
        variant: "destructive"
      });
    }
  });

  const onboardingQuestions = [
    { id: 'name', question: 'What should I call you?', placeholder: 'Your preferred name...' },
    { id: 'role', question: 'What do you do for work or study?', placeholder: 'Your profession, role, or field of study...' },
    { id: 'goals', question: 'What are your main goals or priorities right now?', placeholder: 'Personal goals, work projects, life aspirations...' },
    { id: 'challenges', question: 'What challenges are you currently facing?', placeholder: 'Work challenges, personal obstacles, areas for improvement...' },
    { id: 'interests', question: 'What are your main interests and hobbies?', placeholder: 'Activities you enjoy, topics you are passionate about...' },
    { id: 'communication', question: 'How do you prefer to communicate and receive information?', placeholder: 'Direct, detailed, casual, formal, with examples, bullet points...' },
    { id: 'schedule', question: 'What does your typical day or week look like?', placeholder: 'Daily routine, work schedule, peak productivity times...' },
    { id: 'values', question: 'What values or principles are important to you?', placeholder: 'Core beliefs, what matters most in decisions...' },
    { id: 'learning', question: 'How do you prefer to learn new things?', placeholder: 'Visual, hands-on, reading, videos, practice, examples...' },
    { id: 'support', question: 'What kind of support or assistance would be most helpful?', placeholder: 'Organization, reminders, research, planning, brainstorming...' }
  ];

  const handleSubmitOnboarding = () => {
    const answeredQuestions = Object.keys(onboardingAnswers).length;
    if (answeredQuestions < 3) {
      toast({
        title: "Please answer more questions",
        description: "Answer at least 3 questions to create your profile.",
        variant: "destructive"
      });
      return;
    }
    onboardingMutation.mutate(onboardingAnswers);
  };

  const handleQuickProfile = () => {
    console.log('Handle quick profile clicked, text length:', profileText.length);
    if (profileText.trim()) {
      console.log('Triggering quick profile mutation...');
      quickProfileMutation.mutate(profileText.trim());
    } else {
      toast({
        title: "Empty Profile",
        description: "Please enter some information about yourself first.",
        variant: "destructive"
      });
    }
  };

  const handleClearData = async () => {
    if (confirm('Are you sure you want to delete all notes? This cannot be undone.')) {
      console.log('Clear all data requested');
    }
  };

  const noteCount = notes?.length || 0;
  const todoCount = notes?.reduce((acc, note) => acc + note.todos.length, 0) || 0;
  const completedTodos = notes?.reduce((acc, note) => acc + note.todos.filter(t => t.completed).length, 0) || 0;
  
  // Achievement calculations
  const achievements = [
    { 
      id: 'first_note', 
      name: 'Getting Started', 
      description: 'Create your first note', 
      icon: '🌱', 
      unlocked: noteCount >= 1,
      progress: Math.min(noteCount, 1),
      target: 1
    },
    { 
      id: 'prolific_writer', 
      name: 'Prolific Writer', 
      description: 'Create 50 notes', 
      icon: '📝', 
      unlocked: noteCount >= 50,
      progress: Math.min(noteCount, 50),
      target: 50
    },
    { 
      id: 'task_master', 
      name: 'Task Master', 
      description: 'Complete 100 tasks', 
      icon: '✅', 
      unlocked: completedTodos >= 100,
      progress: Math.min(completedTodos, 100),
      target: 100
    },
    { 
      id: 'ai_enthusiast', 
      name: 'AI Enthusiast', 
      description: 'Process 25 notes with AI', 
      icon: '🤖', 
      unlocked: (apiStats?.totalRequests || 0) >= 25,
      progress: Math.min(apiStats?.totalRequests || 0, 25),
      target: 25
    }
  ];

  const streakDays = 7; // Mock streak data
  const productivityScore = Math.round(((completedTodos / Math.max(todoCount, 1)) * 100));

  return (
    <div className="space-y-3">
      {/* Header */}
      <div className="flex items-center justify-between px-4 pt-6">
        <div className="flex items-center gap-2">
          <h2 className="text-2xl font-serif font-medium text-gray-900 dark:text-gray-100">
            Settings
          </h2>
        </div>
        
        {/* Tiny Sync Status Bubble */}
        <div className="flex items-center gap-1.5">
          <div className={`w-2 h-2 rounded-full ${
            isSyncing ? 'bg-yellow-500' : 
            !isOnline && pendingItems > 0 ? 'bg-red-500' : 
            !isOnline ? 'bg-orange-500' : 
            'bg-green-500'
          }`} />
          <span className="text-xs text-gray-500">
            {isSyncing ? 'syncing' : 
             !isOnline && pendingItems > 0 ? 'offline' : 
             !isOnline ? 'offline' : 
             'synced'}
          </span>
        </div>
      </div>

      {/* Settings Content */}
      <div className="p-4 space-y-6">

        {/* Stats & Achievements */}
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="p-3 border-b border-gray-100">
            <h2 className="text-sm font-medium text-gray-900 flex items-center gap-2">
              <Trophy className="w-4 h-4 text-yellow-500" />
              Your Journey
            </h2>
          </div>
          <div className="p-3 space-y-3">
            {/* Stats Grid - 2 Rows by 2 Columns */}
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gridTemplateRows: '1fr 1fr', gap: '8px' }}>
              <div className="text-center p-2 bg-blue-50 rounded">
                <div className="text-lg font-bold text-blue-600">{noteCount}</div>
                <div className="text-xs text-blue-600">Notes</div>
              </div>
              <div className="text-center p-2 bg-purple-50 rounded">
                <div className="text-lg font-bold text-purple-600">{todoCount}</div>
                <div className="text-xs text-purple-600">To-do's</div>
              </div>
              <div className="text-center p-2 bg-green-50 rounded">
                <div className="text-lg font-bold text-green-600">{productivityScore}%</div>
                <div className="text-xs text-green-600">Done</div>
              </div>
              <div className="text-center p-2 bg-orange-50 rounded">
                <div className="text-lg font-bold text-orange-600">{streakDays}</div>
                <div className="text-xs text-orange-600">Streak days</div>
              </div>
            </div>

            {/* Achievements */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <span className="text-xs font-medium text-gray-700">Achievements</span>
                <span className="text-xs text-gray-500">{achievements.filter(a => a.unlocked).length}/{achievements.length}</span>
              </div>
              <div className="space-y-1">
                {achievements.slice(0, 3).map((achievement) => (
                  <div 
                    key={achievement.id} 
                    className={`flex items-center gap-2 p-1 rounded ${
                      achievement.unlocked 
                        ? 'bg-yellow-50 border border-yellow-200' 
                        : 'bg-gray-50 border border-gray-200'
                    }`}
                  >
                    <span className={`text-sm ${achievement.unlocked ? '' : 'grayscale opacity-50'}`}>
                      {achievement.icon}
                    </span>
                    <div className="flex-1 min-w-0">
                      <div className={`text-xs font-medium truncate ${achievement.unlocked ? 'text-gray-900' : 'text-gray-500'}`}>
                        {achievement.name}
                      </div>
                      <div className="flex items-center gap-1 mt-0.5">
                        <div className="flex-1 bg-gray-200 rounded-full h-1">
                          <div 
                            className={`h-1 rounded-full ${achievement.unlocked ? 'bg-yellow-500' : 'bg-gray-400'}`}
                            style={{ width: `${(achievement.progress / achievement.target) * 100}%` }}
                          />
                        </div>
                        <span className="text-xs text-gray-500 font-medium">
                          {achievement.progress}/{achievement.target}
                        </span>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>

        {/* Personal Profile */}
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="p-4 border-b border-gray-100">
            <h2 className="text-base font-medium text-gray-900 flex items-center gap-2">
              <Target className="w-5 h-5 text-blue-500" />
              Personal Profile
            </h2>
          </div>
          <div className="p-4 space-y-4">
            <div className="text-sm text-gray-600">
              Help Mira learn about you to provide more personalized assistance.
            </div>
            <div className="space-y-3">
              {userProfile?.personalBio ? (
                <div className="p-3 bg-green-50 rounded-lg border border-green-200">
                  <div className="flex items-center gap-2 mb-2">
                    <User className="w-4 h-4 text-green-600" />
                    <span className="text-sm font-medium text-green-900">Your AI Assistant Profile</span>
                  </div>
                  <div className="text-xs text-green-700 mb-2">
                    {userProfile.personalBio.slice(0, 150)}...
                  </div>
                  <div className="flex gap-2">
                    <button 
                      onClick={() => setShowBioPreview(true)}
                      className="text-xs text-green-600 hover:text-green-700 flex items-center gap-1"
                    >
                      <Info className="w-3 h-3" />
                      Read Full Bio
                    </button>
                    <button 
                      onClick={() => setShowQuickProfile(true)}
                      className="text-xs text-green-600 hover:text-green-700 flex items-center gap-1"
                    >
                      <Edit3 className="w-3 h-3" />
                      Update
                    </button>
                  </div>
                </div>
              ) : (
                <>
                  <button 
                    onClick={() => setShowOnboarding(true)}
                    className="w-full flex items-center justify-between p-3 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
                        <span className="text-blue-600 font-medium">?</span>
                      </div>
                      <div className="text-left">
                        <div className="text-sm font-medium text-blue-900">Complete Onboarding</div>
                        <div className="text-xs text-blue-600">Answer questions to personalize Mira</div>
                      </div>
                    </div>
                    <div className="text-blue-600 text-sm">Start</div>
                  </button>
                  <button 
                    onClick={() => setShowQuickProfile(true)}
                    className="w-full flex items-center justify-between p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center">
                        <span className="text-gray-600">📋</span>
                      </div>
                      <div className="text-left">
                        <div className="text-sm font-medium text-gray-900">Quick Profile</div>
                        <div className="text-xs text-gray-500">Paste info about yourself</div>
                      </div>
                    </div>
                    <div className="text-gray-600 text-sm">Add</div>
                  </button>
                </>
              )}
            </div>
          </div>
        </div>

        {/* API Usage (Compact) */}
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="p-3 border-b border-gray-100">
            <h2 className="text-sm font-medium text-gray-900 flex items-center gap-2">
              <GraduationCap className="w-4 h-4 text-purple-500" />
              AI Usage
            </h2>
          </div>
          <div className="p-3 space-y-2">
            <div className="grid grid-cols-3 gap-2 text-center">
              <div className="p-2 bg-indigo-50 rounded">
                <div className="text-sm font-bold text-indigo-600">{apiStats?.openai?.requests || 0}</div>
                <div className="text-xs text-indigo-600">OpenAI</div>
              </div>
              <div className="p-2 bg-cyan-50 rounded">
                <div className="text-sm font-bold text-cyan-600">{apiStats?.claude?.requests || 0}</div>
                <div className="text-xs text-cyan-600">Claude</div>
              </div>
              <div className="p-2 bg-green-50 rounded">
                <div className="text-sm font-bold text-green-600">${((apiStats?.openai?.cost || 0) + (apiStats?.claude?.cost || 0)).toFixed(3)}</div>
                <div className="text-xs text-green-600">Cost</div>
              </div>
            </div>
          </div>
        </div>

        {/* AI Model Settings */}
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="p-4 border-b border-gray-100">
            <h2 className="text-base font-medium text-gray-900">AI Settings</h2>
          </div>
          <div className="p-4 space-y-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <GraduationCap size={20} className="text-gray-500" />
                <div>
                  <div className="text-sm font-medium text-gray-900">AI Model</div>
                  <div className="text-xs text-gray-500">Choose your preferred AI provider</div>
                </div>
              </div>
              <div className="flex gap-1 bg-gray-100 rounded-lg p-1">
                <button
                  onClick={() => setAiModel('openai')}
                  className={`px-3 py-2 rounded text-xs font-medium transition-colors ${aiModel === 'openai' ? 'bg-white shadow-sm text-green-600' : 'hover:bg-gray-200 text-gray-600'}`}
                >
                  🤖 OpenAI
                </button>
                <button
                  onClick={() => setAiModel('claude')}
                  className={`px-3 py-2 rounded text-xs font-medium transition-colors ${aiModel === 'claude' ? 'bg-white shadow-sm text-blue-600' : 'hover:bg-gray-200 text-gray-600'}`}
                >
                  🧠 Claude
                </button>
              </div>
            </div>
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <Target size={20} className="text-gray-500" />
                <div>
                  <div className="text-sm font-medium text-gray-900">Show Emojis</div>
                  <div className="text-xs text-gray-500">Add emojis to note titles</div>
                </div>
              </div>
              <button
                onClick={() => setShowEmojis(!showEmojis)}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${showEmojis ? 'bg-blue-600' : 'bg-gray-200'}`}
              >
                <span className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${showEmojis ? 'translate-x-6' : 'translate-x-1'}`} />
              </button>
            </div>
          </div>
        </div>

        {/* Appearance Section */}
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="p-4 border-b border-gray-100">
            <h2 className="text-base font-medium text-gray-900">Appearance</h2>
          </div>
          <div className="p-4 space-y-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <Palette size={20} className="text-gray-500" />
                <div>
                  <div className="text-sm font-medium text-gray-900">Theme</div>
                  <div className="text-xs text-gray-500">Choose your preferred theme</div>
                </div>
              </div>
              <div className="flex gap-1 bg-gray-100 rounded-lg p-1">
                <button
                  onClick={() => setTheme('light')}
                  className={`p-2 rounded transition-colors ${theme === 'light' ? 'bg-white shadow-sm' : 'hover:bg-gray-200'}`}
                >
                  <Sun size={16} />
                </button>
                <button
                  onClick={() => setTheme('dark')}
                  className={`p-2 rounded transition-colors ${theme === 'dark' ? 'bg-white shadow-sm' : 'hover:bg-gray-200'}`}
                >
                  <Moon size={16} />
                </button>
                <button
                  onClick={() => setTheme('system')}
                  className={`p-2 rounded transition-colors ${theme === 'system' ? 'bg-white shadow-sm' : 'hover:bg-gray-200'}`}
                >
                  <Monitor size={16} />
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Data Management Section */}
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="p-4 border-b border-gray-100">
            <h2 className="text-base font-medium text-gray-900">Data Management</h2>
          </div>
          <div className="p-4 space-y-4">
            <button
              onClick={handleClearData}
              className="w-full flex items-center gap-3 p-3 rounded-lg hover:bg-red-50 transition-colors text-left"
            >
              <Trash2 size={20} className="text-red-600" />
              <div>
                <div className="text-sm font-medium text-red-600">Clear All Data</div>
                <div className="text-xs text-gray-500">Delete all notes and tasks</div>
              </div>
            </button>
          </div>
        </div>

        {/* About Section */}
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="p-4 border-b border-gray-100">
            <h2 className="text-base font-medium text-gray-900">About</h2>
          </div>
          <div className="p-4 space-y-4">
            <div className="flex items-center gap-3 p-3 rounded-lg">
              <Info size={20} className="text-gray-500" />
              <div>
                <div className="text-sm font-medium text-gray-900">Mira</div>
                <div className="text-xs text-gray-500">AI-powered memory and productivity app</div>
                <div className="text-xs text-gray-400 mt-1">Version 1.0.0</div>
              </div>
            </div>
          </div>
        </div>

        {/* Account Section - Compact at Bottom */}
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="p-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <User size={16} className="text-gray-500" />
                <div>
                  <div className="text-sm font-medium text-gray-900">Demo User</div>
                  <div className="text-xs text-gray-500">Not logged in</div>
                </div>
              </div>
              <button
                onClick={() => window.location.href = '/api/login'}
                className="flex items-center gap-1 px-2 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700 transition-colors"
              >
                <LogIn size={12} />
                Login
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Onboarding Modal */}
      {showOnboarding && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
            <div className="p-6">
              <div className="flex items-center justify-between mb-6">
                <h2 className="text-xl font-semibold">Help Mira Learn About You</h2>
                <button 
                  onClick={() => setShowOnboarding(false)}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>
              
              <div className="space-y-6">
                <p className="text-gray-600">
                  Answer these questions to help Mira provide more personalized assistance. You can skip questions and come back later.
                </p>
                
                {onboardingQuestions.map((q, index) => (
                  <div key={q.id} className="space-y-2">
                    <label className="text-sm font-medium text-gray-700">
                      {index + 1}. {q.question}
                    </label>
                    <textarea
                      value={onboardingAnswers[q.id] || ''}
                      onChange={(e) => setOnboardingAnswers(prev => ({
                        ...prev,
                        [q.id]: e.target.value
                      }))}
                      placeholder={q.placeholder}
                      className="w-full p-3 border border-gray-200 rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      rows={3}
                    />
                  </div>
                ))}
                
                <div className="flex items-center justify-between pt-4 border-t">
                  <div className="text-sm text-gray-500">
                    {Object.keys(onboardingAnswers).length} of {onboardingQuestions.length} answered
                  </div>
                  <div className="flex gap-3">
                    <button 
                      onClick={() => setShowOnboarding(false)}
                      className="px-4 py-2 text-gray-600 hover:text-gray-800"
                    >
                      Cancel
                    </button>
                    <button 
                      onClick={handleSubmitOnboarding}
                      disabled={onboardingMutation.isPending}
                      className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
                    >
                      {onboardingMutation.isPending ? 'Creating Profile...' : 'Create AI Profile'}
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Quick Profile Modal */}
      {showQuickProfile && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-lg w-full">
            <div className="p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-lg font-semibold">Quick Profile</h2>
                <button 
                  onClick={() => {
                    setShowQuickProfile(false);
                    setProfileText('');
                  }}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>
              
              <div className="space-y-4">
                <p className="text-sm text-gray-600">
                  Paste information about yourself - bio, resume, personality test results, or anything that helps Mira understand you better.
                </p>
                
                <textarea
                  value={profileText}
                  onChange={(e) => setProfileText(e.target.value)}
                  placeholder="Tell me about yourself... your role, interests, goals, work style, or anything else that would help an AI assistant understand you better."
                  className="w-full p-3 border border-gray-200 rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  rows={8}
                />
                
                <div className="flex gap-3 justify-end">
                  <button 
                    onClick={() => {
                      setShowQuickProfile(false);
                      setProfileText('');
                    }}
                    className="px-4 py-2 text-gray-600 hover:text-gray-800"
                  >
                    Cancel
                  </button>
                  <button 
                    onClick={handleQuickProfile}
                    disabled={!profileText.trim() || quickProfileMutation.isPending}
                    className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {quickProfileMutation.isPending ? 'Generating Profile...' : 'Add Profile'}
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Bio Preview Modal */}
      {showBioPreview && userProfile?.personalBio && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
            <div className="p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-lg font-semibold">Your AI Assistant Profile</h2>
                <button 
                  onClick={() => setShowBioPreview(false)}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>
              
              <div className="prose prose-sm max-w-none">
                <div className="whitespace-pre-line text-gray-700">
                  {userProfile.personalBio}
                </div>
              </div>
              
              <div className="flex justify-end mt-6 pt-4 border-t">
                <button 
                  onClick={() => setShowBioPreview(false)}
                  className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200"
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}```

### client/src/pages/todo-detail.tsx
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { ChevronLeft, CheckCircle2, Circle, Pin, Archive, Calendar, AlertCircle } from "lucide-react";
import { getQueryFn, apiRequest, queryClient } from "@/lib/queryClient";
import type { Todo, NoteWithTodos } from "@shared/schema";

export default function TodoDetail() {
  const { id } = useParams();
  const [, setLocation] = useLocation();

  const { data: todos } = useQuery<Todo[]>({
    queryKey: ["/api/todos"],
  });

  const { data: notes } = useQuery<NoteWithTodos[]>({
    queryKey: ["/api/notes"],
  });

  const todo = todos?.find(t => t.id === parseInt(id || "0"));
  const sourceNote = notes?.find(n => n.id === todo?.noteId);

  const toggleTodoMutation = useMutation({
    mutationFn: async (updates: Partial<Todo>) => {
      if (!id) throw new Error("No todo ID");
      const response = await apiRequest("PATCH", `/api/todos/${id}`, updates);
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  const pinTodoMutation = useMutation({
    mutationFn: async () => {
      if (!todo) throw new Error("No todo data");
      const response = await apiRequest("PATCH", `/api/todos/${id}`, {
        pinned: !todo.pinned
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
    },
  });

  const archiveTodoMutation = useMutation({
    mutationFn: async () => {
      const response = await apiRequest("PATCH", `/api/todos/${id}`, {
        archived: true
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/todos"] });
      setLocation("/");
    },
  });

  if (!todo || !id) {
    return (
      <div className="mx-auto max-w-sm w-full h-full flex flex-col">
        <header className="bg-white px-4 py-3 border-b border-gray-100 flex-shrink-0">
          <div className="flex items-center justify-between">
            <button 
              onClick={() => setLocation("/")}
              className="flex items-center text-[hsl(var(--ios-blue))] touch-manipulation"
            >
              <ChevronLeft className="w-5 h-5 mr-1" />
              Back
            </button>
            <h1 className="text-lg font-semibold">Loading...</h1>
            <div className="w-12"></div>
          </div>
        </header>
        <div className="flex-1 flex items-center justify-center">
          <div className="animate-pulse text-center">
            <div className="w-16 h-16 bg-gray-200 rounded-full mx-auto mb-4"></div>
            <div className="h-4 bg-gray-200 rounded w-32 mx-auto"></div>
          </div>
        </div>
      </div>
    );
  }

  const handleToggle = () => {
    toggleTodoMutation.mutate({ completed: !todo.completed });
  };

  const handlePin = () => {
    pinTodoMutation.mutate();
  };

  const handleArchive = () => {
    archiveTodoMutation.mutate();
  };

  return (
    <div className="mx-auto max-w-sm w-full h-full flex flex-col bg-white">
      {/* Header */}
      <header className="bg-white px-4 py-3 border-b border-gray-100 flex-shrink-0">
        <div className="flex items-center justify-between">
          <button 
            onClick={() => setLocation("/")}
            className="flex items-center text-[hsl(var(--ios-blue))] touch-manipulation"
          >
            <ChevronLeft className="w-5 h-5 mr-1" />
            Back
          </button>
          <h1 className="text-lg font-semibold">Todo Details</h1>
          <div className="flex items-center space-x-1">
            <button 
              onClick={handlePin}
              className={`p-2 touch-manipulation ${todo.pinned ? 'text-amber-600' : 'text-gray-400'}`}
            >
              <Pin className="w-5 h-5" />
            </button>
            <button 
              onClick={handleArchive}
              className="p-2 text-gray-400 touch-manipulation"
            >
              <Archive className="w-5 h-5" />
            </button>
          </div>
        </div>
      </header>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        <div className="p-4 space-y-6">
          {/* Todo Card */}
          <div className="bg-white border border-gray-200 rounded-xl p-4 shadow-sm">
            <div className="flex items-start space-x-3">
              <button 
                onClick={handleToggle}
                disabled={toggleTodoMutation.isPending}
                className="mt-1 touch-manipulation"
              >
                {todo.completed ? (
                  <CheckCircle2 className="w-6 h-6 text-green-600" />
                ) : (
                  <Circle className="w-6 h-6 text-gray-400" />
                )}
              </button>
              
              <div className="flex-1 min-w-0">
                <h2 className={`font-medium text-lg leading-tight ${
                  todo.completed ? 'line-through text-gray-500' : 'text-gray-900'
                }`}>
                  {todo.title}
                </h2>
                
                <div className="flex items-center space-x-2 mt-2">
                  {todo.priority === "urgent" && (
                    <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium text-red-800 bg-red-50 border border-red-200">
                      <AlertCircle className="w-3 h-3 mr-1" />
                      Urgent
                    </span>
                  )}
                  
                  {todo.pinned && (
                    <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium text-amber-800 bg-amber-50 border border-amber-200">
                      <Pin className="w-3 h-3 mr-1" />
                      Pinned
                    </span>
                  )}
                  
                  <span className="text-xs text-gray-500">
                    <Calendar className="w-3 h-3 inline mr-1" />
                    {new Date(todo.createdAt).toLocaleDateString()}
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* Source Note */}
          {sourceNote && (
            <div className="space-y-3">
              <h3 className="font-semibold text-gray-900">Source Note</h3>
              <div 
                onClick={() => setLocation(`/notes/${sourceNote.id}`)}
                className="bg-white border border-gray-200 rounded-lg p-3 cursor-pointer hover:shadow-sm transition-shadow touch-manipulation"
              >
                <p className="text-sm text-gray-800 line-clamp-3">{sourceNote.content}</p>
                <div className="flex items-center justify-between mt-2">
                  <span className="text-xs text-gray-500">
                    {new Date(sourceNote.createdAt).toLocaleDateString()}
                  </span>
                  {sourceNote.todos && sourceNote.todos.length > 1 && (
                    <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded-full">
                      {sourceNote.todos.length} todos from this note
                    </span>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}```

### client/src/store/app-store.ts
```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { NoteWithTodos, Todo, Collection } from '@shared/schema';

export interface SyncOperation {
  id: string;
  operation: 'create' | 'update' | 'delete';
  type: 'note' | 'todo' | 'collection';
  data: any;
  timestamp: number;
  retries: number;
}

interface AppState {
  // Data
  notes: NoteWithTodos[];
  todos: Todo[];
  collections: Collection[];
  
  // App State
  isOffline: boolean;
  isLoading: boolean;
  lastSync: number;
  syncQueue: SyncOperation[];
  
  // UI State
  activeTab: 'activity' | 'todos' | 'collections' | 'settings';
  showCapture: boolean;
  selectedNote: number | null;
  
  // Actions
  setNotes: (notes: NoteWithTodos[]) => void;
  addNote: (note: NoteWithTodos) => void;
  updateNote: (id: number, updates: Partial<NoteWithTodos>) => void;
  deleteNote: (id: number) => void;
  
  setTodos: (todos: Todo[]) => void;
  addTodo: (todo: Todo) => void;
  updateTodo: (id: number, updates: Partial<Todo>) => void;
  deleteTodo: (id: number) => void;
  
  setCollections: (collections: Collection[]) => void;
  addCollection: (collection: Collection) => void;
  updateCollection: (id: number, updates: Partial<Collection>) => void;
  deleteCollection: (id: number) => void;
  
  // Sync operations
  setOfflineStatus: (isOffline: boolean) => void;
  setLoading: (loading: boolean) => void;
  addToSyncQueue: (operation: Omit<SyncOperation, 'id' | 'timestamp' | 'retries'>) => void;
  processSyncQueue: () => Promise<void>;
  clearSyncQueue: () => void;
  updateLastSync: () => void;
  
  // UI actions
  setActiveTab: (tab: 'activity' | 'todos' | 'collections' | 'settings') => void;
  setShowCapture: (show: boolean) => void;
  setSelectedNote: (id: number | null) => void;
}

export const useAppStore = create<AppState>()(
  persist(
    (set, get) => ({
      // Initial state
      notes: [],
      todos: [],
      collections: [],
      isOffline: !navigator.onLine,
      isLoading: false,
      lastSync: 0,
      syncQueue: [],
      activeTab: 'activity',
      showCapture: false,
      selectedNote: null,

      // Data actions
      setNotes: (notes) => set({ notes }),
      
      addNote: (note) => {
        set((state) => ({ notes: [...state.notes, note] }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'create', type: 'note', data: note });
        }
      },
      
      updateNote: (id, updates) => {
        set((state) => ({
          notes: state.notes.map(note => 
            note.id === id ? { ...note, ...updates } : note
          )
        }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'update', type: 'note', data: { id, updates } });
        }
      },
      
      deleteNote: (id) => {
        set((state) => ({
          notes: state.notes.filter(note => note.id !== id),
          todos: state.todos.filter(todo => todo.noteId !== id)
        }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'delete', type: 'note', data: { id } });
        }
      },

      setTodos: (todos) => set({ todos }),
      
      addTodo: (todo) => {
        set((state) => ({ todos: [...state.todos, todo] }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'create', type: 'todo', data: todo });
        }
      },
      
      updateTodo: (id, updates) => {
        set((state) => ({
          todos: state.todos.map(todo => 
            todo.id === id ? { ...todo, ...updates } : todo
          )
        }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'update', type: 'todo', data: { id, updates } });
        }
      },
      
      deleteTodo: (id) => {
        set((state) => ({
          todos: state.todos.filter(todo => todo.id !== id)
        }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'delete', type: 'todo', data: { id } });
        }
      },

      setCollections: (collections) => set({ collections }),
      
      addCollection: (collection) => {
        set((state) => ({ collections: [...state.collections, collection] }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'create', type: 'collection', data: collection });
        }
      },
      
      updateCollection: (id, updates) => {
        set((state) => ({
          collections: state.collections.map(collection => 
            collection.id === id ? { ...collection, ...updates } : collection
          )
        }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'update', type: 'collection', data: { id, updates } });
        }
      },
      
      deleteCollection: (id) => {
        set((state) => ({
          collections: state.collections.filter(collection => collection.id !== id)
        }));
        if (!get().isOffline) {
          get().addToSyncQueue({ operation: 'delete', type: 'collection', data: { id } });
        }
      },

      // Sync operations
      setOfflineStatus: (isOffline) => set({ isOffline }),
      
      setLoading: (loading) => set({ isLoading: loading }),
      
      addToSyncQueue: (operation) => {
        const syncOp: SyncOperation = {
          ...operation,
          id: Math.random().toString(36).substr(2, 9),
          timestamp: Date.now(),
          retries: 0
        };
        set((state) => ({ 
          syncQueue: [...state.syncQueue, syncOp] 
        }));
      },
      
      processSyncQueue: async () => {
        const { syncQueue } = get();
        if (syncQueue.length === 0) return;

        set({ isLoading: true });
        
        for (const operation of syncQueue) {
          try {
            const response = await fetch(`/api/${operation.type}s${operation.operation === 'create' ? '' : `/${operation.data.id}`}`, {
              method: operation.operation === 'create' ? 'POST' : 
                     operation.operation === 'update' ? 'PATCH' : 'DELETE',
              headers: { 'Content-Type': 'application/json' },
              body: operation.operation === 'delete' ? undefined : JSON.stringify(operation.data)
            });

            if (response.ok) {
              // Remove successful operation from queue
              set((state) => ({
                syncQueue: state.syncQueue.filter(op => op.id !== operation.id)
              }));
            } else {
              // Increment retry count
              set((state) => ({
                syncQueue: state.syncQueue.map(op => 
                  op.id === operation.id ? { ...op, retries: op.retries + 1 } : op
                )
              }));
            }
          } catch (error) {
            console.error('Sync operation failed:', error);
            // Increment retry count
            set((state) => ({
              syncQueue: state.syncQueue.map(op => 
                op.id === operation.id ? { ...op, retries: op.retries + 1 } : op
              )
            }));
          }
        }
        
        set({ isLoading: false });
        get().updateLastSync();
      },
      
      clearSyncQueue: () => set({ syncQueue: [] }),
      
      updateLastSync: () => set({ lastSync: Date.now() }),

      // UI actions
      setActiveTab: (tab) => set({ activeTab: tab }),
      setShowCapture: (show) => set({ showCapture: show }),
      setSelectedNote: (id) => set({ selectedNote: id })
    }),
    {
      name: 'mira-app-storage',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        notes: state.notes,
        todos: state.todos,
        collections: state.collections,
        lastSync: state.lastSync,
        syncQueue: state.syncQueue,
        activeTab: state.activeTab
      })
    }
  )
);

// Network monitoring setup
export const setupNetworkMonitoring = () => {
  const updateOnlineStatus = () => {
    const isOnline = navigator.onLine;
    useAppStore.getState().setOfflineStatus(!isOnline);
    
    if (isOnline) {
      // Process sync queue when coming back online
      useAppStore.getState().processSyncQueue();
    }
  };
  
  // Set initial status
  updateOnlineStatus();
  
  // Listen for network changes
  window.addEventListener('online', updateOnlineStatus);
  window.addEventListener('offline', updateOnlineStatus);
  
  // Cleanup function
  return () => {
    window.removeEventListener('online', updateOnlineStatus);
    window.removeEventListener('offline', updateOnlineStatus);
  };
};```

### client/src/store/indexeddb.ts
```typescript
import { openDB, type DBSchema, type IDBPDatabase } from 'idb';
import { NoteWithTodos, Todo, Collection } from '@shared/schema';
import { SyncOperation } from './app-store';

interface MiraDB extends DBSchema {
  notes: {
    key: number;
    value: NoteWithTodos;
    indexes: { 'by-updated': string; 'by-collection': number };
  };
  todos: {
    key: number;
    value: Todo;
    indexes: { 'by-note': number; 'by-completed': boolean };
  };
  collections: {
    key: number;
    value: Collection;
    indexes: { 'by-name': string };
  };
  sync_queue: {
    key: string;
    value: SyncOperation;
    indexes: { 'by-timestamp': number };
  };
}

class IndexedDBManager {
  private db: IDBPDatabase<MiraDB> | null = null;
  private readonly DB_NAME = 'MiraDB';
  private readonly DB_VERSION = 1;

  async init(): Promise<void> {
    try {
      this.db = await openDB<MiraDB>(this.DB_NAME, this.DB_VERSION, {
        upgrade(db) {
          // Notes store
          if (!db.objectStoreNames.contains('notes')) {
            const notesStore = db.createObjectStore('notes', { keyPath: 'id' });
            notesStore.createIndex('by-updated', 'updatedAt');
            notesStore.createIndex('by-collection', 'collectionId');
          }

          // Todos store
          if (!db.objectStoreNames.contains('todos')) {
            const todosStore = db.createObjectStore('todos', { keyPath: 'id' });
            todosStore.createIndex('by-note', 'noteId');
            todosStore.createIndex('by-completed', 'completed');
          }

          // Collections store
          if (!db.objectStoreNames.contains('collections')) {
            const collectionsStore = db.createObjectStore('collections', { keyPath: 'id' });
            collectionsStore.createIndex('by-name', 'name');
          }

          // Sync queue store
          if (!db.objectStoreNames.contains('sync_queue')) {
            const syncStore = db.createObjectStore('sync_queue', { keyPath: 'id' });
            syncStore.createIndex('by-timestamp', 'timestamp');
          }
        },
      });
    } catch (error) {
      console.error('Failed to initialize IndexedDB:', error);
      throw error;
    }
  }

  private ensureDB(): IDBPDatabase<MiraDB> {
    if (!this.db) {
      throw new Error('Database not initialized. Call init() first.');
    }
    return this.db;
  }

  // Notes operations
  async saveNote(note: NoteWithTodos): Promise<void> {
    const db = this.ensureDB();
    await db.put('notes', note);
  }

  async getNote(id: number): Promise<NoteWithTodos | undefined> {
    const db = this.ensureDB();
    return await db.get('notes', id);
  }

  async getAllNotes(): Promise<NoteWithTodos[]> {
    const db = this.ensureDB();
    return await db.getAll('notes');
  }

  async deleteNote(id: number): Promise<void> {
    const db = this.ensureDB();
    await db.delete('notes', id);
  }

  async getNotesByCollection(collectionId: number): Promise<NoteWithTodos[]> {
    const db = this.ensureDB();
    return await db.getAllFromIndex('notes', 'by-collection', collectionId);
  }

  // Todos operations
  async saveTodo(todo: Todo): Promise<void> {
    const db = this.ensureDB();
    await db.put('todos', todo);
  }

  async getTodo(id: number): Promise<Todo | undefined> {
    const db = this.ensureDB();
    return await db.get('todos', id);
  }

  async getAllTodos(): Promise<Todo[]> {
    const db = this.ensureDB();
    return await db.getAll('todos');
  }

  async deleteTodo(id: number): Promise<void> {
    const db = this.ensureDB();
    await db.delete('todos', id);
  }

  async getTodosByNote(noteId: number): Promise<Todo[]> {
    const db = this.ensureDB();
    return await db.getAllFromIndex('todos', 'by-note', noteId);
  }

  async getCompletedTodos(): Promise<Todo[]> {
    const db = this.ensureDB();
    return await db.getAllFromIndex('todos', 'by-completed', true);
  }

  // Collections operations
  async saveCollection(collection: Collection): Promise<void> {
    const db = this.ensureDB();
    await db.put('collections', collection);
  }

  async getCollection(id: number): Promise<Collection | undefined> {
    const db = this.ensureDB();
    return await db.get('collections', id);
  }

  async getAllCollections(): Promise<Collection[]> {
    const db = this.ensureDB();
    return await db.getAll('collections');
  }

  async deleteCollection(id: number): Promise<void> {
    const db = this.ensureDB();
    await db.delete('collections', id);
  }

  // Sync queue operations
  async addToSyncQueue(operation: SyncOperation): Promise<void> {
    const db = this.ensureDB();
    await db.put('sync_queue', operation);
  }

  async getSyncQueue(): Promise<SyncOperation[]> {
    const db = this.ensureDB();
    return await db.getAll('sync_queue');
  }

  async removeSyncOperation(id: string): Promise<void> {
    const db = this.ensureDB();
    await db.delete('sync_queue', id);
  }

  async clearSyncQueue(): Promise<void> {
    const db = this.ensureDB();
    const tx = db.transaction('sync_queue', 'readwrite');
    await tx.store.clear();
  }

  // Utility operations
  async clearAllData(): Promise<void> {
    const db = this.ensureDB();
    const tx = db.transaction(['notes', 'todos', 'collections', 'sync_queue'], 'readwrite');
    await Promise.all([
      tx.objectStore('notes').clear(),
      tx.objectStore('todos').clear(),
      tx.objectStore('collections').clear(),
      tx.objectStore('sync_queue').clear(),
    ]);
  }

  async getStorageStats(): Promise<{
    notes: number;
    todos: number;
    collections: number;
    syncQueue: number;
  }> {
    const db = this.ensureDB();
    const [notes, todos, collections, syncQueue] = await Promise.all([
      db.count('notes'),
      db.count('todos'),
      db.count('collections'),
      db.count('sync_queue'),
    ]);

    return { notes, todos, collections, syncQueue };
  }
}

// Singleton instance
export const indexedDB = new IndexedDBManager();```

### client/src/store/offline-storage.ts
```typescript
/**
 * Enhanced Offline Storage System with Development Cache Busting
 * Provides comprehensive local storage with intelligent cache management
 */

interface StorageItem {
  data: any;
  timestamp: number;
  version: string;
  type: 'api' | 'user' | 'cache';
  expiry?: number;
}

interface CacheConfig {
  maxAge: number;
  priority: 'high' | 'medium' | 'low';
  syncOnReconnect: boolean;
}

class OfflineStorageManager {
  private dbName = 'MiraOfflineDB';
  private version = 1;
  private db: IDBDatabase | null = null;
  private isDevelopment = import.meta.env.DEV || location.hostname === 'localhost';
  
  // Cache configurations for different data types
  private cacheConfigs: Record<string, CacheConfig> = {
    'api/notes': { maxAge: 5 * 60 * 1000, priority: 'high', syncOnReconnect: true },
    'api/todos': { maxAge: 5 * 60 * 1000, priority: 'high', syncOnReconnect: true },
    'api/collections': { maxAge: 15 * 60 * 1000, priority: 'medium', syncOnReconnect: true },
    'user/preferences': { maxAge: 24 * 60 * 60 * 1000, priority: 'high', syncOnReconnect: false },
    'cache/images': { maxAge: 60 * 60 * 1000, priority: 'low', syncOnReconnect: false }
  };

  async init(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Create stores for different data types
        if (!db.objectStoreNames.contains('api')) {
          const apiStore = db.createObjectStore('api', { keyPath: 'key' });
          apiStore.createIndex('timestamp', 'timestamp');
          apiStore.createIndex('type', 'type');
        }
        
        if (!db.objectStoreNames.contains('user')) {
          const userStore = db.createObjectStore('user', { keyPath: 'key' });
          userStore.createIndex('timestamp', 'timestamp');
        }
        
        if (!db.objectStoreNames.contains('cache')) {
          const cacheStore = db.createObjectStore('cache', { keyPath: 'key' });
          cacheStore.createIndex('timestamp', 'timestamp');
          cacheStore.createIndex('expiry', 'expiry');
        }
      };
    });
  }

  // Store data with intelligent caching strategy
  async store(key: string, data: any, type: 'api' | 'user' | 'cache' = 'api'): Promise<void> {
    if (!this.db) await this.init();
    
    const config = this.cacheConfigs[key] || this.cacheConfigs['api/notes'];
    const now = Date.now();
    
    // In development, use shorter cache times
    const maxAge = this.isDevelopment ? Math.min(config.maxAge, 2 * 60 * 1000) : config.maxAge;
    
    const item: StorageItem = {
      data,
      timestamp: now,
      version: this.isDevelopment ? `dev-${now}` : '1.0.0',
      type,
      expiry: now + maxAge
    };

    const transaction = this.db!.transaction([type], 'readwrite');
    const store = transaction.objectStore(type);
    
    await new Promise((resolve, reject) => {
      const request = store.put({ key, ...item });
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  // Retrieve data with staleness checking
  async retrieve(key: string, type: 'api' | 'user' | 'cache' = 'api'): Promise<any | null> {
    if (!this.db) await this.init();
    
    const transaction = this.db!.transaction([type], 'readonly');
    const store = transaction.objectStore(type);
    
    return new Promise((resolve, reject) => {
      const request = store.get(key);
      request.onsuccess = () => {
        const result = request.result;
        if (!result) {
          resolve(null);
          return;
        }

        const now = Date.now();
        const config = this.cacheConfigs[key] || this.cacheConfigs['api/notes'];
        
        // Check if data is stale
        const maxAge = this.isDevelopment ? Math.min(config.maxAge, 2 * 60 * 1000) : config.maxAge;
        const isStale = now - result.timestamp > maxAge;
        
        if (isStale && this.isDevelopment) {
          // In development, return null for stale data to force refresh
          resolve(null);
        } else {
          resolve(result.data);
        }
      };
      request.onerror = () => reject(request.error);
    });
  }

  // Clear stale cache entries
  async clearStaleEntries(): Promise<void> {
    if (!this.db) await this.init();
    
    const now = Date.now();
    const stores = ['api', 'user', 'cache'];
    
    for (const storeName of stores) {
      const transaction = this.db!.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      const index = store.index('timestamp');
      
      const request = index.openCursor();
      request.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest).result;
        if (cursor) {
          const data = cursor.value;
          const config = this.cacheConfigs[data.key] || this.cacheConfigs['api/notes'];
          const maxAge = this.isDevelopment ? Math.min(config.maxAge, 2 * 60 * 1000) : config.maxAge;
          
          if (now - data.timestamp > maxAge) {
            cursor.delete();
          }
          cursor.continue();
        }
      };
    }
  }

  // Development: Force clear all caches
  async clearAllCaches(): Promise<void> {
    if (!this.db) await this.init();
    
    const stores = ['api', 'user', 'cache'];
    
    for (const storeName of stores) {
      const transaction = this.db!.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      await new Promise((resolve, reject) => {
        const request = store.clear();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    console.log('All offline caches cleared for development');
  }

  // Get cache statistics
  async getCacheStats(): Promise<{ total: number; byType: Record<string, number>; oldestEntry: number }> {
    if (!this.db) await this.init();
    
    const stats = { total: 0, byType: { api: 0, user: 0, cache: 0 }, oldestEntry: Date.now() };
    const stores = ['api', 'user', 'cache'];
    
    for (const storeName of stores) {
      const transaction = this.db!.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      
      await new Promise((resolve, reject) => {
        const request = store.count();
        request.onsuccess = () => {
          stats.byType[storeName as keyof typeof stats.byType] = request.result;
          stats.total += request.result;
          resolve(request.result);
        };
        request.onerror = () => reject(request.error);
      });
      
      // Find oldest entry
      const index = store.index('timestamp');
      await new Promise((resolve, reject) => {
        const request = index.openCursor();
        request.onsuccess = (event) => {
          const cursor = (event.target as IDBRequest).result;
          if (cursor) {
            stats.oldestEntry = Math.min(stats.oldestEntry, cursor.value.timestamp);
          }
          resolve(undefined);
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    return stats;
  }
}

// Singleton instance
export const offlineStorage = new OfflineStorageManager();

// Enhanced service worker communication
export class ServiceWorkerManager {
  private registration: ServiceWorkerRegistration | null = null;
  
  async init(): Promise<void> {
    if ('serviceWorker' in navigator) {
      try {
        this.registration = await navigator.serviceWorker.register('/sw.js');
        console.log('ServiceWorker registered');
        
        // Handle updates in development
        if (import.meta.env.DEV) {
          this.registration.addEventListener('updatefound', () => {
            console.log('New ServiceWorker version available in development');
            this.registration?.update();
          });
        }
      } catch (error) {
        console.warn('ServiceWorker registration failed:', error);
      }
    }
  }

  // Force cache clearing for development
  async clearCaches(): Promise<boolean> {
    if (!this.registration || !this.registration.active) return false;
    
    return new Promise((resolve) => {
      const messageChannel = new MessageChannel();
      messageChannel.port1.onmessage = (event) => {
        resolve(event.data.success || false);
      };
      
      this.registration!.active!.postMessage(
        { type: 'CLEAR_CACHE' },
        [messageChannel.port2]
      );
    });
  }

  // Get cache status
  async getCacheStatus(): Promise<{ caches: string[]; isDevelopment: boolean; version: string }> {
    if (!this.registration || !this.registration.active) {
      return { caches: [], isDevelopment: false, version: 'unknown' };
    }
    
    return new Promise((resolve) => {
      const messageChannel = new MessageChannel();
      messageChannel.port1.onmessage = (event) => {
        resolve(event.data);
      };
      
      this.registration!.active!.postMessage(
        { type: 'GET_CACHE_STATUS' },
        [messageChannel.port2]
      );
    });
  }
}

export const serviceWorkerManager = new ServiceWorkerManager();

// Development cache busting utilities
export const devCacheUtils = {
  // Force refresh all data in development
  async forceRefresh(): Promise<void> {
    if (import.meta.env.DEV) {
      await offlineStorage.clearAllCaches();
      await serviceWorkerManager.clearCaches();
      
      // Clear browser caches
      if ('caches' in window) {
        const cacheNames = await caches.keys();
        await Promise.all(cacheNames.map(name => caches.delete(name)));
      }
      
      // Force reload
      window.location.reload();
    }
  },

  // Get comprehensive cache information
  async getCacheInfo(): Promise<{
    offlineStorage: any;
    serviceWorker: any;
    browserCaches: string[];
  }> {
    const info = {
      offlineStorage: await offlineStorage.getCacheStats(),
      serviceWorker: await serviceWorkerManager.getCacheStatus(),
      browserCaches: 'caches' in window ? await caches.keys() : []
    };
    
    console.log('Cache Information:', info);
    return info;
  }
};```

### client/src/store/offline-store.ts
```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { indexedDBManager } from '@/lib/indexeddb';
import { syncService } from '@/lib/sync-service';
import type { NoteWithTodos, Todo, Collection } from '@shared/schema';

interface OfflineState {
  // Data
  notes: NoteWithTodos[];
  collections: Collection[];
  pendingChanges: any[];
  
  // Sync status
  isOnline: boolean;
  isSyncing: boolean;
  lastSyncTime: number | null;
  pendingItems: number;
  conflictItems: number;
  
  // Actions
  loadFromIndexedDB: () => Promise<void>;
  
  // Notes actions
  createNote: (note: Omit<NoteWithTodos, 'id'>) => Promise<NoteWithTodos>;
  updateNote: (id: number, updates: Partial<NoteWithTodos>) => Promise<void>;
  deleteNote: (id: number) => Promise<void>;
  
  // Todo actions
  createTodo: (todo: Omit<Todo, 'id'>) => Promise<Todo>;
  updateTodo: (id: number, updates: Partial<Todo>) => Promise<void>;
  
  // Collection actions
  createCollection: (collection: Omit<Collection, 'id'>) => Promise<Collection>;
  updateCollection: (id: number, updates: Partial<Collection>) => Promise<void>;
  
  // Sync actions
  syncWithServer: () => Promise<void>;
  updateSyncStatus: (status: Partial<OfflineState>) => void;
}

export const useOfflineStore = create<OfflineState>()(
  persist(
    (set, get) => ({
      // Initial state
      notes: [],
      collections: [],
      pendingChanges: [],
      isOnline: navigator.onLine,
      isSyncing: false,
      lastSyncTime: null,
      pendingItems: 0,
      conflictItems: 0,

      // Load data from IndexedDB
      loadFromIndexedDB: async () => {
        try {
          await indexedDBManager.initialize();
          const [notes, collections] = await Promise.all([
            indexedDBManager.getNotes(),
            indexedDBManager.getCollections()
          ]);
          
          set({ notes, collections });
        } catch (error) {
          console.error('Failed to load from IndexedDB:', error);
        }
      },

      // Notes actions
      createNote: async (noteData) => {
        const state = get();
        
        if (state.isOnline) {
          try {
            // Try online first
            const response = await fetch('/api/notes', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(noteData),
            });
            
            if (response.ok) {
              const newNote = await response.json();
              await indexedDBManager.saveNote(newNote, 'synced');
              set(state => ({ notes: [...state.notes, newNote] }));
              return newNote;
            }
          } catch (error) {
            console.warn('Online creation failed, falling back to offline:', error);
          }
        }
        
        // Offline creation
        const newNote = await syncService.createNoteOffline(noteData);
        set(state => ({ notes: [...state.notes, newNote] }));
        return newNote;
      },

      updateNote: async (id, updates) => {
        const state = get();
        
        if (state.isOnline) {
          try {
            const response = await fetch(`/api/notes/${id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(updates),
            });
            
            if (response.ok) {
              const updatedNote = await response.json();
              await indexedDBManager.saveNote(updatedNote, 'synced');
              set(state => ({
                notes: state.notes.map(note => 
                  note.id === id ? updatedNote : note
                )
              }));
              return;
            }
          } catch (error) {
            console.warn('Online update failed, falling back to offline:', error);
          }
        }
        
        // Offline update
        await syncService.updateNoteOffline(id, updates);
        set(state => ({
          notes: state.notes.map(note => 
            note.id === id ? { ...note, ...updates } : note
          )
        }));
      },

      deleteNote: async (id) => {
        const state = get();
        
        if (state.isOnline) {
          try {
            const response = await fetch(`/api/notes/${id}`, {
              method: 'DELETE',
            });
            
            if (response.ok) {
              await indexedDBManager.deleteNote(id);
              set(state => ({
                notes: state.notes.filter(note => note.id !== id)
              }));
              return;
            }
          } catch (error) {
            console.warn('Online deletion failed, falling back to offline:', error);
          }
        }
        
        // Offline deletion
        await syncService.deleteNoteOffline(id);
        set(state => ({
          notes: state.notes.filter(note => note.id !== id)
        }));
      },

      // Todo actions
      createTodo: async (todoData) => {
        const state = get();
        
        if (state.isOnline) {
          try {
            const response = await fetch('/api/todos', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(todoData),
            });
            
            if (response.ok) {
              const newTodo = await response.json();
              await indexedDBManager.saveTodo(newTodo, 'synced');
              
              // Update the note with the new todo
              set(state => ({
                notes: state.notes.map(note => 
                  note.id === todoData.noteId 
                    ? { ...note, todos: [...note.todos, newTodo] }
                    : note
                )
              }));
              
              return newTodo;
            }
          } catch (error) {
            console.warn('Online todo creation failed, falling back to offline:', error);
          }
        }
        
        // Offline creation
        const newTodo = await syncService.createTodoOffline(todoData);
        set(state => ({
          notes: state.notes.map(note => 
            note.id === todoData.noteId 
              ? { ...note, todos: [...note.todos, newTodo] }
              : note
          )
        }));
        
        return newTodo;
      },

      updateTodo: async (id, updates) => {
        const state = get();
        
        if (state.isOnline) {
          try {
            const response = await fetch(`/api/todos/${id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(updates),
            });
            
            if (response.ok) {
              const updatedTodo = await response.json();
              await indexedDBManager.saveTodo(updatedTodo, 'synced');
              
              // Update the todo in the note
              set(state => ({
                notes: state.notes.map(note => ({
                  ...note,
                  todos: note.todos.map(todo => 
                    todo.id === id ? updatedTodo : todo
                  )
                }))
              }));
              
              return;
            }
          } catch (error) {
            console.warn('Online todo update failed, falling back to offline:', error);
          }
        }
        
        // Offline update
        await syncService.updateTodoOffline(id, updates);
        set(state => ({
          notes: state.notes.map(note => ({
            ...note,
            todos: note.todos.map(todo => 
              todo.id === id ? { ...todo, ...updates } : todo
            )
          }))
        }));
      },

      // Collection actions
      createCollection: async (collectionData) => {
        const state = get();
        
        if (state.isOnline) {
          try {
            const response = await fetch('/api/collections', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(collectionData),
            });
            
            if (response.ok) {
              const newCollection = await response.json();
              await indexedDBManager.saveCollection(newCollection, 'synced');
              set(state => ({ collections: [...state.collections, newCollection] }));
              return newCollection;
            }
          } catch (error) {
            console.warn('Online collection creation failed, falling back to offline:', error);
          }
        }
        
        // Offline creation
        const offlineId = Date.now();
        const newCollection = { ...collectionData, id: offlineId } as Collection;
        await indexedDBManager.saveCollection(newCollection, 'pending');
        await indexedDBManager.addToSyncQueue('create', 'collections', newCollection);
        


// Process offline voice notes when connection is restored
async function processOfflineVoiceNotes() {
  const state = useOfflineStore.getState();
  const offlineVoiceNotes = state.notes.filter(note => 
    note.isOffline && note.mode === 'voice' && note.audioBlob
  );

  for (const note of offlineVoiceNotes) {
    try {
      // Convert to FormData and send to server
      const formData = new FormData();
      formData.append("audio", note.audioBlob, "recording.webm");
      formData.append("duration", note.recordingDuration?.toString() || "0");
      
      const response = await fetch("/api/notes/voice", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      
      if (response.ok) {
        const processedNote = await response.json();
        
        // Update the note with processed content
        await state.updateNote(note.id, {
          content: processedNote.content,
          transcription: processedNote.transcription,
          audioUrl: processedNote.audioUrl,
          aiEnhanced: processedNote.aiEnhanced,
          aiSuggestion: processedNote.aiSuggestion,
          aiContext: processedNote.aiContext,
          isOffline: false,
          isProcessing: false
        });
        
        console.log(`Processed offline voice note: ${note.id}`);
      }
    } catch (error) {
      console.error(`Failed to process offline voice note ${note.id}:`, error);
    }
  }
}

        set(state => ({ collections: [...state.collections, newCollection] }));
        return newCollection;
      },

      updateCollection: async (id, updates) => {
        const state = get();
        
        if (state.isOnline) {
          try {
            const response = await fetch(`/api/collections/${id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(updates),
            });
            
            if (response.ok) {
              const updatedCollection = await response.json();
              await indexedDBManager.saveCollection(updatedCollection, 'synced');
              set(state => ({
                collections: state.collections.map(collection => 
                  collection.id === id ? updatedCollection : collection
                )
              }));
              return;
            }
          } catch (error) {
            console.warn('Online collection update failed, falling back to offline:', error);
          }
        }
        
        // Offline update
        const existingCollection = state.collections.find(c => c.id === id);
        if (existingCollection) {
          const updatedCollection = { ...existingCollection, ...updates };
          await indexedDBManager.saveCollection(updatedCollection, 'pending');
          await indexedDBManager.addToSyncQueue('update', 'collections', updatedCollection);
          
          set(state => ({
            collections: state.collections.map(collection => 
              collection.id === id ? updatedCollection : collection
            )
          }));
        }
      },

      // Sync actions
      syncWithServer: async () => {
        await syncService.syncWithServer();
        
        // Process offline voice notes
        await processOfflineVoiceNotes();
        
        // Reload data after sync
        const { loadFromIndexedDB } = get();
        await loadFromIndexedDB();
      },

      updateSyncStatus: (status) => {
        set(status);
      },
    }),
    {
      name: 'mira-offline-storage',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        // Only persist the sync status, not the actual data
        lastSyncTime: state.lastSyncTime,
      }),
    }
  )
);

// Initialize the store and sync service
export const initializeOfflineStore = async () => {
  const store = useOfflineStore.getState();
  
  // Load initial data from IndexedDB
  await store.loadFromIndexedDB();
  
  // Set up sync service status updates
  syncService.onStatusChange((status) => {
    store.updateSyncStatus({
      isOnline: status.isOnline,
      isSyncing: status.isSyncing,
      lastSyncTime: status.lastSyncTime,
      pendingItems: status.pendingItems,
      conflictItems: status.conflictItems,
    });
  });
  
  // Initial sync if online
  if (navigator.onLine) {
    await store.syncWithServer();
  }
};```
## CONFIGURATION FILES

### package.json
```json
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.37.0",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@replit/object-storage": "^1.0.0",
    "@tanstack/react-query": "^5.60.5",
    "@types/memoizee": "^0.4.12",
    "@types/multer": "^1.4.12",
    "@types/uuid": "^10.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "dotenv": "^16.5.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-rate-limit": "^7.5.0",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "idb": "^8.0.3",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "marked": "^15.0.12",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "multer": "^2.0.0",
    "neo4j-driver": "^5.28.1",
    "next-themes": "^0.4.6",
    "openai": "^5.0.1",
    "openid-client": "^6.5.0",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "postgres": "^3.4.7",
    "react": "18.2.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "18.2.0",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-markdown": "^10.1.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "uuid": "^11.1.0",
    "vaul": "^1.1.2",
    "vitest": "^3.2.3",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.2.7",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}
```

### tsconfig.json
```json
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}
```

### vite.config.ts
```json
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
});
```

### tailwind.config.ts
```json
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;
```

### drizzle.config.ts
```json
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});
```
## DATABASE SCHEMA

### shared/schema.ts
```typescript
import { pgTable, text, serial, integer, boolean, timestamp, json, varchar, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { relations } from "drizzle-orm";
import { z } from "zod";

export const notes = pgTable("notes", {
  id: serial("id").primaryKey(),
  content: text("content").notNull(),
  aiGeneratedTitle: text("ai_generated_title"),
  mode: text("mode").notNull(), // 'text', 'voice', 'image'
  userId: varchar("user_id").references(() => users.id),
  isShared: boolean("is_shared").default(false),
  shareId: varchar("share_id"), // For shareable links
  privacyLevel: text("privacy_level").default("private"), // 'private', 'shared', 'public'
  createdAt: timestamp("created_at").defaultNow().notNull(),
  audioUrl: text("audio_url"),
  mediaUrl: text("media_url"), // URL to uploaded media files (images, documents, etc.)
  transcription: text("transcription"),
  imageData: text("image_data"), // Base64 encoded image data
  aiEnhanced: boolean("ai_enhanced").default(false),
  aiSuggestion: text("ai_suggestion"),
  aiContext: text("ai_context"),
  richContext: text("rich_context"), // JSON string containing Google-style organized information
  isProcessing: boolean("is_processing").default(false), // True while AI is processing
  collectionId: integer("collection_id").references(() => collections.id),
  
  // Intelligence-v2: Vector storage for semantic search
  vectorDense: text("vector_dense"), // Dense vector embedding array format: [0.1,0.2,...]
  vectorSparse: text("vector_sparse"), // Sparse vector as JSON string
  intentVector: json("intent_vector").$type<{
    categories: Record<string, number>;
    confidence: number;
    reasoning: string;
  }>(),
  
  // Version control and data protection
  version: integer("version").default(1).notNull(),
  originalContent: text("original_content"), // Preserve original user input
  lastUserEdit: timestamp("last_user_edit").defaultNow(), // Track manual edits
  protectedContent: json("protected_content").$type<{
    userSections: string[]; // Content sections that should be preserved
    manualEdits: { timestamp: Date; content: string; }[];
    aiModifications: { timestamp: Date; type: string; description: string; }[];
  }>(),
  
  // Orthogonal AI upgrade metadata
  processingPath: text("processing_path"), // 'commerce' | 'memory'
  classificationScores: json("classification_scores").$type<Record<string, number>>(),
});

// Note versions for complete changelog and rollback capability
export const noteVersions = pgTable("note_versions", {
  id: serial("id").primaryKey(),
  noteId: integer("note_id").notNull().references(() => notes.id, { onDelete: 'cascade' }),
  version: integer("version").notNull(),
  content: text("content").notNull(),
  changeType: text("change_type").notNull(), // 'user_edit', 'ai_enhancement', 'ai_suggestion_applied', 'manual_rollback'
  changeDescription: text("change_description"), // Human-readable description of what changed
  changedBy: text("changed_by").default("user"), // 'user', 'ai_openai', 'ai_claude', 'system'
  preservedSections: json("preserved_sections").$type<string[]>(), // Content sections that were protected
  createdAt: timestamp("created_at").defaultNow().notNull(),
  
  // Metadata about the change
  confidence: integer("confidence"), // AI confidence level (1-100) for AI changes
  userApproved: boolean("user_approved"), // Whether user explicitly approved AI changes
  riskLevel: text("risk_level").default("low"), // 'low', 'medium', 'high' - based on content value analysis
});

export const todos = pgTable("todos", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  completed: boolean("completed").default(false),
  pinned: boolean("pinned").default(false),
  archived: boolean("archived").default(false),
  priority: text("priority").default("normal"), // "urgent", "normal", "low"
  
  // Enhanced time-sensitivity and reminder classification
  itemType: text("item_type").default("todo"), // "todo", "reminder"
  timeDue: timestamp("time_due"), // Specific due date/time (nullable for "not set")
  timeDependency: text("time_dependency"), // "none", "sequential", "parallel", "contingent"
  dependsOnTodoIds: json("depends_on_todo_ids").$type<number[]>(), // Array of todo IDs this depends on
  triggersTodoIds: json("triggers_todo_ids").$type<number[]>(), // Array of todo IDs triggered by completion
  
  // Sophisticated notification structure
  plannedNotificationStructure: json("planned_notification_structure").$type<{
    enabled: boolean;
    reminderCategory: "today" | "week" | "month" | "year" | "not_set";
    repeatPattern: "none" | "hourly" | "daily" | "weekly" | "monthly" | "annual";
    leadTimeNotifications: string[]; // e.g., ["1 hour before", "1 day before"]
    customSchedule?: {
      times: string[]; // specific times for repeating reminders
      daysOfWeek?: number[]; // for weekly patterns
      dayOfMonth?: number; // for monthly patterns
      monthOfYear?: number; // for annual patterns
    };
  }>().default({
    enabled: false,
    reminderCategory: "not_set",
    repeatPattern: "none",
    leadTimeNotifications: []
  }),
  
  // Enhanced reminder metadata
  isActiveReminder: boolean("is_active_reminder").default(false), // Shows in Reminders section
  lastNotificationSent: timestamp("last_notification_sent"),
  nextNotificationDue: timestamp("next_notification_due"),
  
  // Reminder state management
  reminderState: varchar("reminder_state").default("active"), // 'active', 'overdue', 'completed', 'dismissed', 'archived'
  archivedAt: timestamp("archived_at"),
  dismissedAt: timestamp("dismissed_at"),
  dueDate: timestamp("due_date"), // When the reminder is actually due
  recurrenceRule: text("recurrence_rule"), // RRULE format for recurring reminders
  
  noteId: integer("note_id").notNull().references(() => notes.id, { onDelete: 'cascade' }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const collections = pgTable("collections", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  icon: text("icon").default("folder"),
  color: text("color").default("blue"),
  iconUrl: text("icon_url"), // Custom icon image URL
  displayOrder: integer("display_order").default(0),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  
  // Intelligence-v2: Enhanced collection metadata
  collectionType: text("collection_type").default("standard"), // 'standard', 'smart', 'temporal', 'project'
  smartFilters: json("smart_filters").$type<{
    tags?: string[];
    contentTypes?: string[];
    dateRange?: { start: Date; end: Date };
    priority?: string[];
    autoInclude?: boolean;
  }>(),
  intelligenceMetadata: json("intelligence_metadata").$type<{
    patterns: Record<string, number>;
    relationships: string[];
    userBehavior: Record<string, any>;
    predictiveScore: number;
  }>(),
});

// Intelligence-v2: Collection items for smart organization
export const collectionItems = pgTable("collection_items", {
  id: serial("id").primaryKey(),
  collectionId: integer("collection_id").references(() => collections.id, { onDelete: 'cascade' }),
  sourceNoteId: integer("source_note_id").references(() => notes.id, { onDelete: 'cascade' }),
  rawText: text("raw_text"),
  normalisedJson: json("normalised_json").$type<{
    extractedEntities: Record<string, any>[];
    processedContent: string;
    intelligenceScore: number;
    relationships: string[];
  }>(),
  position: integer("position").default(0),
  completed: boolean("completed").default(false),
  intelligenceRating: integer("intelligence_rating").default(0), // 0-100 quality score
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const reminders = pgTable("reminders", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  reminderTime: timestamp("reminder_time").notNull(),
  isCompleted: boolean("is_completed").default(false),
  todoId: integer("todo_id").references(() => todos.id, { onDelete: 'cascade' }),
  noteId: integer("note_id").references(() => notes.id, { onDelete: 'cascade' }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const items = pgTable("items", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  type: text("type").notNull(), // 'book', 'movie', 'restaurant', 'product', 'place', 'person', 'concept'
  description: text("description"),
  context: text("context"), // Why this item was mentioned
  detailedContent: text("detailed_content"), // AI-generated detailed information
  sourceNoteId: integer("source_note_id").references(() => notes.id),
  collectionId: integer("collection_id").references(() => collections.id),
  isProcessed: boolean("is_processed").default(false), // Whether detailed content has been generated
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Session storage table for Replit Auth
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: json("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// User storage table for Replit Auth
export const users = pgTable("users", {
  id: varchar("id").primaryKey().notNull(),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  phoneNumber: varchar("phone_number"), // For future contact-based discovery
  personalBio: text("personal_bio"),
  preferences: json("preferences"),
  reminderSettings: json("reminder_settings").$type<{
    defaultLeadTimes: {
      general: number;
      pickup: number;
      appointment: number;
      medication: number;
      call: number;
      meeting: number;
      flight: number;
    };
    autoArchiveAfterDays: number;
    showOverdueReminders: boolean;
    enablePushNotifications: boolean;
  }>().default({
    defaultLeadTimes: {
      general: 10,
      pickup: 10,
      appointment: 30,
      medication: 0,
      call: 5,
      meeting: 15,
      flight: 120
    },
    autoArchiveAfterDays: 1,
    showOverdueReminders: true,
    enablePushNotifications: true
  }),
  developerSettings: json("developer_settings").default({
    enableDualAIProcessing: false,
    showAIComparison: false,
    debugMode: false
  }),
  onboardingCompleted: boolean("onboarding_completed").default(false),
  privacySettings: json("privacy_settings").default({
    includePrivateDataInSharedNotes: false,
    allowContactDiscovery: true,
    defaultNotePrivacy: "private"
  }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertNoteSchema = createInsertSchema(notes).omit({
  id: true,
  createdAt: true,
});

export const insertTodoSchema = createInsertSchema(todos).omit({
  id: true,
  createdAt: true,
});

export const insertCollectionSchema = createInsertSchema(collections).omit({
  id: true,
  createdAt: true,
});

export const insertItemSchema = createInsertSchema(items).omit({
  id: true,
  createdAt: true,
});

export const insertUserSchema = createInsertSchema(users).omit({
  createdAt: true,
  updatedAt: true,
});

export type InsertNote = z.infer<typeof insertNoteSchema>;
export type Note = typeof notes.$inferSelect;
export type InsertTodo = z.infer<typeof insertTodoSchema>;
export type Todo = typeof todos.$inferSelect;
export type InsertCollection = z.infer<typeof insertCollectionSchema>;
export type Collection = typeof collections.$inferSelect;
export type InsertItem = z.infer<typeof insertItemSchema>;
export type Item = typeof items.$inferSelect;
export type UpsertUser = typeof users.$inferInsert;
export type User = typeof users.$inferSelect;

export type InsertNoteVersion = typeof noteVersions.$inferInsert;
export type NoteVersion = typeof noteVersions.$inferSelect;

// Relations
export const notesRelations = relations(notes, ({ one, many }) => ({
  collection: one(collections, {
    fields: [notes.collectionId],
    references: [collections.id],
  }),
  user: one(users, {
    fields: [notes.userId],
    references: [users.id],
  }),
  todos: many(todos),
  items: many(items),
}));

export const usersRelations = relations(users, ({ many }) => ({
  notes: many(notes),
}));

export const todosRelations = relations(todos, ({ one }) => ({
  note: one(notes, {
    fields: [todos.noteId],
    references: [notes.id],
  }),
}));

export const collectionsRelations = relations(collections, ({ many }) => ({
  notes: many(notes),
  items: many(items),
}));

export const remindersRelations = relations(reminders, ({ one }) => ({
  todo: one(todos, {
    fields: [reminders.todoId],
    references: [todos.id],
  }),
  note: one(notes, {
    fields: [reminders.noteId],
    references: [notes.id],
  }),
}));

export const itemsRelations = relations(items, ({ one }) => ({
  sourceNote: one(notes, {
    fields: [items.sourceNoteId],
    references: [notes.id],
  }),
  collection: one(collections, {
    fields: [items.collectionId],
    references: [collections.id],
  }),
}));

export type NoteWithTodos = Note & {
  todos: Todo[];
  collection?: Collection;
  items?: Item[];
};

// Additional type exports for new tables  
export type Reminder = typeof reminders.$inferSelect;
export type InsertReminder = typeof reminders.$inferInsert;
```
